// Code generated by ent, DO NOT EDIT.

package repo

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Alijeyrad/simorq_backend/internal/repo/appointment"
	"github.com/Alijeyrad/simorq_backend/internal/repo/clinic"
	"github.com/Alijeyrad/simorq_backend/internal/repo/clinicmember"
	"github.com/Alijeyrad/simorq_backend/internal/repo/clinicpermission"
	"github.com/Alijeyrad/simorq_backend/internal/repo/clinicsettings"
	"github.com/Alijeyrad/simorq_backend/internal/repo/commissionrule"
	"github.com/Alijeyrad/simorq_backend/internal/repo/contactmessage"
	"github.com/Alijeyrad/simorq_backend/internal/repo/conversation"
	"github.com/Alijeyrad/simorq_backend/internal/repo/internpatientaccess"
	"github.com/Alijeyrad/simorq_backend/internal/repo/internprofile"
	"github.com/Alijeyrad/simorq_backend/internal/repo/interntask"
	"github.com/Alijeyrad/simorq_backend/internal/repo/interntaskfile"
	"github.com/Alijeyrad/simorq_backend/internal/repo/message"
	"github.com/Alijeyrad/simorq_backend/internal/repo/notification"
	"github.com/Alijeyrad/simorq_backend/internal/repo/notificationpref"
	"github.com/Alijeyrad/simorq_backend/internal/repo/patient"
	"github.com/Alijeyrad/simorq_backend/internal/repo/patientfile"
	"github.com/Alijeyrad/simorq_backend/internal/repo/patientprescription"
	"github.com/Alijeyrad/simorq_backend/internal/repo/patientreport"
	"github.com/Alijeyrad/simorq_backend/internal/repo/patienttest"
	"github.com/Alijeyrad/simorq_backend/internal/repo/paymentrequest"
	"github.com/Alijeyrad/simorq_backend/internal/repo/predicate"
	"github.com/Alijeyrad/simorq_backend/internal/repo/psychtest"
	"github.com/Alijeyrad/simorq_backend/internal/repo/recurringrule"
	"github.com/Alijeyrad/simorq_backend/internal/repo/therapistprofile"
	"github.com/Alijeyrad/simorq_backend/internal/repo/ticket"
	"github.com/Alijeyrad/simorq_backend/internal/repo/ticketmessage"
	"github.com/Alijeyrad/simorq_backend/internal/repo/timeslot"
	"github.com/Alijeyrad/simorq_backend/internal/repo/transaction"
	"github.com/Alijeyrad/simorq_backend/internal/repo/user"
	"github.com/Alijeyrad/simorq_backend/internal/repo/userdevice"
	"github.com/Alijeyrad/simorq_backend/internal/repo/usersession"
	"github.com/Alijeyrad/simorq_backend/internal/repo/wallet"
	"github.com/Alijeyrad/simorq_backend/internal/repo/withdrawalrequest"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointment         = "Appointment"
	TypeClinic              = "Clinic"
	TypeClinicMember        = "ClinicMember"
	TypeClinicPermission    = "ClinicPermission"
	TypeClinicSettings      = "ClinicSettings"
	TypeCommissionRule      = "CommissionRule"
	TypeContactMessage      = "ContactMessage"
	TypeConversation        = "Conversation"
	TypeInternPatientAccess = "InternPatientAccess"
	TypeInternProfile       = "InternProfile"
	TypeInternTask          = "InternTask"
	TypeInternTaskFile      = "InternTaskFile"
	TypeMessage             = "Message"
	TypeNotification        = "Notification"
	TypeNotificationPref    = "NotificationPref"
	TypePatient             = "Patient"
	TypePatientFile         = "PatientFile"
	TypePatientPrescription = "PatientPrescription"
	TypePatientReport       = "PatientReport"
	TypePatientTest         = "PatientTest"
	TypePaymentRequest      = "PaymentRequest"
	TypePsychTest           = "PsychTest"
	TypeRecurringRule       = "RecurringRule"
	TypeTherapistProfile    = "TherapistProfile"
	TypeTicket              = "Ticket"
	TypeTicketMessage       = "TicketMessage"
	TypeTimeSlot            = "TimeSlot"
	TypeTransaction         = "Transaction"
	TypeUser                = "User"
	TypeUserDevice          = "UserDevice"
	TypeUserSession         = "UserSession"
	TypeWallet              = "Wallet"
	TypeWithdrawalRequest   = "WithdrawalRequest"
)

// AppointmentMutation represents an operation that mutates the Appointment nodes in the graph.
type AppointmentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	clinic_id           *uuid.UUID
	therapist_id        *uuid.UUID
	patient_id          *uuid.UUID
	time_slot_id        *uuid.UUID
	start_time          *time.Time
	end_time            *time.Time
	status              *appointment.Status
	session_price       *int64
	addsession_price    *int64
	reservation_fee     *int64
	addreservation_fee  *int64
	payment_status      *appointment.PaymentStatus
	notes               *string
	cancellation_reason *string
	cancel_requested_by *appointment.CancelRequestedBy
	cancelled_at        *time.Time
	cancellation_fee    *int64
	addcancellation_fee *int64
	completed_at        *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Appointment, error)
	predicates          []predicate.Appointment
}

var _ ent.Mutation = (*AppointmentMutation)(nil)

// appointmentOption allows management of the mutation configuration using functional options.
type appointmentOption func(*AppointmentMutation)

// newAppointmentMutation creates new mutation for the Appointment entity.
func newAppointmentMutation(c config, op Op, opts ...appointmentOption) *AppointmentMutation {
	m := &AppointmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentID sets the ID field of the mutation.
func withAppointmentID(id uuid.UUID) appointmentOption {
	return func(m *AppointmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Appointment
		)
		m.oldValue = func(ctx context.Context) (*Appointment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Appointment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointment sets the old Appointment of the mutation.
func withAppointment(node *Appointment) appointmentOption {
	return func(m *AppointmentMutation) {
		m.oldValue = func(context.Context) (*Appointment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Appointment entities.
func (m *AppointmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppointmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppointmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Appointment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppointmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppointmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppointmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppointmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppointmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppointmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *AppointmentMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *AppointmentMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *AppointmentMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetTherapistID sets the "therapist_id" field.
func (m *AppointmentMutation) SetTherapistID(u uuid.UUID) {
	m.therapist_id = &u
}

// TherapistID returns the value of the "therapist_id" field in the mutation.
func (m *AppointmentMutation) TherapistID() (r uuid.UUID, exists bool) {
	v := m.therapist_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTherapistID returns the old "therapist_id" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldTherapistID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTherapistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTherapistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTherapistID: %w", err)
	}
	return oldValue.TherapistID, nil
}

// ResetTherapistID resets all changes to the "therapist_id" field.
func (m *AppointmentMutation) ResetTherapistID() {
	m.therapist_id = nil
}

// SetPatientID sets the "patient_id" field.
func (m *AppointmentMutation) SetPatientID(u uuid.UUID) {
	m.patient_id = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *AppointmentMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *AppointmentMutation) ResetPatientID() {
	m.patient_id = nil
}

// SetTimeSlotID sets the "time_slot_id" field.
func (m *AppointmentMutation) SetTimeSlotID(u uuid.UUID) {
	m.time_slot_id = &u
}

// TimeSlotID returns the value of the "time_slot_id" field in the mutation.
func (m *AppointmentMutation) TimeSlotID() (r uuid.UUID, exists bool) {
	v := m.time_slot_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeSlotID returns the old "time_slot_id" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldTimeSlotID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeSlotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeSlotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeSlotID: %w", err)
	}
	return oldValue.TimeSlotID, nil
}

// ClearTimeSlotID clears the value of the "time_slot_id" field.
func (m *AppointmentMutation) ClearTimeSlotID() {
	m.time_slot_id = nil
	m.clearedFields[appointment.FieldTimeSlotID] = struct{}{}
}

// TimeSlotIDCleared returns if the "time_slot_id" field was cleared in this mutation.
func (m *AppointmentMutation) TimeSlotIDCleared() bool {
	_, ok := m.clearedFields[appointment.FieldTimeSlotID]
	return ok
}

// ResetTimeSlotID resets all changes to the "time_slot_id" field.
func (m *AppointmentMutation) ResetTimeSlotID() {
	m.time_slot_id = nil
	delete(m.clearedFields, appointment.FieldTimeSlotID)
}

// SetStartTime sets the "start_time" field.
func (m *AppointmentMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *AppointmentMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *AppointmentMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *AppointmentMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *AppointmentMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *AppointmentMutation) ResetEndTime() {
	m.end_time = nil
}

// SetStatus sets the "status" field.
func (m *AppointmentMutation) SetStatus(a appointment.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AppointmentMutation) Status() (r appointment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldStatus(ctx context.Context) (v appointment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppointmentMutation) ResetStatus() {
	m.status = nil
}

// SetSessionPrice sets the "session_price" field.
func (m *AppointmentMutation) SetSessionPrice(i int64) {
	m.session_price = &i
	m.addsession_price = nil
}

// SessionPrice returns the value of the "session_price" field in the mutation.
func (m *AppointmentMutation) SessionPrice() (r int64, exists bool) {
	v := m.session_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionPrice returns the old "session_price" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldSessionPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionPrice: %w", err)
	}
	return oldValue.SessionPrice, nil
}

// AddSessionPrice adds i to the "session_price" field.
func (m *AppointmentMutation) AddSessionPrice(i int64) {
	if m.addsession_price != nil {
		*m.addsession_price += i
	} else {
		m.addsession_price = &i
	}
}

// AddedSessionPrice returns the value that was added to the "session_price" field in this mutation.
func (m *AppointmentMutation) AddedSessionPrice() (r int64, exists bool) {
	v := m.addsession_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessionPrice resets all changes to the "session_price" field.
func (m *AppointmentMutation) ResetSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
}

// SetReservationFee sets the "reservation_fee" field.
func (m *AppointmentMutation) SetReservationFee(i int64) {
	m.reservation_fee = &i
	m.addreservation_fee = nil
}

// ReservationFee returns the value of the "reservation_fee" field in the mutation.
func (m *AppointmentMutation) ReservationFee() (r int64, exists bool) {
	v := m.reservation_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationFee returns the old "reservation_fee" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldReservationFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationFee: %w", err)
	}
	return oldValue.ReservationFee, nil
}

// AddReservationFee adds i to the "reservation_fee" field.
func (m *AppointmentMutation) AddReservationFee(i int64) {
	if m.addreservation_fee != nil {
		*m.addreservation_fee += i
	} else {
		m.addreservation_fee = &i
	}
}

// AddedReservationFee returns the value that was added to the "reservation_fee" field in this mutation.
func (m *AppointmentMutation) AddedReservationFee() (r int64, exists bool) {
	v := m.addreservation_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetReservationFee resets all changes to the "reservation_fee" field.
func (m *AppointmentMutation) ResetReservationFee() {
	m.reservation_fee = nil
	m.addreservation_fee = nil
}

// SetPaymentStatus sets the "payment_status" field.
func (m *AppointmentMutation) SetPaymentStatus(as appointment.PaymentStatus) {
	m.payment_status = &as
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *AppointmentMutation) PaymentStatus() (r appointment.PaymentStatus, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldPaymentStatus(ctx context.Context) (v appointment.PaymentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *AppointmentMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetNotes sets the "notes" field.
func (m *AppointmentMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *AppointmentMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *AppointmentMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[appointment.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *AppointmentMutation) NotesCleared() bool {
	_, ok := m.clearedFields[appointment.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *AppointmentMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, appointment.FieldNotes)
}

// SetCancellationReason sets the "cancellation_reason" field.
func (m *AppointmentMutation) SetCancellationReason(s string) {
	m.cancellation_reason = &s
}

// CancellationReason returns the value of the "cancellation_reason" field in the mutation.
func (m *AppointmentMutation) CancellationReason() (r string, exists bool) {
	v := m.cancellation_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellationReason returns the old "cancellation_reason" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldCancellationReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellationReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellationReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellationReason: %w", err)
	}
	return oldValue.CancellationReason, nil
}

// ClearCancellationReason clears the value of the "cancellation_reason" field.
func (m *AppointmentMutation) ClearCancellationReason() {
	m.cancellation_reason = nil
	m.clearedFields[appointment.FieldCancellationReason] = struct{}{}
}

// CancellationReasonCleared returns if the "cancellation_reason" field was cleared in this mutation.
func (m *AppointmentMutation) CancellationReasonCleared() bool {
	_, ok := m.clearedFields[appointment.FieldCancellationReason]
	return ok
}

// ResetCancellationReason resets all changes to the "cancellation_reason" field.
func (m *AppointmentMutation) ResetCancellationReason() {
	m.cancellation_reason = nil
	delete(m.clearedFields, appointment.FieldCancellationReason)
}

// SetCancelRequestedBy sets the "cancel_requested_by" field.
func (m *AppointmentMutation) SetCancelRequestedBy(arb appointment.CancelRequestedBy) {
	m.cancel_requested_by = &arb
}

// CancelRequestedBy returns the value of the "cancel_requested_by" field in the mutation.
func (m *AppointmentMutation) CancelRequestedBy() (r appointment.CancelRequestedBy, exists bool) {
	v := m.cancel_requested_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelRequestedBy returns the old "cancel_requested_by" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldCancelRequestedBy(ctx context.Context) (v *appointment.CancelRequestedBy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelRequestedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelRequestedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelRequestedBy: %w", err)
	}
	return oldValue.CancelRequestedBy, nil
}

// ClearCancelRequestedBy clears the value of the "cancel_requested_by" field.
func (m *AppointmentMutation) ClearCancelRequestedBy() {
	m.cancel_requested_by = nil
	m.clearedFields[appointment.FieldCancelRequestedBy] = struct{}{}
}

// CancelRequestedByCleared returns if the "cancel_requested_by" field was cleared in this mutation.
func (m *AppointmentMutation) CancelRequestedByCleared() bool {
	_, ok := m.clearedFields[appointment.FieldCancelRequestedBy]
	return ok
}

// ResetCancelRequestedBy resets all changes to the "cancel_requested_by" field.
func (m *AppointmentMutation) ResetCancelRequestedBy() {
	m.cancel_requested_by = nil
	delete(m.clearedFields, appointment.FieldCancelRequestedBy)
}

// SetCancelledAt sets the "cancelled_at" field.
func (m *AppointmentMutation) SetCancelledAt(t time.Time) {
	m.cancelled_at = &t
}

// CancelledAt returns the value of the "cancelled_at" field in the mutation.
func (m *AppointmentMutation) CancelledAt() (r time.Time, exists bool) {
	v := m.cancelled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelledAt returns the old "cancelled_at" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldCancelledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelledAt: %w", err)
	}
	return oldValue.CancelledAt, nil
}

// ClearCancelledAt clears the value of the "cancelled_at" field.
func (m *AppointmentMutation) ClearCancelledAt() {
	m.cancelled_at = nil
	m.clearedFields[appointment.FieldCancelledAt] = struct{}{}
}

// CancelledAtCleared returns if the "cancelled_at" field was cleared in this mutation.
func (m *AppointmentMutation) CancelledAtCleared() bool {
	_, ok := m.clearedFields[appointment.FieldCancelledAt]
	return ok
}

// ResetCancelledAt resets all changes to the "cancelled_at" field.
func (m *AppointmentMutation) ResetCancelledAt() {
	m.cancelled_at = nil
	delete(m.clearedFields, appointment.FieldCancelledAt)
}

// SetCancellationFee sets the "cancellation_fee" field.
func (m *AppointmentMutation) SetCancellationFee(i int64) {
	m.cancellation_fee = &i
	m.addcancellation_fee = nil
}

// CancellationFee returns the value of the "cancellation_fee" field in the mutation.
func (m *AppointmentMutation) CancellationFee() (r int64, exists bool) {
	v := m.cancellation_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellationFee returns the old "cancellation_fee" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldCancellationFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellationFee: %w", err)
	}
	return oldValue.CancellationFee, nil
}

// AddCancellationFee adds i to the "cancellation_fee" field.
func (m *AppointmentMutation) AddCancellationFee(i int64) {
	if m.addcancellation_fee != nil {
		*m.addcancellation_fee += i
	} else {
		m.addcancellation_fee = &i
	}
}

// AddedCancellationFee returns the value that was added to the "cancellation_fee" field in this mutation.
func (m *AppointmentMutation) AddedCancellationFee() (r int64, exists bool) {
	v := m.addcancellation_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetCancellationFee resets all changes to the "cancellation_fee" field.
func (m *AppointmentMutation) ResetCancellationFee() {
	m.cancellation_fee = nil
	m.addcancellation_fee = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *AppointmentMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *AppointmentMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *AppointmentMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[appointment.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *AppointmentMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[appointment.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *AppointmentMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, appointment.FieldCompletedAt)
}

// Where appends a list predicates to the AppointmentMutation builder.
func (m *AppointmentMutation) Where(ps ...predicate.Appointment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppointmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppointmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Appointment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppointmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppointmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Appointment).
func (m *AppointmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppointmentMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, appointment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appointment.FieldUpdatedAt)
	}
	if m.clinic_id != nil {
		fields = append(fields, appointment.FieldClinicID)
	}
	if m.therapist_id != nil {
		fields = append(fields, appointment.FieldTherapistID)
	}
	if m.patient_id != nil {
		fields = append(fields, appointment.FieldPatientID)
	}
	if m.time_slot_id != nil {
		fields = append(fields, appointment.FieldTimeSlotID)
	}
	if m.start_time != nil {
		fields = append(fields, appointment.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, appointment.FieldEndTime)
	}
	if m.status != nil {
		fields = append(fields, appointment.FieldStatus)
	}
	if m.session_price != nil {
		fields = append(fields, appointment.FieldSessionPrice)
	}
	if m.reservation_fee != nil {
		fields = append(fields, appointment.FieldReservationFee)
	}
	if m.payment_status != nil {
		fields = append(fields, appointment.FieldPaymentStatus)
	}
	if m.notes != nil {
		fields = append(fields, appointment.FieldNotes)
	}
	if m.cancellation_reason != nil {
		fields = append(fields, appointment.FieldCancellationReason)
	}
	if m.cancel_requested_by != nil {
		fields = append(fields, appointment.FieldCancelRequestedBy)
	}
	if m.cancelled_at != nil {
		fields = append(fields, appointment.FieldCancelledAt)
	}
	if m.cancellation_fee != nil {
		fields = append(fields, appointment.FieldCancellationFee)
	}
	if m.completed_at != nil {
		fields = append(fields, appointment.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppointmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldCreatedAt:
		return m.CreatedAt()
	case appointment.FieldUpdatedAt:
		return m.UpdatedAt()
	case appointment.FieldClinicID:
		return m.ClinicID()
	case appointment.FieldTherapistID:
		return m.TherapistID()
	case appointment.FieldPatientID:
		return m.PatientID()
	case appointment.FieldTimeSlotID:
		return m.TimeSlotID()
	case appointment.FieldStartTime:
		return m.StartTime()
	case appointment.FieldEndTime:
		return m.EndTime()
	case appointment.FieldStatus:
		return m.Status()
	case appointment.FieldSessionPrice:
		return m.SessionPrice()
	case appointment.FieldReservationFee:
		return m.ReservationFee()
	case appointment.FieldPaymentStatus:
		return m.PaymentStatus()
	case appointment.FieldNotes:
		return m.Notes()
	case appointment.FieldCancellationReason:
		return m.CancellationReason()
	case appointment.FieldCancelRequestedBy:
		return m.CancelRequestedBy()
	case appointment.FieldCancelledAt:
		return m.CancelledAt()
	case appointment.FieldCancellationFee:
		return m.CancellationFee()
	case appointment.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppointmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appointment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appointment.FieldClinicID:
		return m.OldClinicID(ctx)
	case appointment.FieldTherapistID:
		return m.OldTherapistID(ctx)
	case appointment.FieldPatientID:
		return m.OldPatientID(ctx)
	case appointment.FieldTimeSlotID:
		return m.OldTimeSlotID(ctx)
	case appointment.FieldStartTime:
		return m.OldStartTime(ctx)
	case appointment.FieldEndTime:
		return m.OldEndTime(ctx)
	case appointment.FieldStatus:
		return m.OldStatus(ctx)
	case appointment.FieldSessionPrice:
		return m.OldSessionPrice(ctx)
	case appointment.FieldReservationFee:
		return m.OldReservationFee(ctx)
	case appointment.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case appointment.FieldNotes:
		return m.OldNotes(ctx)
	case appointment.FieldCancellationReason:
		return m.OldCancellationReason(ctx)
	case appointment.FieldCancelRequestedBy:
		return m.OldCancelRequestedBy(ctx)
	case appointment.FieldCancelledAt:
		return m.OldCancelledAt(ctx)
	case appointment.FieldCancellationFee:
		return m.OldCancellationFee(ctx)
	case appointment.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Appointment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appointment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appointment.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case appointment.FieldTherapistID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTherapistID(v)
		return nil
	case appointment.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case appointment.FieldTimeSlotID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeSlotID(v)
		return nil
	case appointment.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case appointment.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case appointment.FieldStatus:
		v, ok := value.(appointment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case appointment.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionPrice(v)
		return nil
	case appointment.FieldReservationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationFee(v)
		return nil
	case appointment.FieldPaymentStatus:
		v, ok := value.(appointment.PaymentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case appointment.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case appointment.FieldCancellationReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellationReason(v)
		return nil
	case appointment.FieldCancelRequestedBy:
		v, ok := value.(appointment.CancelRequestedBy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelRequestedBy(v)
		return nil
	case appointment.FieldCancelledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelledAt(v)
		return nil
	case appointment.FieldCancellationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellationFee(v)
		return nil
	case appointment.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppointmentMutation) AddedFields() []string {
	var fields []string
	if m.addsession_price != nil {
		fields = append(fields, appointment.FieldSessionPrice)
	}
	if m.addreservation_fee != nil {
		fields = append(fields, appointment.FieldReservationFee)
	}
	if m.addcancellation_fee != nil {
		fields = append(fields, appointment.FieldCancellationFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppointmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldSessionPrice:
		return m.AddedSessionPrice()
	case appointment.FieldReservationFee:
		return m.AddedReservationFee()
	case appointment.FieldCancellationFee:
		return m.AddedCancellationFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionPrice(v)
		return nil
	case appointment.FieldReservationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationFee(v)
		return nil
	case appointment.FieldCancellationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellationFee(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppointmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appointment.FieldTimeSlotID) {
		fields = append(fields, appointment.FieldTimeSlotID)
	}
	if m.FieldCleared(appointment.FieldNotes) {
		fields = append(fields, appointment.FieldNotes)
	}
	if m.FieldCleared(appointment.FieldCancellationReason) {
		fields = append(fields, appointment.FieldCancellationReason)
	}
	if m.FieldCleared(appointment.FieldCancelRequestedBy) {
		fields = append(fields, appointment.FieldCancelRequestedBy)
	}
	if m.FieldCleared(appointment.FieldCancelledAt) {
		fields = append(fields, appointment.FieldCancelledAt)
	}
	if m.FieldCleared(appointment.FieldCompletedAt) {
		fields = append(fields, appointment.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppointmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentMutation) ClearField(name string) error {
	switch name {
	case appointment.FieldTimeSlotID:
		m.ClearTimeSlotID()
		return nil
	case appointment.FieldNotes:
		m.ClearNotes()
		return nil
	case appointment.FieldCancellationReason:
		m.ClearCancellationReason()
		return nil
	case appointment.FieldCancelRequestedBy:
		m.ClearCancelRequestedBy()
		return nil
	case appointment.FieldCancelledAt:
		m.ClearCancelledAt()
		return nil
	case appointment.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Appointment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppointmentMutation) ResetField(name string) error {
	switch name {
	case appointment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appointment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appointment.FieldClinicID:
		m.ResetClinicID()
		return nil
	case appointment.FieldTherapistID:
		m.ResetTherapistID()
		return nil
	case appointment.FieldPatientID:
		m.ResetPatientID()
		return nil
	case appointment.FieldTimeSlotID:
		m.ResetTimeSlotID()
		return nil
	case appointment.FieldStartTime:
		m.ResetStartTime()
		return nil
	case appointment.FieldEndTime:
		m.ResetEndTime()
		return nil
	case appointment.FieldStatus:
		m.ResetStatus()
		return nil
	case appointment.FieldSessionPrice:
		m.ResetSessionPrice()
		return nil
	case appointment.FieldReservationFee:
		m.ResetReservationFee()
		return nil
	case appointment.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case appointment.FieldNotes:
		m.ResetNotes()
		return nil
	case appointment.FieldCancellationReason:
		m.ResetCancellationReason()
		return nil
	case appointment.FieldCancelRequestedBy:
		m.ResetCancelRequestedBy()
		return nil
	case appointment.FieldCancelledAt:
		m.ResetCancelledAt()
		return nil
	case appointment.FieldCancellationFee:
		m.ResetCancellationFee()
		return nil
	case appointment.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppointmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppointmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppointmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppointmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppointmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppointmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppointmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Appointment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppointmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Appointment edge %s", name)
}

// ClinicMutation represents an operation that mutates the Clinic nodes in the graph.
type ClinicMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	slug               *string
	description        *string
	logo_key           *string
	phone              *string
	address            *string
	city               *string
	province           *string
	is_active          *bool
	is_verified        *bool
	clearedFields      map[string]struct{}
	members            map[uuid.UUID]struct{}
	removedmembers     map[uuid.UUID]struct{}
	clearedmembers     bool
	settings           *uuid.UUID
	clearedsettings    bool
	permissions        map[uuid.UUID]struct{}
	removedpermissions map[uuid.UUID]struct{}
	clearedpermissions bool
	patients           map[uuid.UUID]struct{}
	removedpatients    map[uuid.UUID]struct{}
	clearedpatients    bool
	done               bool
	oldValue           func(context.Context) (*Clinic, error)
	predicates         []predicate.Clinic
}

var _ ent.Mutation = (*ClinicMutation)(nil)

// clinicOption allows management of the mutation configuration using functional options.
type clinicOption func(*ClinicMutation)

// newClinicMutation creates new mutation for the Clinic entity.
func newClinicMutation(c config, op Op, opts ...clinicOption) *ClinicMutation {
	m := &ClinicMutation{
		config:        c,
		op:            op,
		typ:           TypeClinic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicID sets the ID field of the mutation.
func withClinicID(id uuid.UUID) clinicOption {
	return func(m *ClinicMutation) {
		var (
			err   error
			once  sync.Once
			value *Clinic
		)
		m.oldValue = func(ctx context.Context) (*Clinic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Clinic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinic sets the old Clinic of the mutation.
func withClinic(node *Clinic) clinicOption {
	return func(m *ClinicMutation) {
		m.oldValue = func(context.Context) (*Clinic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Clinic entities.
func (m *ClinicMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Clinic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ClinicMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClinicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClinicMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClinicMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClinicMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClinicMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ClinicMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ClinicMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ClinicMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[clinic.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ClinicMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[clinic.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ClinicMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, clinic.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ClinicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClinicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClinicMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *ClinicMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ClinicMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ClinicMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *ClinicMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClinicMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ClinicMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[clinic.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ClinicMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[clinic.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ClinicMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, clinic.FieldDescription)
}

// SetLogoKey sets the "logo_key" field.
func (m *ClinicMutation) SetLogoKey(s string) {
	m.logo_key = &s
}

// LogoKey returns the value of the "logo_key" field in the mutation.
func (m *ClinicMutation) LogoKey() (r string, exists bool) {
	v := m.logo_key
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoKey returns the old "logo_key" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldLogoKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoKey: %w", err)
	}
	return oldValue.LogoKey, nil
}

// ClearLogoKey clears the value of the "logo_key" field.
func (m *ClinicMutation) ClearLogoKey() {
	m.logo_key = nil
	m.clearedFields[clinic.FieldLogoKey] = struct{}{}
}

// LogoKeyCleared returns if the "logo_key" field was cleared in this mutation.
func (m *ClinicMutation) LogoKeyCleared() bool {
	_, ok := m.clearedFields[clinic.FieldLogoKey]
	return ok
}

// ResetLogoKey resets all changes to the "logo_key" field.
func (m *ClinicMutation) ResetLogoKey() {
	m.logo_key = nil
	delete(m.clearedFields, clinic.FieldLogoKey)
}

// SetPhone sets the "phone" field.
func (m *ClinicMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ClinicMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *ClinicMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[clinic.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *ClinicMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[clinic.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *ClinicMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, clinic.FieldPhone)
}

// SetAddress sets the "address" field.
func (m *ClinicMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ClinicMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ClinicMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[clinic.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ClinicMutation) AddressCleared() bool {
	_, ok := m.clearedFields[clinic.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ClinicMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, clinic.FieldAddress)
}

// SetCity sets the "city" field.
func (m *ClinicMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *ClinicMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *ClinicMutation) ClearCity() {
	m.city = nil
	m.clearedFields[clinic.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *ClinicMutation) CityCleared() bool {
	_, ok := m.clearedFields[clinic.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *ClinicMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, clinic.FieldCity)
}

// SetProvince sets the "province" field.
func (m *ClinicMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *ClinicMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldProvince(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *ClinicMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[clinic.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *ClinicMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[clinic.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *ClinicMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, clinic.FieldProvince)
}

// SetIsActive sets the "is_active" field.
func (m *ClinicMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ClinicMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ClinicMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *ClinicMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *ClinicMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the Clinic entity.
// If the Clinic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *ClinicMutation) ResetIsVerified() {
	m.is_verified = nil
}

// AddMemberIDs adds the "members" edge to the ClinicMember entity by ids.
func (m *ClinicMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the ClinicMember entity.
func (m *ClinicMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the ClinicMember entity was cleared.
func (m *ClinicMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the ClinicMember entity by IDs.
func (m *ClinicMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the ClinicMember entity.
func (m *ClinicMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ClinicMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ClinicMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// SetSettingsID sets the "settings" edge to the ClinicSettings entity by id.
func (m *ClinicMutation) SetSettingsID(id uuid.UUID) {
	m.settings = &id
}

// ClearSettings clears the "settings" edge to the ClinicSettings entity.
func (m *ClinicMutation) ClearSettings() {
	m.clearedsettings = true
}

// SettingsCleared reports if the "settings" edge to the ClinicSettings entity was cleared.
func (m *ClinicMutation) SettingsCleared() bool {
	return m.clearedsettings
}

// SettingsID returns the "settings" edge ID in the mutation.
func (m *ClinicMutation) SettingsID() (id uuid.UUID, exists bool) {
	if m.settings != nil {
		return *m.settings, true
	}
	return
}

// SettingsIDs returns the "settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingsID instead. It exists only for internal usage by the builders.
func (m *ClinicMutation) SettingsIDs() (ids []uuid.UUID) {
	if id := m.settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettings resets all changes to the "settings" edge.
func (m *ClinicMutation) ResetSettings() {
	m.settings = nil
	m.clearedsettings = false
}

// AddPermissionIDs adds the "permissions" edge to the ClinicPermission entity by ids.
func (m *ClinicMutation) AddPermissionIDs(ids ...uuid.UUID) {
	if m.permissions == nil {
		m.permissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the ClinicPermission entity.
func (m *ClinicMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the ClinicPermission entity was cleared.
func (m *ClinicMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the ClinicPermission entity by IDs.
func (m *ClinicMutation) RemovePermissionIDs(ids ...uuid.UUID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the ClinicPermission entity.
func (m *ClinicMutation) RemovedPermissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *ClinicMutation) PermissionsIDs() (ids []uuid.UUID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *ClinicMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddPatientIDs adds the "patients" edge to the Patient entity by ids.
func (m *ClinicMutation) AddPatientIDs(ids ...uuid.UUID) {
	if m.patients == nil {
		m.patients = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.patients[ids[i]] = struct{}{}
	}
}

// ClearPatients clears the "patients" edge to the Patient entity.
func (m *ClinicMutation) ClearPatients() {
	m.clearedpatients = true
}

// PatientsCleared reports if the "patients" edge to the Patient entity was cleared.
func (m *ClinicMutation) PatientsCleared() bool {
	return m.clearedpatients
}

// RemovePatientIDs removes the "patients" edge to the Patient entity by IDs.
func (m *ClinicMutation) RemovePatientIDs(ids ...uuid.UUID) {
	if m.removedpatients == nil {
		m.removedpatients = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.patients, ids[i])
		m.removedpatients[ids[i]] = struct{}{}
	}
}

// RemovedPatients returns the removed IDs of the "patients" edge to the Patient entity.
func (m *ClinicMutation) RemovedPatientsIDs() (ids []uuid.UUID) {
	for id := range m.removedpatients {
		ids = append(ids, id)
	}
	return
}

// PatientsIDs returns the "patients" edge IDs in the mutation.
func (m *ClinicMutation) PatientsIDs() (ids []uuid.UUID) {
	for id := range m.patients {
		ids = append(ids, id)
	}
	return
}

// ResetPatients resets all changes to the "patients" edge.
func (m *ClinicMutation) ResetPatients() {
	m.patients = nil
	m.clearedpatients = false
	m.removedpatients = nil
}

// Where appends a list predicates to the ClinicMutation builder.
func (m *ClinicMutation) Where(ps ...predicate.Clinic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClinicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClinicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Clinic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClinicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClinicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Clinic).
func (m *ClinicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, clinic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clinic.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, clinic.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, clinic.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, clinic.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, clinic.FieldDescription)
	}
	if m.logo_key != nil {
		fields = append(fields, clinic.FieldLogoKey)
	}
	if m.phone != nil {
		fields = append(fields, clinic.FieldPhone)
	}
	if m.address != nil {
		fields = append(fields, clinic.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, clinic.FieldCity)
	}
	if m.province != nil {
		fields = append(fields, clinic.FieldProvince)
	}
	if m.is_active != nil {
		fields = append(fields, clinic.FieldIsActive)
	}
	if m.is_verified != nil {
		fields = append(fields, clinic.FieldIsVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinic.FieldCreatedAt:
		return m.CreatedAt()
	case clinic.FieldUpdatedAt:
		return m.UpdatedAt()
	case clinic.FieldDeletedAt:
		return m.DeletedAt()
	case clinic.FieldName:
		return m.Name()
	case clinic.FieldSlug:
		return m.Slug()
	case clinic.FieldDescription:
		return m.Description()
	case clinic.FieldLogoKey:
		return m.LogoKey()
	case clinic.FieldPhone:
		return m.Phone()
	case clinic.FieldAddress:
		return m.Address()
	case clinic.FieldCity:
		return m.City()
	case clinic.FieldProvince:
		return m.Province()
	case clinic.FieldIsActive:
		return m.IsActive()
	case clinic.FieldIsVerified:
		return m.IsVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clinic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case clinic.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case clinic.FieldName:
		return m.OldName(ctx)
	case clinic.FieldSlug:
		return m.OldSlug(ctx)
	case clinic.FieldDescription:
		return m.OldDescription(ctx)
	case clinic.FieldLogoKey:
		return m.OldLogoKey(ctx)
	case clinic.FieldPhone:
		return m.OldPhone(ctx)
	case clinic.FieldAddress:
		return m.OldAddress(ctx)
	case clinic.FieldCity:
		return m.OldCity(ctx)
	case clinic.FieldProvince:
		return m.OldProvince(ctx)
	case clinic.FieldIsActive:
		return m.OldIsActive(ctx)
	case clinic.FieldIsVerified:
		return m.OldIsVerified(ctx)
	}
	return nil, fmt.Errorf("unknown Clinic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clinic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case clinic.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case clinic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case clinic.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case clinic.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case clinic.FieldLogoKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoKey(v)
		return nil
	case clinic.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case clinic.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case clinic.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case clinic.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case clinic.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case clinic.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	}
	return fmt.Errorf("unknown Clinic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Clinic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clinic.FieldDeletedAt) {
		fields = append(fields, clinic.FieldDeletedAt)
	}
	if m.FieldCleared(clinic.FieldDescription) {
		fields = append(fields, clinic.FieldDescription)
	}
	if m.FieldCleared(clinic.FieldLogoKey) {
		fields = append(fields, clinic.FieldLogoKey)
	}
	if m.FieldCleared(clinic.FieldPhone) {
		fields = append(fields, clinic.FieldPhone)
	}
	if m.FieldCleared(clinic.FieldAddress) {
		fields = append(fields, clinic.FieldAddress)
	}
	if m.FieldCleared(clinic.FieldCity) {
		fields = append(fields, clinic.FieldCity)
	}
	if m.FieldCleared(clinic.FieldProvince) {
		fields = append(fields, clinic.FieldProvince)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicMutation) ClearField(name string) error {
	switch name {
	case clinic.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case clinic.FieldDescription:
		m.ClearDescription()
		return nil
	case clinic.FieldLogoKey:
		m.ClearLogoKey()
		return nil
	case clinic.FieldPhone:
		m.ClearPhone()
		return nil
	case clinic.FieldAddress:
		m.ClearAddress()
		return nil
	case clinic.FieldCity:
		m.ClearCity()
		return nil
	case clinic.FieldProvince:
		m.ClearProvince()
		return nil
	}
	return fmt.Errorf("unknown Clinic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicMutation) ResetField(name string) error {
	switch name {
	case clinic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clinic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case clinic.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case clinic.FieldName:
		m.ResetName()
		return nil
	case clinic.FieldSlug:
		m.ResetSlug()
		return nil
	case clinic.FieldDescription:
		m.ResetDescription()
		return nil
	case clinic.FieldLogoKey:
		m.ResetLogoKey()
		return nil
	case clinic.FieldPhone:
		m.ResetPhone()
		return nil
	case clinic.FieldAddress:
		m.ResetAddress()
		return nil
	case clinic.FieldCity:
		m.ResetCity()
		return nil
	case clinic.FieldProvince:
		m.ResetProvince()
		return nil
	case clinic.FieldIsActive:
		m.ResetIsActive()
		return nil
	case clinic.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	}
	return fmt.Errorf("unknown Clinic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.members != nil {
		edges = append(edges, clinic.EdgeMembers)
	}
	if m.settings != nil {
		edges = append(edges, clinic.EdgeSettings)
	}
	if m.permissions != nil {
		edges = append(edges, clinic.EdgePermissions)
	}
	if m.patients != nil {
		edges = append(edges, clinic.EdgePatients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinic.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgeSettings:
		if id := m.settings; id != nil {
			return []ent.Value{*id}
		}
	case clinic.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgePatients:
		ids := make([]ent.Value, 0, len(m.patients))
		for id := range m.patients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, clinic.EdgeMembers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, clinic.EdgePermissions)
	}
	if m.removedpatients != nil {
		edges = append(edges, clinic.EdgePatients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clinic.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case clinic.EdgePatients:
		ids := make([]ent.Value, 0, len(m.removedpatients))
		for id := range m.removedpatients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmembers {
		edges = append(edges, clinic.EdgeMembers)
	}
	if m.clearedsettings {
		edges = append(edges, clinic.EdgeSettings)
	}
	if m.clearedpermissions {
		edges = append(edges, clinic.EdgePermissions)
	}
	if m.clearedpatients {
		edges = append(edges, clinic.EdgePatients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicMutation) EdgeCleared(name string) bool {
	switch name {
	case clinic.EdgeMembers:
		return m.clearedmembers
	case clinic.EdgeSettings:
		return m.clearedsettings
	case clinic.EdgePermissions:
		return m.clearedpermissions
	case clinic.EdgePatients:
		return m.clearedpatients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicMutation) ClearEdge(name string) error {
	switch name {
	case clinic.EdgeSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Clinic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicMutation) ResetEdge(name string) error {
	switch name {
	case clinic.EdgeMembers:
		m.ResetMembers()
		return nil
	case clinic.EdgeSettings:
		m.ResetSettings()
		return nil
	case clinic.EdgePermissions:
		m.ResetPermissions()
		return nil
	case clinic.EdgePatients:
		m.ResetPatients()
		return nil
	}
	return fmt.Errorf("unknown Clinic edge %s", name)
}

// ClinicMemberMutation represents an operation that mutates the ClinicMember nodes in the graph.
type ClinicMemberMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	role                     *clinicmember.Role
	is_active                *bool
	joined_at                *time.Time
	clearedFields            map[string]struct{}
	clinic                   *uuid.UUID
	clearedclinic            bool
	user                     *uuid.UUID
	cleareduser              bool
	therapist_profile        *uuid.UUID
	clearedtherapist_profile bool
	done                     bool
	oldValue                 func(context.Context) (*ClinicMember, error)
	predicates               []predicate.ClinicMember
}

var _ ent.Mutation = (*ClinicMemberMutation)(nil)

// clinicmemberOption allows management of the mutation configuration using functional options.
type clinicmemberOption func(*ClinicMemberMutation)

// newClinicMemberMutation creates new mutation for the ClinicMember entity.
func newClinicMemberMutation(c config, op Op, opts ...clinicmemberOption) *ClinicMemberMutation {
	m := &ClinicMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeClinicMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicMemberID sets the ID field of the mutation.
func withClinicMemberID(id uuid.UUID) clinicmemberOption {
	return func(m *ClinicMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ClinicMember
		)
		m.oldValue = func(ctx context.Context) (*ClinicMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClinicMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinicMember sets the old ClinicMember of the mutation.
func withClinicMember(node *ClinicMember) clinicmemberOption {
	return func(m *ClinicMemberMutation) {
		m.oldValue = func(context.Context) (*ClinicMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClinicMember entities.
func (m *ClinicMemberMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicMemberMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicMemberMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClinicMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClinicID sets the "clinic_id" field.
func (m *ClinicMemberMutation) SetClinicID(u uuid.UUID) {
	m.clinic = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *ClinicMemberMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the ClinicMember entity.
// If the ClinicMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMemberMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *ClinicMemberMutation) ResetClinicID() {
	m.clinic = nil
}

// SetUserID sets the "user_id" field.
func (m *ClinicMemberMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ClinicMemberMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ClinicMember entity.
// If the ClinicMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMemberMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ClinicMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *ClinicMemberMutation) SetRole(c clinicmember.Role) {
	m.role = &c
}

// Role returns the value of the "role" field in the mutation.
func (m *ClinicMemberMutation) Role() (r clinicmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ClinicMember entity.
// If the ClinicMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMemberMutation) OldRole(ctx context.Context) (v clinicmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ClinicMemberMutation) ResetRole() {
	m.role = nil
}

// SetIsActive sets the "is_active" field.
func (m *ClinicMemberMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ClinicMemberMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ClinicMember entity.
// If the ClinicMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMemberMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ClinicMemberMutation) ResetIsActive() {
	m.is_active = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *ClinicMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *ClinicMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the ClinicMember entity.
// If the ClinicMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *ClinicMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *ClinicMemberMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[clinicmember.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *ClinicMemberMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *ClinicMemberMutation) ClinicIDs() (ids []uuid.UUID) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *ClinicMemberMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ClinicMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[clinicmember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ClinicMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClinicMemberMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ClinicMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetTherapistProfileID sets the "therapist_profile" edge to the TherapistProfile entity by id.
func (m *ClinicMemberMutation) SetTherapistProfileID(id uuid.UUID) {
	m.therapist_profile = &id
}

// ClearTherapistProfile clears the "therapist_profile" edge to the TherapistProfile entity.
func (m *ClinicMemberMutation) ClearTherapistProfile() {
	m.clearedtherapist_profile = true
}

// TherapistProfileCleared reports if the "therapist_profile" edge to the TherapistProfile entity was cleared.
func (m *ClinicMemberMutation) TherapistProfileCleared() bool {
	return m.clearedtherapist_profile
}

// TherapistProfileID returns the "therapist_profile" edge ID in the mutation.
func (m *ClinicMemberMutation) TherapistProfileID() (id uuid.UUID, exists bool) {
	if m.therapist_profile != nil {
		return *m.therapist_profile, true
	}
	return
}

// TherapistProfileIDs returns the "therapist_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TherapistProfileID instead. It exists only for internal usage by the builders.
func (m *ClinicMemberMutation) TherapistProfileIDs() (ids []uuid.UUID) {
	if id := m.therapist_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTherapistProfile resets all changes to the "therapist_profile" edge.
func (m *ClinicMemberMutation) ResetTherapistProfile() {
	m.therapist_profile = nil
	m.clearedtherapist_profile = false
}

// Where appends a list predicates to the ClinicMemberMutation builder.
func (m *ClinicMemberMutation) Where(ps ...predicate.ClinicMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClinicMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClinicMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClinicMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClinicMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClinicMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClinicMember).
func (m *ClinicMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicMemberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.clinic != nil {
		fields = append(fields, clinicmember.FieldClinicID)
	}
	if m.user != nil {
		fields = append(fields, clinicmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, clinicmember.FieldRole)
	}
	if m.is_active != nil {
		fields = append(fields, clinicmember.FieldIsActive)
	}
	if m.joined_at != nil {
		fields = append(fields, clinicmember.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinicmember.FieldClinicID:
		return m.ClinicID()
	case clinicmember.FieldUserID:
		return m.UserID()
	case clinicmember.FieldRole:
		return m.Role()
	case clinicmember.FieldIsActive:
		return m.IsActive()
	case clinicmember.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinicmember.FieldClinicID:
		return m.OldClinicID(ctx)
	case clinicmember.FieldUserID:
		return m.OldUserID(ctx)
	case clinicmember.FieldRole:
		return m.OldRole(ctx)
	case clinicmember.FieldIsActive:
		return m.OldIsActive(ctx)
	case clinicmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ClinicMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinicmember.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case clinicmember.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case clinicmember.FieldRole:
		v, ok := value.(clinicmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case clinicmember.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case clinicmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ClinicMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClinicMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClinicMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicMemberMutation) ResetField(name string) error {
	switch name {
	case clinicmember.FieldClinicID:
		m.ResetClinicID()
		return nil
	case clinicmember.FieldUserID:
		m.ResetUserID()
		return nil
	case clinicmember.FieldRole:
		m.ResetRole()
		return nil
	case clinicmember.FieldIsActive:
		m.ResetIsActive()
		return nil
	case clinicmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown ClinicMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clinic != nil {
		edges = append(edges, clinicmember.EdgeClinic)
	}
	if m.user != nil {
		edges = append(edges, clinicmember.EdgeUser)
	}
	if m.therapist_profile != nil {
		edges = append(edges, clinicmember.EdgeTherapistProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinicmember.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case clinicmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case clinicmember.EdgeTherapistProfile:
		if id := m.therapist_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclinic {
		edges = append(edges, clinicmember.EdgeClinic)
	}
	if m.cleareduser {
		edges = append(edges, clinicmember.EdgeUser)
	}
	if m.clearedtherapist_profile {
		edges = append(edges, clinicmember.EdgeTherapistProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case clinicmember.EdgeClinic:
		return m.clearedclinic
	case clinicmember.EdgeUser:
		return m.cleareduser
	case clinicmember.EdgeTherapistProfile:
		return m.clearedtherapist_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicMemberMutation) ClearEdge(name string) error {
	switch name {
	case clinicmember.EdgeClinic:
		m.ClearClinic()
		return nil
	case clinicmember.EdgeUser:
		m.ClearUser()
		return nil
	case clinicmember.EdgeTherapistProfile:
		m.ClearTherapistProfile()
		return nil
	}
	return fmt.Errorf("unknown ClinicMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicMemberMutation) ResetEdge(name string) error {
	switch name {
	case clinicmember.EdgeClinic:
		m.ResetClinic()
		return nil
	case clinicmember.EdgeUser:
		m.ResetUser()
		return nil
	case clinicmember.EdgeTherapistProfile:
		m.ResetTherapistProfile()
		return nil
	}
	return fmt.Errorf("unknown ClinicMember edge %s", name)
}

// ClinicPermissionMutation represents an operation that mutates the ClinicPermission nodes in the graph.
type ClinicPermissionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	resource_type *string
	resource_id   *uuid.UUID
	action        *string
	granted       *bool
	clearedFields map[string]struct{}
	clinic        *uuid.UUID
	clearedclinic bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ClinicPermission, error)
	predicates    []predicate.ClinicPermission
}

var _ ent.Mutation = (*ClinicPermissionMutation)(nil)

// clinicpermissionOption allows management of the mutation configuration using functional options.
type clinicpermissionOption func(*ClinicPermissionMutation)

// newClinicPermissionMutation creates new mutation for the ClinicPermission entity.
func newClinicPermissionMutation(c config, op Op, opts ...clinicpermissionOption) *ClinicPermissionMutation {
	m := &ClinicPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeClinicPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicPermissionID sets the ID field of the mutation.
func withClinicPermissionID(id uuid.UUID) clinicpermissionOption {
	return func(m *ClinicPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *ClinicPermission
		)
		m.oldValue = func(ctx context.Context) (*ClinicPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClinicPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinicPermission sets the old ClinicPermission of the mutation.
func withClinicPermission(node *ClinicPermission) clinicpermissionOption {
	return func(m *ClinicPermissionMutation) {
		m.oldValue = func(context.Context) (*ClinicPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClinicPermission entities.
func (m *ClinicPermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicPermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicPermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClinicPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ClinicPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClinicPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClinicPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *ClinicPermissionMutation) SetClinicID(u uuid.UUID) {
	m.clinic = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *ClinicPermissionMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *ClinicPermissionMutation) ResetClinicID() {
	m.clinic = nil
}

// SetUserID sets the "user_id" field.
func (m *ClinicPermissionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ClinicPermissionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ClinicPermissionMutation) ResetUserID() {
	m.user = nil
}

// SetResourceType sets the "resource_type" field.
func (m *ClinicPermissionMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *ClinicPermissionMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *ClinicPermissionMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ClinicPermissionMutation) SetResourceID(u uuid.UUID) {
	m.resource_id = &u
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ClinicPermissionMutation) ResourceID() (r uuid.UUID, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldResourceID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *ClinicPermissionMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[clinicpermission.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *ClinicPermissionMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[clinicpermission.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ClinicPermissionMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, clinicpermission.FieldResourceID)
}

// SetAction sets the "action" field.
func (m *ClinicPermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ClinicPermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ClinicPermissionMutation) ResetAction() {
	m.action = nil
}

// SetGranted sets the "granted" field.
func (m *ClinicPermissionMutation) SetGranted(b bool) {
	m.granted = &b
}

// Granted returns the value of the "granted" field in the mutation.
func (m *ClinicPermissionMutation) Granted() (r bool, exists bool) {
	v := m.granted
	if v == nil {
		return
	}
	return *v, true
}

// OldGranted returns the old "granted" field's value of the ClinicPermission entity.
// If the ClinicPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicPermissionMutation) OldGranted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGranted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGranted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGranted: %w", err)
	}
	return oldValue.Granted, nil
}

// ResetGranted resets all changes to the "granted" field.
func (m *ClinicPermissionMutation) ResetGranted() {
	m.granted = nil
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *ClinicPermissionMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[clinicpermission.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *ClinicPermissionMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *ClinicPermissionMutation) ClinicIDs() (ids []uuid.UUID) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *ClinicPermissionMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ClinicPermissionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[clinicpermission.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ClinicPermissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClinicPermissionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ClinicPermissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ClinicPermissionMutation builder.
func (m *ClinicPermissionMutation) Where(ps ...predicate.ClinicPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClinicPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClinicPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClinicPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClinicPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClinicPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClinicPermission).
func (m *ClinicPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicPermissionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, clinicpermission.FieldCreatedAt)
	}
	if m.clinic != nil {
		fields = append(fields, clinicpermission.FieldClinicID)
	}
	if m.user != nil {
		fields = append(fields, clinicpermission.FieldUserID)
	}
	if m.resource_type != nil {
		fields = append(fields, clinicpermission.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, clinicpermission.FieldResourceID)
	}
	if m.action != nil {
		fields = append(fields, clinicpermission.FieldAction)
	}
	if m.granted != nil {
		fields = append(fields, clinicpermission.FieldGranted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinicpermission.FieldCreatedAt:
		return m.CreatedAt()
	case clinicpermission.FieldClinicID:
		return m.ClinicID()
	case clinicpermission.FieldUserID:
		return m.UserID()
	case clinicpermission.FieldResourceType:
		return m.ResourceType()
	case clinicpermission.FieldResourceID:
		return m.ResourceID()
	case clinicpermission.FieldAction:
		return m.Action()
	case clinicpermission.FieldGranted:
		return m.Granted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinicpermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clinicpermission.FieldClinicID:
		return m.OldClinicID(ctx)
	case clinicpermission.FieldUserID:
		return m.OldUserID(ctx)
	case clinicpermission.FieldResourceType:
		return m.OldResourceType(ctx)
	case clinicpermission.FieldResourceID:
		return m.OldResourceID(ctx)
	case clinicpermission.FieldAction:
		return m.OldAction(ctx)
	case clinicpermission.FieldGranted:
		return m.OldGranted(ctx)
	}
	return nil, fmt.Errorf("unknown ClinicPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinicpermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clinicpermission.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case clinicpermission.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case clinicpermission.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case clinicpermission.FieldResourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case clinicpermission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case clinicpermission.FieldGranted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGranted(v)
		return nil
	}
	return fmt.Errorf("unknown ClinicPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClinicPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clinicpermission.FieldResourceID) {
		fields = append(fields, clinicpermission.FieldResourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicPermissionMutation) ClearField(name string) error {
	switch name {
	case clinicpermission.FieldResourceID:
		m.ClearResourceID()
		return nil
	}
	return fmt.Errorf("unknown ClinicPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicPermissionMutation) ResetField(name string) error {
	switch name {
	case clinicpermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clinicpermission.FieldClinicID:
		m.ResetClinicID()
		return nil
	case clinicpermission.FieldUserID:
		m.ResetUserID()
		return nil
	case clinicpermission.FieldResourceType:
		m.ResetResourceType()
		return nil
	case clinicpermission.FieldResourceID:
		m.ResetResourceID()
		return nil
	case clinicpermission.FieldAction:
		m.ResetAction()
		return nil
	case clinicpermission.FieldGranted:
		m.ResetGranted()
		return nil
	}
	return fmt.Errorf("unknown ClinicPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clinic != nil {
		edges = append(edges, clinicpermission.EdgeClinic)
	}
	if m.user != nil {
		edges = append(edges, clinicpermission.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinicpermission.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case clinicpermission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclinic {
		edges = append(edges, clinicpermission.EdgeClinic)
	}
	if m.cleareduser {
		edges = append(edges, clinicpermission.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case clinicpermission.EdgeClinic:
		return m.clearedclinic
	case clinicpermission.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicPermissionMutation) ClearEdge(name string) error {
	switch name {
	case clinicpermission.EdgeClinic:
		m.ClearClinic()
		return nil
	case clinicpermission.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ClinicPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicPermissionMutation) ResetEdge(name string) error {
	switch name {
	case clinicpermission.EdgeClinic:
		m.ResetClinic()
		return nil
	case clinicpermission.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ClinicPermission edge %s", name)
}

// ClinicSettingsMutation represents an operation that mutates the ClinicSettings nodes in the graph.
type ClinicSettingsMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	reservation_fee_amount          *int64
	addreservation_fee_amount       *int64
	reservation_fee_percent         *int
	addreservation_fee_percent      *int
	cancellation_window_hours       *int
	addcancellation_window_hours    *int
	cancellation_fee_amount         *int64
	addcancellation_fee_amount      *int64
	cancellation_fee_percent        *int
	addcancellation_fee_percent     *int
	allow_client_self_book          *bool
	default_session_duration_min    *int
	adddefault_session_duration_min *int
	default_session_price           *int64
	adddefault_session_price        *int64
	working_hours                   *map[string]interface{}
	clearedFields                   map[string]struct{}
	clinic                          *uuid.UUID
	clearedclinic                   bool
	done                            bool
	oldValue                        func(context.Context) (*ClinicSettings, error)
	predicates                      []predicate.ClinicSettings
}

var _ ent.Mutation = (*ClinicSettingsMutation)(nil)

// clinicsettingsOption allows management of the mutation configuration using functional options.
type clinicsettingsOption func(*ClinicSettingsMutation)

// newClinicSettingsMutation creates new mutation for the ClinicSettings entity.
func newClinicSettingsMutation(c config, op Op, opts ...clinicsettingsOption) *ClinicSettingsMutation {
	m := &ClinicSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeClinicSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicSettingsID sets the ID field of the mutation.
func withClinicSettingsID(id uuid.UUID) clinicsettingsOption {
	return func(m *ClinicSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *ClinicSettings
		)
		m.oldValue = func(ctx context.Context) (*ClinicSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClinicSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinicSettings sets the old ClinicSettings of the mutation.
func withClinicSettings(node *ClinicSettings) clinicsettingsOption {
	return func(m *ClinicSettingsMutation) {
		m.oldValue = func(context.Context) (*ClinicSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClinicSettings entities.
func (m *ClinicSettingsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicSettingsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicSettingsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClinicSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ClinicSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClinicSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClinicSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClinicSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClinicSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClinicSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *ClinicSettingsMutation) SetClinicID(u uuid.UUID) {
	m.clinic = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *ClinicSettingsMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *ClinicSettingsMutation) ResetClinicID() {
	m.clinic = nil
}

// SetReservationFeeAmount sets the "reservation_fee_amount" field.
func (m *ClinicSettingsMutation) SetReservationFeeAmount(i int64) {
	m.reservation_fee_amount = &i
	m.addreservation_fee_amount = nil
}

// ReservationFeeAmount returns the value of the "reservation_fee_amount" field in the mutation.
func (m *ClinicSettingsMutation) ReservationFeeAmount() (r int64, exists bool) {
	v := m.reservation_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationFeeAmount returns the old "reservation_fee_amount" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldReservationFeeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationFeeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationFeeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationFeeAmount: %w", err)
	}
	return oldValue.ReservationFeeAmount, nil
}

// AddReservationFeeAmount adds i to the "reservation_fee_amount" field.
func (m *ClinicSettingsMutation) AddReservationFeeAmount(i int64) {
	if m.addreservation_fee_amount != nil {
		*m.addreservation_fee_amount += i
	} else {
		m.addreservation_fee_amount = &i
	}
}

// AddedReservationFeeAmount returns the value that was added to the "reservation_fee_amount" field in this mutation.
func (m *ClinicSettingsMutation) AddedReservationFeeAmount() (r int64, exists bool) {
	v := m.addreservation_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetReservationFeeAmount resets all changes to the "reservation_fee_amount" field.
func (m *ClinicSettingsMutation) ResetReservationFeeAmount() {
	m.reservation_fee_amount = nil
	m.addreservation_fee_amount = nil
}

// SetReservationFeePercent sets the "reservation_fee_percent" field.
func (m *ClinicSettingsMutation) SetReservationFeePercent(i int) {
	m.reservation_fee_percent = &i
	m.addreservation_fee_percent = nil
}

// ReservationFeePercent returns the value of the "reservation_fee_percent" field in the mutation.
func (m *ClinicSettingsMutation) ReservationFeePercent() (r int, exists bool) {
	v := m.reservation_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationFeePercent returns the old "reservation_fee_percent" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldReservationFeePercent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationFeePercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationFeePercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationFeePercent: %w", err)
	}
	return oldValue.ReservationFeePercent, nil
}

// AddReservationFeePercent adds i to the "reservation_fee_percent" field.
func (m *ClinicSettingsMutation) AddReservationFeePercent(i int) {
	if m.addreservation_fee_percent != nil {
		*m.addreservation_fee_percent += i
	} else {
		m.addreservation_fee_percent = &i
	}
}

// AddedReservationFeePercent returns the value that was added to the "reservation_fee_percent" field in this mutation.
func (m *ClinicSettingsMutation) AddedReservationFeePercent() (r int, exists bool) {
	v := m.addreservation_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetReservationFeePercent resets all changes to the "reservation_fee_percent" field.
func (m *ClinicSettingsMutation) ResetReservationFeePercent() {
	m.reservation_fee_percent = nil
	m.addreservation_fee_percent = nil
}

// SetCancellationWindowHours sets the "cancellation_window_hours" field.
func (m *ClinicSettingsMutation) SetCancellationWindowHours(i int) {
	m.cancellation_window_hours = &i
	m.addcancellation_window_hours = nil
}

// CancellationWindowHours returns the value of the "cancellation_window_hours" field in the mutation.
func (m *ClinicSettingsMutation) CancellationWindowHours() (r int, exists bool) {
	v := m.cancellation_window_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellationWindowHours returns the old "cancellation_window_hours" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldCancellationWindowHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellationWindowHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellationWindowHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellationWindowHours: %w", err)
	}
	return oldValue.CancellationWindowHours, nil
}

// AddCancellationWindowHours adds i to the "cancellation_window_hours" field.
func (m *ClinicSettingsMutation) AddCancellationWindowHours(i int) {
	if m.addcancellation_window_hours != nil {
		*m.addcancellation_window_hours += i
	} else {
		m.addcancellation_window_hours = &i
	}
}

// AddedCancellationWindowHours returns the value that was added to the "cancellation_window_hours" field in this mutation.
func (m *ClinicSettingsMutation) AddedCancellationWindowHours() (r int, exists bool) {
	v := m.addcancellation_window_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetCancellationWindowHours resets all changes to the "cancellation_window_hours" field.
func (m *ClinicSettingsMutation) ResetCancellationWindowHours() {
	m.cancellation_window_hours = nil
	m.addcancellation_window_hours = nil
}

// SetCancellationFeeAmount sets the "cancellation_fee_amount" field.
func (m *ClinicSettingsMutation) SetCancellationFeeAmount(i int64) {
	m.cancellation_fee_amount = &i
	m.addcancellation_fee_amount = nil
}

// CancellationFeeAmount returns the value of the "cancellation_fee_amount" field in the mutation.
func (m *ClinicSettingsMutation) CancellationFeeAmount() (r int64, exists bool) {
	v := m.cancellation_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellationFeeAmount returns the old "cancellation_fee_amount" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldCancellationFeeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellationFeeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellationFeeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellationFeeAmount: %w", err)
	}
	return oldValue.CancellationFeeAmount, nil
}

// AddCancellationFeeAmount adds i to the "cancellation_fee_amount" field.
func (m *ClinicSettingsMutation) AddCancellationFeeAmount(i int64) {
	if m.addcancellation_fee_amount != nil {
		*m.addcancellation_fee_amount += i
	} else {
		m.addcancellation_fee_amount = &i
	}
}

// AddedCancellationFeeAmount returns the value that was added to the "cancellation_fee_amount" field in this mutation.
func (m *ClinicSettingsMutation) AddedCancellationFeeAmount() (r int64, exists bool) {
	v := m.addcancellation_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCancellationFeeAmount resets all changes to the "cancellation_fee_amount" field.
func (m *ClinicSettingsMutation) ResetCancellationFeeAmount() {
	m.cancellation_fee_amount = nil
	m.addcancellation_fee_amount = nil
}

// SetCancellationFeePercent sets the "cancellation_fee_percent" field.
func (m *ClinicSettingsMutation) SetCancellationFeePercent(i int) {
	m.cancellation_fee_percent = &i
	m.addcancellation_fee_percent = nil
}

// CancellationFeePercent returns the value of the "cancellation_fee_percent" field in the mutation.
func (m *ClinicSettingsMutation) CancellationFeePercent() (r int, exists bool) {
	v := m.cancellation_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellationFeePercent returns the old "cancellation_fee_percent" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldCancellationFeePercent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellationFeePercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellationFeePercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellationFeePercent: %w", err)
	}
	return oldValue.CancellationFeePercent, nil
}

// AddCancellationFeePercent adds i to the "cancellation_fee_percent" field.
func (m *ClinicSettingsMutation) AddCancellationFeePercent(i int) {
	if m.addcancellation_fee_percent != nil {
		*m.addcancellation_fee_percent += i
	} else {
		m.addcancellation_fee_percent = &i
	}
}

// AddedCancellationFeePercent returns the value that was added to the "cancellation_fee_percent" field in this mutation.
func (m *ClinicSettingsMutation) AddedCancellationFeePercent() (r int, exists bool) {
	v := m.addcancellation_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCancellationFeePercent resets all changes to the "cancellation_fee_percent" field.
func (m *ClinicSettingsMutation) ResetCancellationFeePercent() {
	m.cancellation_fee_percent = nil
	m.addcancellation_fee_percent = nil
}

// SetAllowClientSelfBook sets the "allow_client_self_book" field.
func (m *ClinicSettingsMutation) SetAllowClientSelfBook(b bool) {
	m.allow_client_self_book = &b
}

// AllowClientSelfBook returns the value of the "allow_client_self_book" field in the mutation.
func (m *ClinicSettingsMutation) AllowClientSelfBook() (r bool, exists bool) {
	v := m.allow_client_self_book
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowClientSelfBook returns the old "allow_client_self_book" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldAllowClientSelfBook(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowClientSelfBook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowClientSelfBook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowClientSelfBook: %w", err)
	}
	return oldValue.AllowClientSelfBook, nil
}

// ResetAllowClientSelfBook resets all changes to the "allow_client_self_book" field.
func (m *ClinicSettingsMutation) ResetAllowClientSelfBook() {
	m.allow_client_self_book = nil
}

// SetDefaultSessionDurationMin sets the "default_session_duration_min" field.
func (m *ClinicSettingsMutation) SetDefaultSessionDurationMin(i int) {
	m.default_session_duration_min = &i
	m.adddefault_session_duration_min = nil
}

// DefaultSessionDurationMin returns the value of the "default_session_duration_min" field in the mutation.
func (m *ClinicSettingsMutation) DefaultSessionDurationMin() (r int, exists bool) {
	v := m.default_session_duration_min
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultSessionDurationMin returns the old "default_session_duration_min" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldDefaultSessionDurationMin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultSessionDurationMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultSessionDurationMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultSessionDurationMin: %w", err)
	}
	return oldValue.DefaultSessionDurationMin, nil
}

// AddDefaultSessionDurationMin adds i to the "default_session_duration_min" field.
func (m *ClinicSettingsMutation) AddDefaultSessionDurationMin(i int) {
	if m.adddefault_session_duration_min != nil {
		*m.adddefault_session_duration_min += i
	} else {
		m.adddefault_session_duration_min = &i
	}
}

// AddedDefaultSessionDurationMin returns the value that was added to the "default_session_duration_min" field in this mutation.
func (m *ClinicSettingsMutation) AddedDefaultSessionDurationMin() (r int, exists bool) {
	v := m.adddefault_session_duration_min
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultSessionDurationMin resets all changes to the "default_session_duration_min" field.
func (m *ClinicSettingsMutation) ResetDefaultSessionDurationMin() {
	m.default_session_duration_min = nil
	m.adddefault_session_duration_min = nil
}

// SetDefaultSessionPrice sets the "default_session_price" field.
func (m *ClinicSettingsMutation) SetDefaultSessionPrice(i int64) {
	m.default_session_price = &i
	m.adddefault_session_price = nil
}

// DefaultSessionPrice returns the value of the "default_session_price" field in the mutation.
func (m *ClinicSettingsMutation) DefaultSessionPrice() (r int64, exists bool) {
	v := m.default_session_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultSessionPrice returns the old "default_session_price" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldDefaultSessionPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultSessionPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultSessionPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultSessionPrice: %w", err)
	}
	return oldValue.DefaultSessionPrice, nil
}

// AddDefaultSessionPrice adds i to the "default_session_price" field.
func (m *ClinicSettingsMutation) AddDefaultSessionPrice(i int64) {
	if m.adddefault_session_price != nil {
		*m.adddefault_session_price += i
	} else {
		m.adddefault_session_price = &i
	}
}

// AddedDefaultSessionPrice returns the value that was added to the "default_session_price" field in this mutation.
func (m *ClinicSettingsMutation) AddedDefaultSessionPrice() (r int64, exists bool) {
	v := m.adddefault_session_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultSessionPrice resets all changes to the "default_session_price" field.
func (m *ClinicSettingsMutation) ResetDefaultSessionPrice() {
	m.default_session_price = nil
	m.adddefault_session_price = nil
}

// SetWorkingHours sets the "working_hours" field.
func (m *ClinicSettingsMutation) SetWorkingHours(value map[string]interface{}) {
	m.working_hours = &value
}

// WorkingHours returns the value of the "working_hours" field in the mutation.
func (m *ClinicSettingsMutation) WorkingHours() (r map[string]interface{}, exists bool) {
	v := m.working_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkingHours returns the old "working_hours" field's value of the ClinicSettings entity.
// If the ClinicSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicSettingsMutation) OldWorkingHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkingHours: %w", err)
	}
	return oldValue.WorkingHours, nil
}

// ClearWorkingHours clears the value of the "working_hours" field.
func (m *ClinicSettingsMutation) ClearWorkingHours() {
	m.working_hours = nil
	m.clearedFields[clinicsettings.FieldWorkingHours] = struct{}{}
}

// WorkingHoursCleared returns if the "working_hours" field was cleared in this mutation.
func (m *ClinicSettingsMutation) WorkingHoursCleared() bool {
	_, ok := m.clearedFields[clinicsettings.FieldWorkingHours]
	return ok
}

// ResetWorkingHours resets all changes to the "working_hours" field.
func (m *ClinicSettingsMutation) ResetWorkingHours() {
	m.working_hours = nil
	delete(m.clearedFields, clinicsettings.FieldWorkingHours)
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *ClinicSettingsMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[clinicsettings.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *ClinicSettingsMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *ClinicSettingsMutation) ClinicIDs() (ids []uuid.UUID) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *ClinicSettingsMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// Where appends a list predicates to the ClinicSettingsMutation builder.
func (m *ClinicSettingsMutation) Where(ps ...predicate.ClinicSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClinicSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClinicSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClinicSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClinicSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClinicSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClinicSettings).
func (m *ClinicSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicSettingsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, clinicsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clinicsettings.FieldUpdatedAt)
	}
	if m.clinic != nil {
		fields = append(fields, clinicsettings.FieldClinicID)
	}
	if m.reservation_fee_amount != nil {
		fields = append(fields, clinicsettings.FieldReservationFeeAmount)
	}
	if m.reservation_fee_percent != nil {
		fields = append(fields, clinicsettings.FieldReservationFeePercent)
	}
	if m.cancellation_window_hours != nil {
		fields = append(fields, clinicsettings.FieldCancellationWindowHours)
	}
	if m.cancellation_fee_amount != nil {
		fields = append(fields, clinicsettings.FieldCancellationFeeAmount)
	}
	if m.cancellation_fee_percent != nil {
		fields = append(fields, clinicsettings.FieldCancellationFeePercent)
	}
	if m.allow_client_self_book != nil {
		fields = append(fields, clinicsettings.FieldAllowClientSelfBook)
	}
	if m.default_session_duration_min != nil {
		fields = append(fields, clinicsettings.FieldDefaultSessionDurationMin)
	}
	if m.default_session_price != nil {
		fields = append(fields, clinicsettings.FieldDefaultSessionPrice)
	}
	if m.working_hours != nil {
		fields = append(fields, clinicsettings.FieldWorkingHours)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinicsettings.FieldCreatedAt:
		return m.CreatedAt()
	case clinicsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	case clinicsettings.FieldClinicID:
		return m.ClinicID()
	case clinicsettings.FieldReservationFeeAmount:
		return m.ReservationFeeAmount()
	case clinicsettings.FieldReservationFeePercent:
		return m.ReservationFeePercent()
	case clinicsettings.FieldCancellationWindowHours:
		return m.CancellationWindowHours()
	case clinicsettings.FieldCancellationFeeAmount:
		return m.CancellationFeeAmount()
	case clinicsettings.FieldCancellationFeePercent:
		return m.CancellationFeePercent()
	case clinicsettings.FieldAllowClientSelfBook:
		return m.AllowClientSelfBook()
	case clinicsettings.FieldDefaultSessionDurationMin:
		return m.DefaultSessionDurationMin()
	case clinicsettings.FieldDefaultSessionPrice:
		return m.DefaultSessionPrice()
	case clinicsettings.FieldWorkingHours:
		return m.WorkingHours()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinicsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clinicsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case clinicsettings.FieldClinicID:
		return m.OldClinicID(ctx)
	case clinicsettings.FieldReservationFeeAmount:
		return m.OldReservationFeeAmount(ctx)
	case clinicsettings.FieldReservationFeePercent:
		return m.OldReservationFeePercent(ctx)
	case clinicsettings.FieldCancellationWindowHours:
		return m.OldCancellationWindowHours(ctx)
	case clinicsettings.FieldCancellationFeeAmount:
		return m.OldCancellationFeeAmount(ctx)
	case clinicsettings.FieldCancellationFeePercent:
		return m.OldCancellationFeePercent(ctx)
	case clinicsettings.FieldAllowClientSelfBook:
		return m.OldAllowClientSelfBook(ctx)
	case clinicsettings.FieldDefaultSessionDurationMin:
		return m.OldDefaultSessionDurationMin(ctx)
	case clinicsettings.FieldDefaultSessionPrice:
		return m.OldDefaultSessionPrice(ctx)
	case clinicsettings.FieldWorkingHours:
		return m.OldWorkingHours(ctx)
	}
	return nil, fmt.Errorf("unknown ClinicSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinicsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clinicsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case clinicsettings.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case clinicsettings.FieldReservationFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationFeeAmount(v)
		return nil
	case clinicsettings.FieldReservationFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationFeePercent(v)
		return nil
	case clinicsettings.FieldCancellationWindowHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellationWindowHours(v)
		return nil
	case clinicsettings.FieldCancellationFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellationFeeAmount(v)
		return nil
	case clinicsettings.FieldCancellationFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellationFeePercent(v)
		return nil
	case clinicsettings.FieldAllowClientSelfBook:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowClientSelfBook(v)
		return nil
	case clinicsettings.FieldDefaultSessionDurationMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultSessionDurationMin(v)
		return nil
	case clinicsettings.FieldDefaultSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultSessionPrice(v)
		return nil
	case clinicsettings.FieldWorkingHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkingHours(v)
		return nil
	}
	return fmt.Errorf("unknown ClinicSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicSettingsMutation) AddedFields() []string {
	var fields []string
	if m.addreservation_fee_amount != nil {
		fields = append(fields, clinicsettings.FieldReservationFeeAmount)
	}
	if m.addreservation_fee_percent != nil {
		fields = append(fields, clinicsettings.FieldReservationFeePercent)
	}
	if m.addcancellation_window_hours != nil {
		fields = append(fields, clinicsettings.FieldCancellationWindowHours)
	}
	if m.addcancellation_fee_amount != nil {
		fields = append(fields, clinicsettings.FieldCancellationFeeAmount)
	}
	if m.addcancellation_fee_percent != nil {
		fields = append(fields, clinicsettings.FieldCancellationFeePercent)
	}
	if m.adddefault_session_duration_min != nil {
		fields = append(fields, clinicsettings.FieldDefaultSessionDurationMin)
	}
	if m.adddefault_session_price != nil {
		fields = append(fields, clinicsettings.FieldDefaultSessionPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicSettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case clinicsettings.FieldReservationFeeAmount:
		return m.AddedReservationFeeAmount()
	case clinicsettings.FieldReservationFeePercent:
		return m.AddedReservationFeePercent()
	case clinicsettings.FieldCancellationWindowHours:
		return m.AddedCancellationWindowHours()
	case clinicsettings.FieldCancellationFeeAmount:
		return m.AddedCancellationFeeAmount()
	case clinicsettings.FieldCancellationFeePercent:
		return m.AddedCancellationFeePercent()
	case clinicsettings.FieldDefaultSessionDurationMin:
		return m.AddedDefaultSessionDurationMin()
	case clinicsettings.FieldDefaultSessionPrice:
		return m.AddedDefaultSessionPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case clinicsettings.FieldReservationFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationFeeAmount(v)
		return nil
	case clinicsettings.FieldReservationFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationFeePercent(v)
		return nil
	case clinicsettings.FieldCancellationWindowHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellationWindowHours(v)
		return nil
	case clinicsettings.FieldCancellationFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellationFeeAmount(v)
		return nil
	case clinicsettings.FieldCancellationFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellationFeePercent(v)
		return nil
	case clinicsettings.FieldDefaultSessionDurationMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultSessionDurationMin(v)
		return nil
	case clinicsettings.FieldDefaultSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultSessionPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ClinicSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clinicsettings.FieldWorkingHours) {
		fields = append(fields, clinicsettings.FieldWorkingHours)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicSettingsMutation) ClearField(name string) error {
	switch name {
	case clinicsettings.FieldWorkingHours:
		m.ClearWorkingHours()
		return nil
	}
	return fmt.Errorf("unknown ClinicSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicSettingsMutation) ResetField(name string) error {
	switch name {
	case clinicsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clinicsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case clinicsettings.FieldClinicID:
		m.ResetClinicID()
		return nil
	case clinicsettings.FieldReservationFeeAmount:
		m.ResetReservationFeeAmount()
		return nil
	case clinicsettings.FieldReservationFeePercent:
		m.ResetReservationFeePercent()
		return nil
	case clinicsettings.FieldCancellationWindowHours:
		m.ResetCancellationWindowHours()
		return nil
	case clinicsettings.FieldCancellationFeeAmount:
		m.ResetCancellationFeeAmount()
		return nil
	case clinicsettings.FieldCancellationFeePercent:
		m.ResetCancellationFeePercent()
		return nil
	case clinicsettings.FieldAllowClientSelfBook:
		m.ResetAllowClientSelfBook()
		return nil
	case clinicsettings.FieldDefaultSessionDurationMin:
		m.ResetDefaultSessionDurationMin()
		return nil
	case clinicsettings.FieldDefaultSessionPrice:
		m.ResetDefaultSessionPrice()
		return nil
	case clinicsettings.FieldWorkingHours:
		m.ResetWorkingHours()
		return nil
	}
	return fmt.Errorf("unknown ClinicSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clinic != nil {
		edges = append(edges, clinicsettings.EdgeClinic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinicsettings.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclinic {
		edges = append(edges, clinicsettings.EdgeClinic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case clinicsettings.EdgeClinic:
		return m.clearedclinic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicSettingsMutation) ClearEdge(name string) error {
	switch name {
	case clinicsettings.EdgeClinic:
		m.ClearClinic()
		return nil
	}
	return fmt.Errorf("unknown ClinicSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicSettingsMutation) ResetEdge(name string) error {
	switch name {
	case clinicsettings.EdgeClinic:
		m.ResetClinic()
		return nil
	}
	return fmt.Errorf("unknown ClinicSettings edge %s", name)
}

// CommissionRuleMutation represents an operation that mutates the CommissionRule nodes in the graph.
type CommissionRuleMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	clinic_id               *uuid.UUID
	platform_fee_percent    *int
	addplatform_fee_percent *int
	clinic_fee_percent      *int
	addclinic_fee_percent   *int
	is_flat_fee             *bool
	flat_fee_amount         *int64
	addflat_fee_amount      *int64
	is_active               *bool
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*CommissionRule, error)
	predicates              []predicate.CommissionRule
}

var _ ent.Mutation = (*CommissionRuleMutation)(nil)

// commissionruleOption allows management of the mutation configuration using functional options.
type commissionruleOption func(*CommissionRuleMutation)

// newCommissionRuleMutation creates new mutation for the CommissionRule entity.
func newCommissionRuleMutation(c config, op Op, opts ...commissionruleOption) *CommissionRuleMutation {
	m := &CommissionRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeCommissionRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommissionRuleID sets the ID field of the mutation.
func withCommissionRuleID(id uuid.UUID) commissionruleOption {
	return func(m *CommissionRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *CommissionRule
		)
		m.oldValue = func(ctx context.Context) (*CommissionRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommissionRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommissionRule sets the old CommissionRule of the mutation.
func withCommissionRule(node *CommissionRule) commissionruleOption {
	return func(m *CommissionRuleMutation) {
		m.oldValue = func(context.Context) (*CommissionRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommissionRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommissionRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommissionRule entities.
func (m *CommissionRuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommissionRuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommissionRuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommissionRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommissionRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommissionRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommissionRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommissionRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommissionRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommissionRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *CommissionRuleMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *CommissionRuleMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *CommissionRuleMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetPlatformFeePercent sets the "platform_fee_percent" field.
func (m *CommissionRuleMutation) SetPlatformFeePercent(i int) {
	m.platform_fee_percent = &i
	m.addplatform_fee_percent = nil
}

// PlatformFeePercent returns the value of the "platform_fee_percent" field in the mutation.
func (m *CommissionRuleMutation) PlatformFeePercent() (r int, exists bool) {
	v := m.platform_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformFeePercent returns the old "platform_fee_percent" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldPlatformFeePercent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformFeePercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformFeePercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformFeePercent: %w", err)
	}
	return oldValue.PlatformFeePercent, nil
}

// AddPlatformFeePercent adds i to the "platform_fee_percent" field.
func (m *CommissionRuleMutation) AddPlatformFeePercent(i int) {
	if m.addplatform_fee_percent != nil {
		*m.addplatform_fee_percent += i
	} else {
		m.addplatform_fee_percent = &i
	}
}

// AddedPlatformFeePercent returns the value that was added to the "platform_fee_percent" field in this mutation.
func (m *CommissionRuleMutation) AddedPlatformFeePercent() (r int, exists bool) {
	v := m.addplatform_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformFeePercent resets all changes to the "platform_fee_percent" field.
func (m *CommissionRuleMutation) ResetPlatformFeePercent() {
	m.platform_fee_percent = nil
	m.addplatform_fee_percent = nil
}

// SetClinicFeePercent sets the "clinic_fee_percent" field.
func (m *CommissionRuleMutation) SetClinicFeePercent(i int) {
	m.clinic_fee_percent = &i
	m.addclinic_fee_percent = nil
}

// ClinicFeePercent returns the value of the "clinic_fee_percent" field in the mutation.
func (m *CommissionRuleMutation) ClinicFeePercent() (r int, exists bool) {
	v := m.clinic_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicFeePercent returns the old "clinic_fee_percent" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldClinicFeePercent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicFeePercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicFeePercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicFeePercent: %w", err)
	}
	return oldValue.ClinicFeePercent, nil
}

// AddClinicFeePercent adds i to the "clinic_fee_percent" field.
func (m *CommissionRuleMutation) AddClinicFeePercent(i int) {
	if m.addclinic_fee_percent != nil {
		*m.addclinic_fee_percent += i
	} else {
		m.addclinic_fee_percent = &i
	}
}

// AddedClinicFeePercent returns the value that was added to the "clinic_fee_percent" field in this mutation.
func (m *CommissionRuleMutation) AddedClinicFeePercent() (r int, exists bool) {
	v := m.addclinic_fee_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetClinicFeePercent resets all changes to the "clinic_fee_percent" field.
func (m *CommissionRuleMutation) ResetClinicFeePercent() {
	m.clinic_fee_percent = nil
	m.addclinic_fee_percent = nil
}

// SetIsFlatFee sets the "is_flat_fee" field.
func (m *CommissionRuleMutation) SetIsFlatFee(b bool) {
	m.is_flat_fee = &b
}

// IsFlatFee returns the value of the "is_flat_fee" field in the mutation.
func (m *CommissionRuleMutation) IsFlatFee() (r bool, exists bool) {
	v := m.is_flat_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlatFee returns the old "is_flat_fee" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldIsFlatFee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlatFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlatFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlatFee: %w", err)
	}
	return oldValue.IsFlatFee, nil
}

// ResetIsFlatFee resets all changes to the "is_flat_fee" field.
func (m *CommissionRuleMutation) ResetIsFlatFee() {
	m.is_flat_fee = nil
}

// SetFlatFeeAmount sets the "flat_fee_amount" field.
func (m *CommissionRuleMutation) SetFlatFeeAmount(i int64) {
	m.flat_fee_amount = &i
	m.addflat_fee_amount = nil
}

// FlatFeeAmount returns the value of the "flat_fee_amount" field in the mutation.
func (m *CommissionRuleMutation) FlatFeeAmount() (r int64, exists bool) {
	v := m.flat_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFlatFeeAmount returns the old "flat_fee_amount" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldFlatFeeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlatFeeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlatFeeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlatFeeAmount: %w", err)
	}
	return oldValue.FlatFeeAmount, nil
}

// AddFlatFeeAmount adds i to the "flat_fee_amount" field.
func (m *CommissionRuleMutation) AddFlatFeeAmount(i int64) {
	if m.addflat_fee_amount != nil {
		*m.addflat_fee_amount += i
	} else {
		m.addflat_fee_amount = &i
	}
}

// AddedFlatFeeAmount returns the value that was added to the "flat_fee_amount" field in this mutation.
func (m *CommissionRuleMutation) AddedFlatFeeAmount() (r int64, exists bool) {
	v := m.addflat_fee_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetFlatFeeAmount resets all changes to the "flat_fee_amount" field.
func (m *CommissionRuleMutation) ResetFlatFeeAmount() {
	m.flat_fee_amount = nil
	m.addflat_fee_amount = nil
}

// SetIsActive sets the "is_active" field.
func (m *CommissionRuleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CommissionRuleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CommissionRule entity.
// If the CommissionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionRuleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CommissionRuleMutation) ResetIsActive() {
	m.is_active = nil
}

// Where appends a list predicates to the CommissionRuleMutation builder.
func (m *CommissionRuleMutation) Where(ps ...predicate.CommissionRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommissionRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommissionRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommissionRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommissionRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommissionRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommissionRule).
func (m *CommissionRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommissionRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, commissionrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commissionrule.FieldUpdatedAt)
	}
	if m.clinic_id != nil {
		fields = append(fields, commissionrule.FieldClinicID)
	}
	if m.platform_fee_percent != nil {
		fields = append(fields, commissionrule.FieldPlatformFeePercent)
	}
	if m.clinic_fee_percent != nil {
		fields = append(fields, commissionrule.FieldClinicFeePercent)
	}
	if m.is_flat_fee != nil {
		fields = append(fields, commissionrule.FieldIsFlatFee)
	}
	if m.flat_fee_amount != nil {
		fields = append(fields, commissionrule.FieldFlatFeeAmount)
	}
	if m.is_active != nil {
		fields = append(fields, commissionrule.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommissionRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commissionrule.FieldCreatedAt:
		return m.CreatedAt()
	case commissionrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case commissionrule.FieldClinicID:
		return m.ClinicID()
	case commissionrule.FieldPlatformFeePercent:
		return m.PlatformFeePercent()
	case commissionrule.FieldClinicFeePercent:
		return m.ClinicFeePercent()
	case commissionrule.FieldIsFlatFee:
		return m.IsFlatFee()
	case commissionrule.FieldFlatFeeAmount:
		return m.FlatFeeAmount()
	case commissionrule.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommissionRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commissionrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commissionrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commissionrule.FieldClinicID:
		return m.OldClinicID(ctx)
	case commissionrule.FieldPlatformFeePercent:
		return m.OldPlatformFeePercent(ctx)
	case commissionrule.FieldClinicFeePercent:
		return m.OldClinicFeePercent(ctx)
	case commissionrule.FieldIsFlatFee:
		return m.OldIsFlatFee(ctx)
	case commissionrule.FieldFlatFeeAmount:
		return m.OldFlatFeeAmount(ctx)
	case commissionrule.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown CommissionRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commissionrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commissionrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commissionrule.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case commissionrule.FieldPlatformFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformFeePercent(v)
		return nil
	case commissionrule.FieldClinicFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicFeePercent(v)
		return nil
	case commissionrule.FieldIsFlatFee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlatFee(v)
		return nil
	case commissionrule.FieldFlatFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlatFeeAmount(v)
		return nil
	case commissionrule.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown CommissionRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommissionRuleMutation) AddedFields() []string {
	var fields []string
	if m.addplatform_fee_percent != nil {
		fields = append(fields, commissionrule.FieldPlatformFeePercent)
	}
	if m.addclinic_fee_percent != nil {
		fields = append(fields, commissionrule.FieldClinicFeePercent)
	}
	if m.addflat_fee_amount != nil {
		fields = append(fields, commissionrule.FieldFlatFeeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommissionRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commissionrule.FieldPlatformFeePercent:
		return m.AddedPlatformFeePercent()
	case commissionrule.FieldClinicFeePercent:
		return m.AddedClinicFeePercent()
	case commissionrule.FieldFlatFeeAmount:
		return m.AddedFlatFeeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commissionrule.FieldPlatformFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformFeePercent(v)
		return nil
	case commissionrule.FieldClinicFeePercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClinicFeePercent(v)
		return nil
	case commissionrule.FieldFlatFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlatFeeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CommissionRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommissionRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommissionRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommissionRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommissionRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommissionRuleMutation) ResetField(name string) error {
	switch name {
	case commissionrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commissionrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commissionrule.FieldClinicID:
		m.ResetClinicID()
		return nil
	case commissionrule.FieldPlatformFeePercent:
		m.ResetPlatformFeePercent()
		return nil
	case commissionrule.FieldClinicFeePercent:
		m.ResetClinicFeePercent()
		return nil
	case commissionrule.FieldIsFlatFee:
		m.ResetIsFlatFee()
		return nil
	case commissionrule.FieldFlatFeeAmount:
		m.ResetFlatFeeAmount()
		return nil
	case commissionrule.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown CommissionRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommissionRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommissionRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommissionRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommissionRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommissionRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommissionRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommissionRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommissionRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommissionRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommissionRule edge %s", name)
}

// ContactMessageMutation represents an operation that mutates the ContactMessage nodes in the graph.
type ContactMessageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	name          *string
	email         *string
	subject       *string
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ContactMessage, error)
	predicates    []predicate.ContactMessage
}

var _ ent.Mutation = (*ContactMessageMutation)(nil)

// contactmessageOption allows management of the mutation configuration using functional options.
type contactmessageOption func(*ContactMessageMutation)

// newContactMessageMutation creates new mutation for the ContactMessage entity.
func newContactMessageMutation(c config, op Op, opts ...contactmessageOption) *ContactMessageMutation {
	m := &ContactMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeContactMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactMessageID sets the ID field of the mutation.
func withContactMessageID(id uuid.UUID) contactmessageOption {
	return func(m *ContactMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *ContactMessage
		)
		m.oldValue = func(ctx context.Context) (*ContactMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContactMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContactMessage sets the old ContactMessage of the mutation.
func withContactMessage(node *ContactMessage) contactmessageOption {
	return func(m *ContactMessageMutation) {
		m.oldValue = func(context.Context) (*ContactMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContactMessage entities.
func (m *ContactMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContactMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContactMessage entity.
// If the ContactMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetName sets the "name" field.
func (m *ContactMessageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactMessageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ContactMessage entity.
// If the ContactMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMessageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContactMessageMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *ContactMessageMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactMessageMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ContactMessage entity.
// If the ContactMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMessageMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactMessageMutation) ResetEmail() {
	m.email = nil
}

// SetSubject sets the "subject" field.
func (m *ContactMessageMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *ContactMessageMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the ContactMessage entity.
// If the ContactMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMessageMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *ContactMessageMutation) ResetSubject() {
	m.subject = nil
}

// SetMessage sets the "message" field.
func (m *ContactMessageMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ContactMessageMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ContactMessage entity.
// If the ContactMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ContactMessageMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the ContactMessageMutation builder.
func (m *ContactMessageMutation) Where(ps ...predicate.ContactMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContactMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContactMessage).
func (m *ContactMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, contactmessage.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, contactmessage.FieldName)
	}
	if m.email != nil {
		fields = append(fields, contactmessage.FieldEmail)
	}
	if m.subject != nil {
		fields = append(fields, contactmessage.FieldSubject)
	}
	if m.message != nil {
		fields = append(fields, contactmessage.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contactmessage.FieldCreatedAt:
		return m.CreatedAt()
	case contactmessage.FieldName:
		return m.Name()
	case contactmessage.FieldEmail:
		return m.Email()
	case contactmessage.FieldSubject:
		return m.Subject()
	case contactmessage.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contactmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contactmessage.FieldName:
		return m.OldName(ctx)
	case contactmessage.FieldEmail:
		return m.OldEmail(ctx)
	case contactmessage.FieldSubject:
		return m.OldSubject(ctx)
	case contactmessage.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown ContactMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contactmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contactmessage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contactmessage.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contactmessage.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case contactmessage.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown ContactMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContactMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ContactMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMessageMutation) ResetField(name string) error {
	switch name {
	case contactmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contactmessage.FieldName:
		m.ResetName()
		return nil
	case contactmessage.FieldEmail:
		m.ResetEmail()
		return nil
	case contactmessage.FieldSubject:
		m.ResetSubject()
		return nil
	case contactmessage.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown ContactMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ContactMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ContactMessage edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	clinic_id       *uuid.UUID
	participant_a   *uuid.UUID
	participant_b   *uuid.UUID
	patient_id      *uuid.UUID
	last_message_at *time.Time
	is_active       *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Conversation, error)
	predicates      []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id uuid.UUID) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conversation entities.
func (m *ConversationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *ConversationMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *ConversationMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *ConversationMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetParticipantA sets the "participant_a" field.
func (m *ConversationMutation) SetParticipantA(u uuid.UUID) {
	m.participant_a = &u
}

// ParticipantA returns the value of the "participant_a" field in the mutation.
func (m *ConversationMutation) ParticipantA() (r uuid.UUID, exists bool) {
	v := m.participant_a
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantA returns the old "participant_a" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldParticipantA(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipantA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipantA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantA: %w", err)
	}
	return oldValue.ParticipantA, nil
}

// ResetParticipantA resets all changes to the "participant_a" field.
func (m *ConversationMutation) ResetParticipantA() {
	m.participant_a = nil
}

// SetParticipantB sets the "participant_b" field.
func (m *ConversationMutation) SetParticipantB(u uuid.UUID) {
	m.participant_b = &u
}

// ParticipantB returns the value of the "participant_b" field in the mutation.
func (m *ConversationMutation) ParticipantB() (r uuid.UUID, exists bool) {
	v := m.participant_b
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantB returns the old "participant_b" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldParticipantB(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipantB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipantB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantB: %w", err)
	}
	return oldValue.ParticipantB, nil
}

// ResetParticipantB resets all changes to the "participant_b" field.
func (m *ConversationMutation) ResetParticipantB() {
	m.participant_b = nil
}

// SetPatientID sets the "patient_id" field.
func (m *ConversationMutation) SetPatientID(u uuid.UUID) {
	m.patient_id = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *ConversationMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldPatientID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ClearPatientID clears the value of the "patient_id" field.
func (m *ConversationMutation) ClearPatientID() {
	m.patient_id = nil
	m.clearedFields[conversation.FieldPatientID] = struct{}{}
}

// PatientIDCleared returns if the "patient_id" field was cleared in this mutation.
func (m *ConversationMutation) PatientIDCleared() bool {
	_, ok := m.clearedFields[conversation.FieldPatientID]
	return ok
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *ConversationMutation) ResetPatientID() {
	m.patient_id = nil
	delete(m.clearedFields, conversation.FieldPatientID)
}

// SetLastMessageAt sets the "last_message_at" field.
func (m *ConversationMutation) SetLastMessageAt(t time.Time) {
	m.last_message_at = &t
}

// LastMessageAt returns the value of the "last_message_at" field in the mutation.
func (m *ConversationMutation) LastMessageAt() (r time.Time, exists bool) {
	v := m.last_message_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMessageAt returns the old "last_message_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldLastMessageAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMessageAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMessageAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMessageAt: %w", err)
	}
	return oldValue.LastMessageAt, nil
}

// ClearLastMessageAt clears the value of the "last_message_at" field.
func (m *ConversationMutation) ClearLastMessageAt() {
	m.last_message_at = nil
	m.clearedFields[conversation.FieldLastMessageAt] = struct{}{}
}

// LastMessageAtCleared returns if the "last_message_at" field was cleared in this mutation.
func (m *ConversationMutation) LastMessageAtCleared() bool {
	_, ok := m.clearedFields[conversation.FieldLastMessageAt]
	return ok
}

// ResetLastMessageAt resets all changes to the "last_message_at" field.
func (m *ConversationMutation) ResetLastMessageAt() {
	m.last_message_at = nil
	delete(m.clearedFields, conversation.FieldLastMessageAt)
}

// SetIsActive sets the "is_active" field.
func (m *ConversationMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ConversationMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ConversationMutation) ResetIsActive() {
	m.is_active = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.clinic_id != nil {
		fields = append(fields, conversation.FieldClinicID)
	}
	if m.participant_a != nil {
		fields = append(fields, conversation.FieldParticipantA)
	}
	if m.participant_b != nil {
		fields = append(fields, conversation.FieldParticipantB)
	}
	if m.patient_id != nil {
		fields = append(fields, conversation.FieldPatientID)
	}
	if m.last_message_at != nil {
		fields = append(fields, conversation.FieldLastMessageAt)
	}
	if m.is_active != nil {
		fields = append(fields, conversation.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldClinicID:
		return m.ClinicID()
	case conversation.FieldParticipantA:
		return m.ParticipantA()
	case conversation.FieldParticipantB:
		return m.ParticipantB()
	case conversation.FieldPatientID:
		return m.PatientID()
	case conversation.FieldLastMessageAt:
		return m.LastMessageAt()
	case conversation.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldClinicID:
		return m.OldClinicID(ctx)
	case conversation.FieldParticipantA:
		return m.OldParticipantA(ctx)
	case conversation.FieldParticipantB:
		return m.OldParticipantB(ctx)
	case conversation.FieldPatientID:
		return m.OldPatientID(ctx)
	case conversation.FieldLastMessageAt:
		return m.OldLastMessageAt(ctx)
	case conversation.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case conversation.FieldParticipantA:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantA(v)
		return nil
	case conversation.FieldParticipantB:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantB(v)
		return nil
	case conversation.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case conversation.FieldLastMessageAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMessageAt(v)
		return nil
	case conversation.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldPatientID) {
		fields = append(fields, conversation.FieldPatientID)
	}
	if m.FieldCleared(conversation.FieldLastMessageAt) {
		fields = append(fields, conversation.FieldLastMessageAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldPatientID:
		m.ClearPatientID()
		return nil
	case conversation.FieldLastMessageAt:
		m.ClearLastMessageAt()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldClinicID:
		m.ResetClinicID()
		return nil
	case conversation.FieldParticipantA:
		m.ResetParticipantA()
		return nil
	case conversation.FieldParticipantB:
		m.ResetParticipantB()
		return nil
	case conversation.FieldPatientID:
		m.ResetPatientID()
		return nil
	case conversation.FieldLastMessageAt:
		m.ResetLastMessageAt()
		return nil
	case conversation.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// InternPatientAccessMutation represents an operation that mutates the InternPatientAccess nodes in the graph.
type InternPatientAccessMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	intern_id         *uuid.UUID
	patient_id        *uuid.UUID
	granted_by        *uuid.UUID
	can_view_files    *bool
	can_write_reports *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*InternPatientAccess, error)
	predicates        []predicate.InternPatientAccess
}

var _ ent.Mutation = (*InternPatientAccessMutation)(nil)

// internpatientaccessOption allows management of the mutation configuration using functional options.
type internpatientaccessOption func(*InternPatientAccessMutation)

// newInternPatientAccessMutation creates new mutation for the InternPatientAccess entity.
func newInternPatientAccessMutation(c config, op Op, opts ...internpatientaccessOption) *InternPatientAccessMutation {
	m := &InternPatientAccessMutation{
		config:        c,
		op:            op,
		typ:           TypeInternPatientAccess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternPatientAccessID sets the ID field of the mutation.
func withInternPatientAccessID(id uuid.UUID) internpatientaccessOption {
	return func(m *InternPatientAccessMutation) {
		var (
			err   error
			once  sync.Once
			value *InternPatientAccess
		)
		m.oldValue = func(ctx context.Context) (*InternPatientAccess, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternPatientAccess.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternPatientAccess sets the old InternPatientAccess of the mutation.
func withInternPatientAccess(node *InternPatientAccess) internpatientaccessOption {
	return func(m *InternPatientAccessMutation) {
		m.oldValue = func(context.Context) (*InternPatientAccess, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternPatientAccessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternPatientAccessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternPatientAccess entities.
func (m *InternPatientAccessMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternPatientAccessMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternPatientAccessMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternPatientAccess.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternPatientAccessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternPatientAccessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternPatientAccess entity.
// If the InternPatientAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternPatientAccessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternPatientAccessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetInternID sets the "intern_id" field.
func (m *InternPatientAccessMutation) SetInternID(u uuid.UUID) {
	m.intern_id = &u
}

// InternID returns the value of the "intern_id" field in the mutation.
func (m *InternPatientAccessMutation) InternID() (r uuid.UUID, exists bool) {
	v := m.intern_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternID returns the old "intern_id" field's value of the InternPatientAccess entity.
// If the InternPatientAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternPatientAccessMutation) OldInternID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternID: %w", err)
	}
	return oldValue.InternID, nil
}

// ResetInternID resets all changes to the "intern_id" field.
func (m *InternPatientAccessMutation) ResetInternID() {
	m.intern_id = nil
}

// SetPatientID sets the "patient_id" field.
func (m *InternPatientAccessMutation) SetPatientID(u uuid.UUID) {
	m.patient_id = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *InternPatientAccessMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the InternPatientAccess entity.
// If the InternPatientAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternPatientAccessMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *InternPatientAccessMutation) ResetPatientID() {
	m.patient_id = nil
}

// SetGrantedBy sets the "granted_by" field.
func (m *InternPatientAccessMutation) SetGrantedBy(u uuid.UUID) {
	m.granted_by = &u
}

// GrantedBy returns the value of the "granted_by" field in the mutation.
func (m *InternPatientAccessMutation) GrantedBy() (r uuid.UUID, exists bool) {
	v := m.granted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedBy returns the old "granted_by" field's value of the InternPatientAccess entity.
// If the InternPatientAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternPatientAccessMutation) OldGrantedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedBy: %w", err)
	}
	return oldValue.GrantedBy, nil
}

// ResetGrantedBy resets all changes to the "granted_by" field.
func (m *InternPatientAccessMutation) ResetGrantedBy() {
	m.granted_by = nil
}

// SetCanViewFiles sets the "can_view_files" field.
func (m *InternPatientAccessMutation) SetCanViewFiles(b bool) {
	m.can_view_files = &b
}

// CanViewFiles returns the value of the "can_view_files" field in the mutation.
func (m *InternPatientAccessMutation) CanViewFiles() (r bool, exists bool) {
	v := m.can_view_files
	if v == nil {
		return
	}
	return *v, true
}

// OldCanViewFiles returns the old "can_view_files" field's value of the InternPatientAccess entity.
// If the InternPatientAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternPatientAccessMutation) OldCanViewFiles(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanViewFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanViewFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanViewFiles: %w", err)
	}
	return oldValue.CanViewFiles, nil
}

// ResetCanViewFiles resets all changes to the "can_view_files" field.
func (m *InternPatientAccessMutation) ResetCanViewFiles() {
	m.can_view_files = nil
}

// SetCanWriteReports sets the "can_write_reports" field.
func (m *InternPatientAccessMutation) SetCanWriteReports(b bool) {
	m.can_write_reports = &b
}

// CanWriteReports returns the value of the "can_write_reports" field in the mutation.
func (m *InternPatientAccessMutation) CanWriteReports() (r bool, exists bool) {
	v := m.can_write_reports
	if v == nil {
		return
	}
	return *v, true
}

// OldCanWriteReports returns the old "can_write_reports" field's value of the InternPatientAccess entity.
// If the InternPatientAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternPatientAccessMutation) OldCanWriteReports(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanWriteReports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanWriteReports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanWriteReports: %w", err)
	}
	return oldValue.CanWriteReports, nil
}

// ResetCanWriteReports resets all changes to the "can_write_reports" field.
func (m *InternPatientAccessMutation) ResetCanWriteReports() {
	m.can_write_reports = nil
}

// Where appends a list predicates to the InternPatientAccessMutation builder.
func (m *InternPatientAccessMutation) Where(ps ...predicate.InternPatientAccess) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternPatientAccessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternPatientAccessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternPatientAccess, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternPatientAccessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternPatientAccessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternPatientAccess).
func (m *InternPatientAccessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternPatientAccessMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, internpatientaccess.FieldCreatedAt)
	}
	if m.intern_id != nil {
		fields = append(fields, internpatientaccess.FieldInternID)
	}
	if m.patient_id != nil {
		fields = append(fields, internpatientaccess.FieldPatientID)
	}
	if m.granted_by != nil {
		fields = append(fields, internpatientaccess.FieldGrantedBy)
	}
	if m.can_view_files != nil {
		fields = append(fields, internpatientaccess.FieldCanViewFiles)
	}
	if m.can_write_reports != nil {
		fields = append(fields, internpatientaccess.FieldCanWriteReports)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternPatientAccessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internpatientaccess.FieldCreatedAt:
		return m.CreatedAt()
	case internpatientaccess.FieldInternID:
		return m.InternID()
	case internpatientaccess.FieldPatientID:
		return m.PatientID()
	case internpatientaccess.FieldGrantedBy:
		return m.GrantedBy()
	case internpatientaccess.FieldCanViewFiles:
		return m.CanViewFiles()
	case internpatientaccess.FieldCanWriteReports:
		return m.CanWriteReports()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternPatientAccessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internpatientaccess.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internpatientaccess.FieldInternID:
		return m.OldInternID(ctx)
	case internpatientaccess.FieldPatientID:
		return m.OldPatientID(ctx)
	case internpatientaccess.FieldGrantedBy:
		return m.OldGrantedBy(ctx)
	case internpatientaccess.FieldCanViewFiles:
		return m.OldCanViewFiles(ctx)
	case internpatientaccess.FieldCanWriteReports:
		return m.OldCanWriteReports(ctx)
	}
	return nil, fmt.Errorf("unknown InternPatientAccess field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternPatientAccessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internpatientaccess.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internpatientaccess.FieldInternID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternID(v)
		return nil
	case internpatientaccess.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case internpatientaccess.FieldGrantedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedBy(v)
		return nil
	case internpatientaccess.FieldCanViewFiles:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanViewFiles(v)
		return nil
	case internpatientaccess.FieldCanWriteReports:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanWriteReports(v)
		return nil
	}
	return fmt.Errorf("unknown InternPatientAccess field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternPatientAccessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternPatientAccessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternPatientAccessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InternPatientAccess numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternPatientAccessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternPatientAccessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternPatientAccessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InternPatientAccess nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternPatientAccessMutation) ResetField(name string) error {
	switch name {
	case internpatientaccess.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internpatientaccess.FieldInternID:
		m.ResetInternID()
		return nil
	case internpatientaccess.FieldPatientID:
		m.ResetPatientID()
		return nil
	case internpatientaccess.FieldGrantedBy:
		m.ResetGrantedBy()
		return nil
	case internpatientaccess.FieldCanViewFiles:
		m.ResetCanViewFiles()
		return nil
	case internpatientaccess.FieldCanWriteReports:
		m.ResetCanWriteReports()
		return nil
	}
	return fmt.Errorf("unknown InternPatientAccess field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternPatientAccessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternPatientAccessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternPatientAccessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternPatientAccessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternPatientAccessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternPatientAccessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternPatientAccessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternPatientAccess unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternPatientAccessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternPatientAccess edge %s", name)
}

// InternProfileMutation represents an operation that mutates the InternProfile nodes in the graph.
type InternProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	clinic_member_id     *uuid.UUID
	internship_year      *int
	addinternship_year   *int
	supervisor_ids       *[]uuid.UUID
	appendsupervisor_ids []uuid.UUID
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*InternProfile, error)
	predicates           []predicate.InternProfile
}

var _ ent.Mutation = (*InternProfileMutation)(nil)

// internprofileOption allows management of the mutation configuration using functional options.
type internprofileOption func(*InternProfileMutation)

// newInternProfileMutation creates new mutation for the InternProfile entity.
func newInternProfileMutation(c config, op Op, opts ...internprofileOption) *InternProfileMutation {
	m := &InternProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeInternProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternProfileID sets the ID field of the mutation.
func withInternProfileID(id uuid.UUID) internprofileOption {
	return func(m *InternProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *InternProfile
		)
		m.oldValue = func(ctx context.Context) (*InternProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternProfile sets the old InternProfile of the mutation.
func withInternProfile(node *InternProfile) internprofileOption {
	return func(m *InternProfileMutation) {
		m.oldValue = func(context.Context) (*InternProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternProfile entities.
func (m *InternProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternProfile entity.
// If the InternProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternProfile entity.
// If the InternProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicMemberID sets the "clinic_member_id" field.
func (m *InternProfileMutation) SetClinicMemberID(u uuid.UUID) {
	m.clinic_member_id = &u
}

// ClinicMemberID returns the value of the "clinic_member_id" field in the mutation.
func (m *InternProfileMutation) ClinicMemberID() (r uuid.UUID, exists bool) {
	v := m.clinic_member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicMemberID returns the old "clinic_member_id" field's value of the InternProfile entity.
// If the InternProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternProfileMutation) OldClinicMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicMemberID: %w", err)
	}
	return oldValue.ClinicMemberID, nil
}

// ResetClinicMemberID resets all changes to the "clinic_member_id" field.
func (m *InternProfileMutation) ResetClinicMemberID() {
	m.clinic_member_id = nil
}

// SetInternshipYear sets the "internship_year" field.
func (m *InternProfileMutation) SetInternshipYear(i int) {
	m.internship_year = &i
	m.addinternship_year = nil
}

// InternshipYear returns the value of the "internship_year" field in the mutation.
func (m *InternProfileMutation) InternshipYear() (r int, exists bool) {
	v := m.internship_year
	if v == nil {
		return
	}
	return *v, true
}

// OldInternshipYear returns the old "internship_year" field's value of the InternProfile entity.
// If the InternProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternProfileMutation) OldInternshipYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternshipYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternshipYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternshipYear: %w", err)
	}
	return oldValue.InternshipYear, nil
}

// AddInternshipYear adds i to the "internship_year" field.
func (m *InternProfileMutation) AddInternshipYear(i int) {
	if m.addinternship_year != nil {
		*m.addinternship_year += i
	} else {
		m.addinternship_year = &i
	}
}

// AddedInternshipYear returns the value that was added to the "internship_year" field in this mutation.
func (m *InternProfileMutation) AddedInternshipYear() (r int, exists bool) {
	v := m.addinternship_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearInternshipYear clears the value of the "internship_year" field.
func (m *InternProfileMutation) ClearInternshipYear() {
	m.internship_year = nil
	m.addinternship_year = nil
	m.clearedFields[internprofile.FieldInternshipYear] = struct{}{}
}

// InternshipYearCleared returns if the "internship_year" field was cleared in this mutation.
func (m *InternProfileMutation) InternshipYearCleared() bool {
	_, ok := m.clearedFields[internprofile.FieldInternshipYear]
	return ok
}

// ResetInternshipYear resets all changes to the "internship_year" field.
func (m *InternProfileMutation) ResetInternshipYear() {
	m.internship_year = nil
	m.addinternship_year = nil
	delete(m.clearedFields, internprofile.FieldInternshipYear)
}

// SetSupervisorIds sets the "supervisor_ids" field.
func (m *InternProfileMutation) SetSupervisorIds(u []uuid.UUID) {
	m.supervisor_ids = &u
	m.appendsupervisor_ids = nil
}

// SupervisorIds returns the value of the "supervisor_ids" field in the mutation.
func (m *InternProfileMutation) SupervisorIds() (r []uuid.UUID, exists bool) {
	v := m.supervisor_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupervisorIds returns the old "supervisor_ids" field's value of the InternProfile entity.
// If the InternProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternProfileMutation) OldSupervisorIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupervisorIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupervisorIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupervisorIds: %w", err)
	}
	return oldValue.SupervisorIds, nil
}

// AppendSupervisorIds adds u to the "supervisor_ids" field.
func (m *InternProfileMutation) AppendSupervisorIds(u []uuid.UUID) {
	m.appendsupervisor_ids = append(m.appendsupervisor_ids, u...)
}

// AppendedSupervisorIds returns the list of values that were appended to the "supervisor_ids" field in this mutation.
func (m *InternProfileMutation) AppendedSupervisorIds() ([]uuid.UUID, bool) {
	if len(m.appendsupervisor_ids) == 0 {
		return nil, false
	}
	return m.appendsupervisor_ids, true
}

// ClearSupervisorIds clears the value of the "supervisor_ids" field.
func (m *InternProfileMutation) ClearSupervisorIds() {
	m.supervisor_ids = nil
	m.appendsupervisor_ids = nil
	m.clearedFields[internprofile.FieldSupervisorIds] = struct{}{}
}

// SupervisorIdsCleared returns if the "supervisor_ids" field was cleared in this mutation.
func (m *InternProfileMutation) SupervisorIdsCleared() bool {
	_, ok := m.clearedFields[internprofile.FieldSupervisorIds]
	return ok
}

// ResetSupervisorIds resets all changes to the "supervisor_ids" field.
func (m *InternProfileMutation) ResetSupervisorIds() {
	m.supervisor_ids = nil
	m.appendsupervisor_ids = nil
	delete(m.clearedFields, internprofile.FieldSupervisorIds)
}

// Where appends a list predicates to the InternProfileMutation builder.
func (m *InternProfileMutation) Where(ps ...predicate.InternProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternProfile).
func (m *InternProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternProfileMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, internprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internprofile.FieldUpdatedAt)
	}
	if m.clinic_member_id != nil {
		fields = append(fields, internprofile.FieldClinicMemberID)
	}
	if m.internship_year != nil {
		fields = append(fields, internprofile.FieldInternshipYear)
	}
	if m.supervisor_ids != nil {
		fields = append(fields, internprofile.FieldSupervisorIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internprofile.FieldCreatedAt:
		return m.CreatedAt()
	case internprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case internprofile.FieldClinicMemberID:
		return m.ClinicMemberID()
	case internprofile.FieldInternshipYear:
		return m.InternshipYear()
	case internprofile.FieldSupervisorIds:
		return m.SupervisorIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internprofile.FieldClinicMemberID:
		return m.OldClinicMemberID(ctx)
	case internprofile.FieldInternshipYear:
		return m.OldInternshipYear(ctx)
	case internprofile.FieldSupervisorIds:
		return m.OldSupervisorIds(ctx)
	}
	return nil, fmt.Errorf("unknown InternProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internprofile.FieldClinicMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicMemberID(v)
		return nil
	case internprofile.FieldInternshipYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternshipYear(v)
		return nil
	case internprofile.FieldSupervisorIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupervisorIds(v)
		return nil
	}
	return fmt.Errorf("unknown InternProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternProfileMutation) AddedFields() []string {
	var fields []string
	if m.addinternship_year != nil {
		fields = append(fields, internprofile.FieldInternshipYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case internprofile.FieldInternshipYear:
		return m.AddedInternshipYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case internprofile.FieldInternshipYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInternshipYear(v)
		return nil
	}
	return fmt.Errorf("unknown InternProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internprofile.FieldInternshipYear) {
		fields = append(fields, internprofile.FieldInternshipYear)
	}
	if m.FieldCleared(internprofile.FieldSupervisorIds) {
		fields = append(fields, internprofile.FieldSupervisorIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternProfileMutation) ClearField(name string) error {
	switch name {
	case internprofile.FieldInternshipYear:
		m.ClearInternshipYear()
		return nil
	case internprofile.FieldSupervisorIds:
		m.ClearSupervisorIds()
		return nil
	}
	return fmt.Errorf("unknown InternProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternProfileMutation) ResetField(name string) error {
	switch name {
	case internprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internprofile.FieldClinicMemberID:
		m.ResetClinicMemberID()
		return nil
	case internprofile.FieldInternshipYear:
		m.ResetInternshipYear()
		return nil
	case internprofile.FieldSupervisorIds:
		m.ResetSupervisorIds()
		return nil
	}
	return fmt.Errorf("unknown InternProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternProfileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternProfileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternProfileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternProfileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternProfile edge %s", name)
}

// InternTaskMutation represents an operation that mutates the InternTask nodes in the graph.
type InternTaskMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	clinic_id      *uuid.UUID
	intern_id      *uuid.UUID
	title          *string
	caption        *string
	submitted_at   *time.Time
	review_status  *interntask.ReviewStatus
	reviewed_by    *uuid.UUID
	review_comment *string
	grade          *string
	reviewed_at    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*InternTask, error)
	predicates     []predicate.InternTask
}

var _ ent.Mutation = (*InternTaskMutation)(nil)

// interntaskOption allows management of the mutation configuration using functional options.
type interntaskOption func(*InternTaskMutation)

// newInternTaskMutation creates new mutation for the InternTask entity.
func newInternTaskMutation(c config, op Op, opts ...interntaskOption) *InternTaskMutation {
	m := &InternTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeInternTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternTaskID sets the ID field of the mutation.
func withInternTaskID(id uuid.UUID) interntaskOption {
	return func(m *InternTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *InternTask
		)
		m.oldValue = func(ctx context.Context) (*InternTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternTask sets the old InternTask of the mutation.
func withInternTask(node *InternTask) interntaskOption {
	return func(m *InternTaskMutation) {
		m.oldValue = func(context.Context) (*InternTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternTask entities.
func (m *InternTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *InternTaskMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *InternTaskMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *InternTaskMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetInternID sets the "intern_id" field.
func (m *InternTaskMutation) SetInternID(u uuid.UUID) {
	m.intern_id = &u
}

// InternID returns the value of the "intern_id" field in the mutation.
func (m *InternTaskMutation) InternID() (r uuid.UUID, exists bool) {
	v := m.intern_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternID returns the old "intern_id" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldInternID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternID: %w", err)
	}
	return oldValue.InternID, nil
}

// ResetInternID resets all changes to the "intern_id" field.
func (m *InternTaskMutation) ResetInternID() {
	m.intern_id = nil
}

// SetTitle sets the "title" field.
func (m *InternTaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *InternTaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *InternTaskMutation) ResetTitle() {
	m.title = nil
}

// SetCaption sets the "caption" field.
func (m *InternTaskMutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *InternTaskMutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldCaption(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ClearCaption clears the value of the "caption" field.
func (m *InternTaskMutation) ClearCaption() {
	m.caption = nil
	m.clearedFields[interntask.FieldCaption] = struct{}{}
}

// CaptionCleared returns if the "caption" field was cleared in this mutation.
func (m *InternTaskMutation) CaptionCleared() bool {
	_, ok := m.clearedFields[interntask.FieldCaption]
	return ok
}

// ResetCaption resets all changes to the "caption" field.
func (m *InternTaskMutation) ResetCaption() {
	m.caption = nil
	delete(m.clearedFields, interntask.FieldCaption)
}

// SetSubmittedAt sets the "submitted_at" field.
func (m *InternTaskMutation) SetSubmittedAt(t time.Time) {
	m.submitted_at = &t
}

// SubmittedAt returns the value of the "submitted_at" field in the mutation.
func (m *InternTaskMutation) SubmittedAt() (r time.Time, exists bool) {
	v := m.submitted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedAt returns the old "submitted_at" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldSubmittedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedAt: %w", err)
	}
	return oldValue.SubmittedAt, nil
}

// ResetSubmittedAt resets all changes to the "submitted_at" field.
func (m *InternTaskMutation) ResetSubmittedAt() {
	m.submitted_at = nil
}

// SetReviewStatus sets the "review_status" field.
func (m *InternTaskMutation) SetReviewStatus(is interntask.ReviewStatus) {
	m.review_status = &is
}

// ReviewStatus returns the value of the "review_status" field in the mutation.
func (m *InternTaskMutation) ReviewStatus() (r interntask.ReviewStatus, exists bool) {
	v := m.review_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewStatus returns the old "review_status" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldReviewStatus(ctx context.Context) (v interntask.ReviewStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewStatus: %w", err)
	}
	return oldValue.ReviewStatus, nil
}

// ResetReviewStatus resets all changes to the "review_status" field.
func (m *InternTaskMutation) ResetReviewStatus() {
	m.review_status = nil
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *InternTaskMutation) SetReviewedBy(u uuid.UUID) {
	m.reviewed_by = &u
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *InternTaskMutation) ReviewedBy() (r uuid.UUID, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldReviewedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// ClearReviewedBy clears the value of the "reviewed_by" field.
func (m *InternTaskMutation) ClearReviewedBy() {
	m.reviewed_by = nil
	m.clearedFields[interntask.FieldReviewedBy] = struct{}{}
}

// ReviewedByCleared returns if the "reviewed_by" field was cleared in this mutation.
func (m *InternTaskMutation) ReviewedByCleared() bool {
	_, ok := m.clearedFields[interntask.FieldReviewedBy]
	return ok
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *InternTaskMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	delete(m.clearedFields, interntask.FieldReviewedBy)
}

// SetReviewComment sets the "review_comment" field.
func (m *InternTaskMutation) SetReviewComment(s string) {
	m.review_comment = &s
}

// ReviewComment returns the value of the "review_comment" field in the mutation.
func (m *InternTaskMutation) ReviewComment() (r string, exists bool) {
	v := m.review_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewComment returns the old "review_comment" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldReviewComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewComment: %w", err)
	}
	return oldValue.ReviewComment, nil
}

// ClearReviewComment clears the value of the "review_comment" field.
func (m *InternTaskMutation) ClearReviewComment() {
	m.review_comment = nil
	m.clearedFields[interntask.FieldReviewComment] = struct{}{}
}

// ReviewCommentCleared returns if the "review_comment" field was cleared in this mutation.
func (m *InternTaskMutation) ReviewCommentCleared() bool {
	_, ok := m.clearedFields[interntask.FieldReviewComment]
	return ok
}

// ResetReviewComment resets all changes to the "review_comment" field.
func (m *InternTaskMutation) ResetReviewComment() {
	m.review_comment = nil
	delete(m.clearedFields, interntask.FieldReviewComment)
}

// SetGrade sets the "grade" field.
func (m *InternTaskMutation) SetGrade(s string) {
	m.grade = &s
}

// Grade returns the value of the "grade" field in the mutation.
func (m *InternTaskMutation) Grade() (r string, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old "grade" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldGrade(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// ClearGrade clears the value of the "grade" field.
func (m *InternTaskMutation) ClearGrade() {
	m.grade = nil
	m.clearedFields[interntask.FieldGrade] = struct{}{}
}

// GradeCleared returns if the "grade" field was cleared in this mutation.
func (m *InternTaskMutation) GradeCleared() bool {
	_, ok := m.clearedFields[interntask.FieldGrade]
	return ok
}

// ResetGrade resets all changes to the "grade" field.
func (m *InternTaskMutation) ResetGrade() {
	m.grade = nil
	delete(m.clearedFields, interntask.FieldGrade)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *InternTaskMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *InternTaskMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the InternTask entity.
// If the InternTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskMutation) OldReviewedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *InternTaskMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[interntask.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *InternTaskMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[interntask.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *InternTaskMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, interntask.FieldReviewedAt)
}

// Where appends a list predicates to the InternTaskMutation builder.
func (m *InternTaskMutation) Where(ps ...predicate.InternTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternTask).
func (m *InternTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternTaskMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, interntask.FieldCreatedAt)
	}
	if m.clinic_id != nil {
		fields = append(fields, interntask.FieldClinicID)
	}
	if m.intern_id != nil {
		fields = append(fields, interntask.FieldInternID)
	}
	if m.title != nil {
		fields = append(fields, interntask.FieldTitle)
	}
	if m.caption != nil {
		fields = append(fields, interntask.FieldCaption)
	}
	if m.submitted_at != nil {
		fields = append(fields, interntask.FieldSubmittedAt)
	}
	if m.review_status != nil {
		fields = append(fields, interntask.FieldReviewStatus)
	}
	if m.reviewed_by != nil {
		fields = append(fields, interntask.FieldReviewedBy)
	}
	if m.review_comment != nil {
		fields = append(fields, interntask.FieldReviewComment)
	}
	if m.grade != nil {
		fields = append(fields, interntask.FieldGrade)
	}
	if m.reviewed_at != nil {
		fields = append(fields, interntask.FieldReviewedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interntask.FieldCreatedAt:
		return m.CreatedAt()
	case interntask.FieldClinicID:
		return m.ClinicID()
	case interntask.FieldInternID:
		return m.InternID()
	case interntask.FieldTitle:
		return m.Title()
	case interntask.FieldCaption:
		return m.Caption()
	case interntask.FieldSubmittedAt:
		return m.SubmittedAt()
	case interntask.FieldReviewStatus:
		return m.ReviewStatus()
	case interntask.FieldReviewedBy:
		return m.ReviewedBy()
	case interntask.FieldReviewComment:
		return m.ReviewComment()
	case interntask.FieldGrade:
		return m.Grade()
	case interntask.FieldReviewedAt:
		return m.ReviewedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interntask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interntask.FieldClinicID:
		return m.OldClinicID(ctx)
	case interntask.FieldInternID:
		return m.OldInternID(ctx)
	case interntask.FieldTitle:
		return m.OldTitle(ctx)
	case interntask.FieldCaption:
		return m.OldCaption(ctx)
	case interntask.FieldSubmittedAt:
		return m.OldSubmittedAt(ctx)
	case interntask.FieldReviewStatus:
		return m.OldReviewStatus(ctx)
	case interntask.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case interntask.FieldReviewComment:
		return m.OldReviewComment(ctx)
	case interntask.FieldGrade:
		return m.OldGrade(ctx)
	case interntask.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InternTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interntask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interntask.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case interntask.FieldInternID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternID(v)
		return nil
	case interntask.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case interntask.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case interntask.FieldSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedAt(v)
		return nil
	case interntask.FieldReviewStatus:
		v, ok := value.(interntask.ReviewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewStatus(v)
		return nil
	case interntask.FieldReviewedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case interntask.FieldReviewComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewComment(v)
		return nil
	case interntask.FieldGrade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	case interntask.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InternTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InternTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interntask.FieldCaption) {
		fields = append(fields, interntask.FieldCaption)
	}
	if m.FieldCleared(interntask.FieldReviewedBy) {
		fields = append(fields, interntask.FieldReviewedBy)
	}
	if m.FieldCleared(interntask.FieldReviewComment) {
		fields = append(fields, interntask.FieldReviewComment)
	}
	if m.FieldCleared(interntask.FieldGrade) {
		fields = append(fields, interntask.FieldGrade)
	}
	if m.FieldCleared(interntask.FieldReviewedAt) {
		fields = append(fields, interntask.FieldReviewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternTaskMutation) ClearField(name string) error {
	switch name {
	case interntask.FieldCaption:
		m.ClearCaption()
		return nil
	case interntask.FieldReviewedBy:
		m.ClearReviewedBy()
		return nil
	case interntask.FieldReviewComment:
		m.ClearReviewComment()
		return nil
	case interntask.FieldGrade:
		m.ClearGrade()
		return nil
	case interntask.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown InternTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternTaskMutation) ResetField(name string) error {
	switch name {
	case interntask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interntask.FieldClinicID:
		m.ResetClinicID()
		return nil
	case interntask.FieldInternID:
		m.ResetInternID()
		return nil
	case interntask.FieldTitle:
		m.ResetTitle()
		return nil
	case interntask.FieldCaption:
		m.ResetCaption()
		return nil
	case interntask.FieldSubmittedAt:
		m.ResetSubmittedAt()
		return nil
	case interntask.FieldReviewStatus:
		m.ResetReviewStatus()
		return nil
	case interntask.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case interntask.FieldReviewComment:
		m.ResetReviewComment()
		return nil
	case interntask.FieldGrade:
		m.ResetGrade()
		return nil
	case interntask.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown InternTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternTask edge %s", name)
}

// InternTaskFileMutation represents an operation that mutates the InternTaskFile nodes in the graph.
type InternTaskFileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	task_id       *uuid.UUID
	file_key      *string
	file_name     *string
	file_size     *int64
	addfile_size  *int64
	mime_type     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InternTaskFile, error)
	predicates    []predicate.InternTaskFile
}

var _ ent.Mutation = (*InternTaskFileMutation)(nil)

// interntaskfileOption allows management of the mutation configuration using functional options.
type interntaskfileOption func(*InternTaskFileMutation)

// newInternTaskFileMutation creates new mutation for the InternTaskFile entity.
func newInternTaskFileMutation(c config, op Op, opts ...interntaskfileOption) *InternTaskFileMutation {
	m := &InternTaskFileMutation{
		config:        c,
		op:            op,
		typ:           TypeInternTaskFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternTaskFileID sets the ID field of the mutation.
func withInternTaskFileID(id uuid.UUID) interntaskfileOption {
	return func(m *InternTaskFileMutation) {
		var (
			err   error
			once  sync.Once
			value *InternTaskFile
		)
		m.oldValue = func(ctx context.Context) (*InternTaskFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternTaskFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternTaskFile sets the old InternTaskFile of the mutation.
func withInternTaskFile(node *InternTaskFile) interntaskfileOption {
	return func(m *InternTaskFileMutation) {
		m.oldValue = func(context.Context) (*InternTaskFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternTaskFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternTaskFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternTaskFile entities.
func (m *InternTaskFileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternTaskFileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternTaskFileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternTaskFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternTaskFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternTaskFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternTaskFile entity.
// If the InternTaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternTaskFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTaskID sets the "task_id" field.
func (m *InternTaskFileMutation) SetTaskID(u uuid.UUID) {
	m.task_id = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *InternTaskFileMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the InternTaskFile entity.
// If the InternTaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskFileMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *InternTaskFileMutation) ResetTaskID() {
	m.task_id = nil
}

// SetFileKey sets the "file_key" field.
func (m *InternTaskFileMutation) SetFileKey(s string) {
	m.file_key = &s
}

// FileKey returns the value of the "file_key" field in the mutation.
func (m *InternTaskFileMutation) FileKey() (r string, exists bool) {
	v := m.file_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFileKey returns the old "file_key" field's value of the InternTaskFile entity.
// If the InternTaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskFileMutation) OldFileKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileKey: %w", err)
	}
	return oldValue.FileKey, nil
}

// ResetFileKey resets all changes to the "file_key" field.
func (m *InternTaskFileMutation) ResetFileKey() {
	m.file_key = nil
}

// SetFileName sets the "file_name" field.
func (m *InternTaskFileMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *InternTaskFileMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the InternTaskFile entity.
// If the InternTaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskFileMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *InternTaskFileMutation) ResetFileName() {
	m.file_name = nil
}

// SetFileSize sets the "file_size" field.
func (m *InternTaskFileMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *InternTaskFileMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the InternTaskFile entity.
// If the InternTaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskFileMutation) OldFileSize(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *InternTaskFileMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *InternTaskFileMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *InternTaskFileMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[interntaskfile.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *InternTaskFileMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[interntaskfile.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *InternTaskFileMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, interntaskfile.FieldFileSize)
}

// SetMimeType sets the "mime_type" field.
func (m *InternTaskFileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *InternTaskFileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the InternTaskFile entity.
// If the InternTaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternTaskFileMutation) OldMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *InternTaskFileMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[interntaskfile.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *InternTaskFileMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[interntaskfile.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *InternTaskFileMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, interntaskfile.FieldMimeType)
}

// Where appends a list predicates to the InternTaskFileMutation builder.
func (m *InternTaskFileMutation) Where(ps ...predicate.InternTaskFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternTaskFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternTaskFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternTaskFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternTaskFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternTaskFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternTaskFile).
func (m *InternTaskFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternTaskFileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, interntaskfile.FieldCreatedAt)
	}
	if m.task_id != nil {
		fields = append(fields, interntaskfile.FieldTaskID)
	}
	if m.file_key != nil {
		fields = append(fields, interntaskfile.FieldFileKey)
	}
	if m.file_name != nil {
		fields = append(fields, interntaskfile.FieldFileName)
	}
	if m.file_size != nil {
		fields = append(fields, interntaskfile.FieldFileSize)
	}
	if m.mime_type != nil {
		fields = append(fields, interntaskfile.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternTaskFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interntaskfile.FieldCreatedAt:
		return m.CreatedAt()
	case interntaskfile.FieldTaskID:
		return m.TaskID()
	case interntaskfile.FieldFileKey:
		return m.FileKey()
	case interntaskfile.FieldFileName:
		return m.FileName()
	case interntaskfile.FieldFileSize:
		return m.FileSize()
	case interntaskfile.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternTaskFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interntaskfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interntaskfile.FieldTaskID:
		return m.OldTaskID(ctx)
	case interntaskfile.FieldFileKey:
		return m.OldFileKey(ctx)
	case interntaskfile.FieldFileName:
		return m.OldFileName(ctx)
	case interntaskfile.FieldFileSize:
		return m.OldFileSize(ctx)
	case interntaskfile.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown InternTaskFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternTaskFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interntaskfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interntaskfile.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case interntaskfile.FieldFileKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileKey(v)
		return nil
	case interntaskfile.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case interntaskfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case interntaskfile.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown InternTaskFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternTaskFileMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, interntaskfile.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternTaskFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case interntaskfile.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternTaskFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case interntaskfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown InternTaskFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternTaskFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interntaskfile.FieldFileSize) {
		fields = append(fields, interntaskfile.FieldFileSize)
	}
	if m.FieldCleared(interntaskfile.FieldMimeType) {
		fields = append(fields, interntaskfile.FieldMimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternTaskFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternTaskFileMutation) ClearField(name string) error {
	switch name {
	case interntaskfile.FieldFileSize:
		m.ClearFileSize()
		return nil
	case interntaskfile.FieldMimeType:
		m.ClearMimeType()
		return nil
	}
	return fmt.Errorf("unknown InternTaskFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternTaskFileMutation) ResetField(name string) error {
	switch name {
	case interntaskfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interntaskfile.FieldTaskID:
		m.ResetTaskID()
		return nil
	case interntaskfile.FieldFileKey:
		m.ResetFileKey()
		return nil
	case interntaskfile.FieldFileName:
		m.ResetFileName()
		return nil
	case interntaskfile.FieldFileSize:
		m.ResetFileSize()
		return nil
	case interntaskfile.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown InternTaskFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternTaskFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternTaskFileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternTaskFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternTaskFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternTaskFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternTaskFileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternTaskFileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternTaskFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternTaskFileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternTaskFile edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	deleted_at      *time.Time
	conversation_id *uuid.UUID
	sender_id       *uuid.UUID
	content         *string
	file_key        *string
	file_name       *string
	file_mime       *string
	is_read         *bool
	read_at         *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Message, error)
	predicates      []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(u uuid.UUID) {
	m.conversation_id = &u
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r uuid.UUID, exists bool) {
	v := m.conversation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation_id = nil
}

// SetSenderID sets the "sender_id" field.
func (m *MessageMutation) SetSenderID(u uuid.UUID) {
	m.sender_id = &u
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *MessageMutation) SenderID() (r uuid.UUID, exists bool) {
	v := m.sender_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *MessageMutation) ResetSenderID() {
	m.sender_id = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[message.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[message.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, message.FieldContent)
}

// SetFileKey sets the "file_key" field.
func (m *MessageMutation) SetFileKey(s string) {
	m.file_key = &s
}

// FileKey returns the value of the "file_key" field in the mutation.
func (m *MessageMutation) FileKey() (r string, exists bool) {
	v := m.file_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFileKey returns the old "file_key" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldFileKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileKey: %w", err)
	}
	return oldValue.FileKey, nil
}

// ClearFileKey clears the value of the "file_key" field.
func (m *MessageMutation) ClearFileKey() {
	m.file_key = nil
	m.clearedFields[message.FieldFileKey] = struct{}{}
}

// FileKeyCleared returns if the "file_key" field was cleared in this mutation.
func (m *MessageMutation) FileKeyCleared() bool {
	_, ok := m.clearedFields[message.FieldFileKey]
	return ok
}

// ResetFileKey resets all changes to the "file_key" field.
func (m *MessageMutation) ResetFileKey() {
	m.file_key = nil
	delete(m.clearedFields, message.FieldFileKey)
}

// SetFileName sets the "file_name" field.
func (m *MessageMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *MessageMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "file_name" field.
func (m *MessageMutation) ClearFileName() {
	m.file_name = nil
	m.clearedFields[message.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "file_name" field was cleared in this mutation.
func (m *MessageMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[message.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "file_name" field.
func (m *MessageMutation) ResetFileName() {
	m.file_name = nil
	delete(m.clearedFields, message.FieldFileName)
}

// SetFileMime sets the "file_mime" field.
func (m *MessageMutation) SetFileMime(s string) {
	m.file_mime = &s
}

// FileMime returns the value of the "file_mime" field in the mutation.
func (m *MessageMutation) FileMime() (r string, exists bool) {
	v := m.file_mime
	if v == nil {
		return
	}
	return *v, true
}

// OldFileMime returns the old "file_mime" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldFileMime(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileMime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileMime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileMime: %w", err)
	}
	return oldValue.FileMime, nil
}

// ClearFileMime clears the value of the "file_mime" field.
func (m *MessageMutation) ClearFileMime() {
	m.file_mime = nil
	m.clearedFields[message.FieldFileMime] = struct{}{}
}

// FileMimeCleared returns if the "file_mime" field was cleared in this mutation.
func (m *MessageMutation) FileMimeCleared() bool {
	_, ok := m.clearedFields[message.FieldFileMime]
	return ok
}

// ResetFileMime resets all changes to the "file_mime" field.
func (m *MessageMutation) ResetFileMime() {
	m.file_mime = nil
	delete(m.clearedFields, message.FieldFileMime)
}

// SetIsRead sets the "is_read" field.
func (m *MessageMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *MessageMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *MessageMutation) ResetIsRead() {
	m.is_read = nil
}

// SetReadAt sets the "read_at" field.
func (m *MessageMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *MessageMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *MessageMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[message.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *MessageMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[message.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *MessageMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, message.FieldReadAt)
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.conversation_id != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.sender_id != nil {
		fields = append(fields, message.FieldSenderID)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.file_key != nil {
		fields = append(fields, message.FieldFileKey)
	}
	if m.file_name != nil {
		fields = append(fields, message.FieldFileName)
	}
	if m.file_mime != nil {
		fields = append(fields, message.FieldFileMime)
	}
	if m.is_read != nil {
		fields = append(fields, message.FieldIsRead)
	}
	if m.read_at != nil {
		fields = append(fields, message.FieldReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldDeletedAt:
		return m.DeletedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldSenderID:
		return m.SenderID()
	case message.FieldContent:
		return m.Content()
	case message.FieldFileKey:
		return m.FileKey()
	case message.FieldFileName:
		return m.FileName()
	case message.FieldFileMime:
		return m.FileMime()
	case message.FieldIsRead:
		return m.IsRead()
	case message.FieldReadAt:
		return m.ReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldSenderID:
		return m.OldSenderID(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldFileKey:
		return m.OldFileKey(ctx)
	case message.FieldFileName:
		return m.OldFileName(ctx)
	case message.FieldFileMime:
		return m.OldFileMime(ctx)
	case message.FieldIsRead:
		return m.OldIsRead(ctx)
	case message.FieldReadAt:
		return m.OldReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldSenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldFileKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileKey(v)
		return nil
	case message.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case message.FieldFileMime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileMime(v)
		return nil
	case message.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	case message.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.FieldCleared(message.FieldContent) {
		fields = append(fields, message.FieldContent)
	}
	if m.FieldCleared(message.FieldFileKey) {
		fields = append(fields, message.FieldFileKey)
	}
	if m.FieldCleared(message.FieldFileName) {
		fields = append(fields, message.FieldFileName)
	}
	if m.FieldCleared(message.FieldFileMime) {
		fields = append(fields, message.FieldFileMime)
	}
	if m.FieldCleared(message.FieldReadAt) {
		fields = append(fields, message.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case message.FieldContent:
		m.ClearContent()
		return nil
	case message.FieldFileKey:
		m.ClearFileKey()
		return nil
	case message.FieldFileName:
		m.ClearFileName()
		return nil
	case message.FieldFileMime:
		m.ClearFileMime()
		return nil
	case message.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldSenderID:
		m.ResetSenderID()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldFileKey:
		m.ResetFileKey()
		return nil
	case message.FieldFileName:
		m.ResetFileName()
		return nil
	case message.FieldFileMime:
		m.ResetFileMime()
		return nil
	case message.FieldIsRead:
		m.ResetIsRead()
		return nil
	case message.FieldReadAt:
		m.ResetReadAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Message edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	user_id       *uuid.UUID
	_type         *string
	title         *string
	body          *string
	data          *map[string]interface{}
	is_read       *bool
	is_pushed     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id uuid.UUID) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user_id" field.
func (m *NotificationMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationMutation) ResetUserID() {
	m.user_id = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *NotificationMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *NotificationMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *NotificationMutation) ClearBody() {
	m.body = nil
	m.clearedFields[notification.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *NotificationMutation) BodyCleared() bool {
	_, ok := m.clearedFields[notification.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *NotificationMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, notification.FieldBody)
}

// SetData sets the "data" field.
func (m *NotificationMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *NotificationMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *NotificationMutation) ClearData() {
	m.data = nil
	m.clearedFields[notification.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *NotificationMutation) DataCleared() bool {
	_, ok := m.clearedFields[notification.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *NotificationMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, notification.FieldData)
}

// SetIsRead sets the "is_read" field.
func (m *NotificationMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *NotificationMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *NotificationMutation) ResetIsRead() {
	m.is_read = nil
}

// SetIsPushed sets the "is_pushed" field.
func (m *NotificationMutation) SetIsPushed(b bool) {
	m.is_pushed = &b
}

// IsPushed returns the value of the "is_pushed" field in the mutation.
func (m *NotificationMutation) IsPushed() (r bool, exists bool) {
	v := m.is_pushed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPushed returns the old "is_pushed" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldIsPushed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPushed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPushed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPushed: %w", err)
	}
	return oldValue.IsPushed, nil
}

// ResetIsPushed resets all changes to the "is_pushed" field.
func (m *NotificationMutation) ResetIsPushed() {
	m.is_pushed = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, notification.FieldBody)
	}
	if m.data != nil {
		fields = append(fields, notification.FieldData)
	}
	if m.is_read != nil {
		fields = append(fields, notification.FieldIsRead)
	}
	if m.is_pushed != nil {
		fields = append(fields, notification.FieldIsPushed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUserID:
		return m.UserID()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldBody:
		return m.Body()
	case notification.FieldData:
		return m.Data()
	case notification.FieldIsRead:
		return m.IsRead()
	case notification.FieldIsPushed:
		return m.IsPushed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUserID:
		return m.OldUserID(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldBody:
		return m.OldBody(ctx)
	case notification.FieldData:
		return m.OldData(ctx)
	case notification.FieldIsRead:
		return m.OldIsRead(ctx)
	case notification.FieldIsPushed:
		return m.OldIsPushed(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case notification.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case notification.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	case notification.FieldIsPushed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPushed(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldBody) {
		fields = append(fields, notification.FieldBody)
	}
	if m.FieldCleared(notification.FieldData) {
		fields = append(fields, notification.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldBody:
		m.ClearBody()
		return nil
	case notification.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUserID:
		m.ResetUserID()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldBody:
		m.ResetBody()
		return nil
	case notification.FieldData:
		m.ResetData()
		return nil
	case notification.FieldIsRead:
		m.ResetIsRead()
		return nil
	case notification.FieldIsPushed:
		m.ResetIsPushed()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// NotificationPrefMutation represents an operation that mutates the NotificationPref nodes in the graph.
type NotificationPrefMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	user_id           *uuid.UUID
	appointment_sms   *bool
	appointment_push  *bool
	message_push      *bool
	ticket_reply_push *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*NotificationPref, error)
	predicates        []predicate.NotificationPref
}

var _ ent.Mutation = (*NotificationPrefMutation)(nil)

// notificationprefOption allows management of the mutation configuration using functional options.
type notificationprefOption func(*NotificationPrefMutation)

// newNotificationPrefMutation creates new mutation for the NotificationPref entity.
func newNotificationPrefMutation(c config, op Op, opts ...notificationprefOption) *NotificationPrefMutation {
	m := &NotificationPrefMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationPref,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationPrefID sets the ID field of the mutation.
func withNotificationPrefID(id uuid.UUID) notificationprefOption {
	return func(m *NotificationPrefMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationPref
		)
		m.oldValue = func(ctx context.Context) (*NotificationPref, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationPref.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationPref sets the old NotificationPref of the mutation.
func withNotificationPref(node *NotificationPref) notificationprefOption {
	return func(m *NotificationPrefMutation) {
		m.oldValue = func(context.Context) (*NotificationPref, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationPrefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationPrefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationPref entities.
func (m *NotificationPrefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationPrefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationPrefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationPref.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationPrefMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationPrefMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationPrefMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationPrefMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationPrefMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationPrefMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *NotificationPrefMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationPrefMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationPrefMutation) ResetUserID() {
	m.user_id = nil
}

// SetAppointmentSms sets the "appointment_sms" field.
func (m *NotificationPrefMutation) SetAppointmentSms(b bool) {
	m.appointment_sms = &b
}

// AppointmentSms returns the value of the "appointment_sms" field in the mutation.
func (m *NotificationPrefMutation) AppointmentSms() (r bool, exists bool) {
	v := m.appointment_sms
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentSms returns the old "appointment_sms" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldAppointmentSms(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentSms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentSms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentSms: %w", err)
	}
	return oldValue.AppointmentSms, nil
}

// ResetAppointmentSms resets all changes to the "appointment_sms" field.
func (m *NotificationPrefMutation) ResetAppointmentSms() {
	m.appointment_sms = nil
}

// SetAppointmentPush sets the "appointment_push" field.
func (m *NotificationPrefMutation) SetAppointmentPush(b bool) {
	m.appointment_push = &b
}

// AppointmentPush returns the value of the "appointment_push" field in the mutation.
func (m *NotificationPrefMutation) AppointmentPush() (r bool, exists bool) {
	v := m.appointment_push
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentPush returns the old "appointment_push" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldAppointmentPush(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentPush is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentPush requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentPush: %w", err)
	}
	return oldValue.AppointmentPush, nil
}

// ResetAppointmentPush resets all changes to the "appointment_push" field.
func (m *NotificationPrefMutation) ResetAppointmentPush() {
	m.appointment_push = nil
}

// SetMessagePush sets the "message_push" field.
func (m *NotificationPrefMutation) SetMessagePush(b bool) {
	m.message_push = &b
}

// MessagePush returns the value of the "message_push" field in the mutation.
func (m *NotificationPrefMutation) MessagePush() (r bool, exists bool) {
	v := m.message_push
	if v == nil {
		return
	}
	return *v, true
}

// OldMessagePush returns the old "message_push" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldMessagePush(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessagePush is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessagePush requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessagePush: %w", err)
	}
	return oldValue.MessagePush, nil
}

// ResetMessagePush resets all changes to the "message_push" field.
func (m *NotificationPrefMutation) ResetMessagePush() {
	m.message_push = nil
}

// SetTicketReplyPush sets the "ticket_reply_push" field.
func (m *NotificationPrefMutation) SetTicketReplyPush(b bool) {
	m.ticket_reply_push = &b
}

// TicketReplyPush returns the value of the "ticket_reply_push" field in the mutation.
func (m *NotificationPrefMutation) TicketReplyPush() (r bool, exists bool) {
	v := m.ticket_reply_push
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketReplyPush returns the old "ticket_reply_push" field's value of the NotificationPref entity.
// If the NotificationPref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPrefMutation) OldTicketReplyPush(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketReplyPush is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketReplyPush requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketReplyPush: %w", err)
	}
	return oldValue.TicketReplyPush, nil
}

// ResetTicketReplyPush resets all changes to the "ticket_reply_push" field.
func (m *NotificationPrefMutation) ResetTicketReplyPush() {
	m.ticket_reply_push = nil
}

// Where appends a list predicates to the NotificationPrefMutation builder.
func (m *NotificationPrefMutation) Where(ps ...predicate.NotificationPref) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationPrefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationPrefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationPref, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationPrefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationPrefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationPref).
func (m *NotificationPrefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationPrefMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, notificationpref.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationpref.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, notificationpref.FieldUserID)
	}
	if m.appointment_sms != nil {
		fields = append(fields, notificationpref.FieldAppointmentSms)
	}
	if m.appointment_push != nil {
		fields = append(fields, notificationpref.FieldAppointmentPush)
	}
	if m.message_push != nil {
		fields = append(fields, notificationpref.FieldMessagePush)
	}
	if m.ticket_reply_push != nil {
		fields = append(fields, notificationpref.FieldTicketReplyPush)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationPrefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationpref.FieldCreatedAt:
		return m.CreatedAt()
	case notificationpref.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationpref.FieldUserID:
		return m.UserID()
	case notificationpref.FieldAppointmentSms:
		return m.AppointmentSms()
	case notificationpref.FieldAppointmentPush:
		return m.AppointmentPush()
	case notificationpref.FieldMessagePush:
		return m.MessagePush()
	case notificationpref.FieldTicketReplyPush:
		return m.TicketReplyPush()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationPrefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationpref.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationpref.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationpref.FieldUserID:
		return m.OldUserID(ctx)
	case notificationpref.FieldAppointmentSms:
		return m.OldAppointmentSms(ctx)
	case notificationpref.FieldAppointmentPush:
		return m.OldAppointmentPush(ctx)
	case notificationpref.FieldMessagePush:
		return m.OldMessagePush(ctx)
	case notificationpref.FieldTicketReplyPush:
		return m.OldTicketReplyPush(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationPref field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationPrefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationpref.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationpref.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationpref.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notificationpref.FieldAppointmentSms:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentSms(v)
		return nil
	case notificationpref.FieldAppointmentPush:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentPush(v)
		return nil
	case notificationpref.FieldMessagePush:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessagePush(v)
		return nil
	case notificationpref.FieldTicketReplyPush:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketReplyPush(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationPref field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationPrefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationPrefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationPrefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationPref numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationPrefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationPrefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationPrefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationPref nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationPrefMutation) ResetField(name string) error {
	switch name {
	case notificationpref.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationpref.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationpref.FieldUserID:
		m.ResetUserID()
		return nil
	case notificationpref.FieldAppointmentSms:
		m.ResetAppointmentSms()
		return nil
	case notificationpref.FieldAppointmentPush:
		m.ResetAppointmentPush()
		return nil
	case notificationpref.FieldMessagePush:
		m.ResetMessagePush()
		return nil
	case notificationpref.FieldTicketReplyPush:
		m.ResetTicketReplyPush()
		return nil
	}
	return fmt.Errorf("unknown NotificationPref field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationPrefMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationPrefMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationPrefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationPrefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationPrefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationPrefMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationPrefMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationPref unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationPrefMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationPref edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	file_number              *string
	status                   *patient.Status
	session_count            *int
	addsession_count         *int
	total_cancellations      *int
	addtotal_cancellations   *int
	last_cancel_reason       *string
	has_discount             *bool
	discount_percent         *int
	adddiscount_percent      *int
	payment_status           *patient.PaymentStatus
	total_paid               *int64
	addtotal_paid            *int64
	notes                    *string
	referral_source          *string
	chief_complaint          *string
	is_child                 *bool
	child_birth_date         *time.Time
	child_school             *string
	child_grade              *string
	parent_name              *string
	parent_phone             *string
	parent_relation          *string
	developmental_history    *map[string]interface{}
	clearedFields            map[string]struct{}
	clinic                   *uuid.UUID
	clearedclinic            bool
	user                     *uuid.UUID
	cleareduser              bool
	primary_therapist        *uuid.UUID
	clearedprimary_therapist bool
	reports                  map[uuid.UUID]struct{}
	removedreports           map[uuid.UUID]struct{}
	clearedreports           bool
	files                    map[uuid.UUID]struct{}
	removedfiles             map[uuid.UUID]struct{}
	clearedfiles             bool
	prescriptions            map[uuid.UUID]struct{}
	removedprescriptions     map[uuid.UUID]struct{}
	clearedprescriptions     bool
	tests                    map[uuid.UUID]struct{}
	removedtests             map[uuid.UUID]struct{}
	clearedtests             bool
	done                     bool
	oldValue                 func(context.Context) (*Patient, error)
	predicates               []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id uuid.UUID) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Patient entities.
func (m *PatientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Patient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PatientMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PatientMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PatientMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[patient.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PatientMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[patient.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PatientMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, patient.FieldDeletedAt)
}

// SetClinicID sets the "clinic_id" field.
func (m *PatientMutation) SetClinicID(u uuid.UUID) {
	m.clinic = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PatientMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PatientMutation) ResetClinicID() {
	m.clinic = nil
}

// SetUserID sets the "user_id" field.
func (m *PatientMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PatientMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PatientMutation) ResetUserID() {
	m.user = nil
}

// SetPrimaryTherapistID sets the "primary_therapist_id" field.
func (m *PatientMutation) SetPrimaryTherapistID(u uuid.UUID) {
	m.primary_therapist = &u
}

// PrimaryTherapistID returns the value of the "primary_therapist_id" field in the mutation.
func (m *PatientMutation) PrimaryTherapistID() (r uuid.UUID, exists bool) {
	v := m.primary_therapist
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryTherapistID returns the old "primary_therapist_id" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPrimaryTherapistID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryTherapistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryTherapistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryTherapistID: %w", err)
	}
	return oldValue.PrimaryTherapistID, nil
}

// ClearPrimaryTherapistID clears the value of the "primary_therapist_id" field.
func (m *PatientMutation) ClearPrimaryTherapistID() {
	m.primary_therapist = nil
	m.clearedFields[patient.FieldPrimaryTherapistID] = struct{}{}
}

// PrimaryTherapistIDCleared returns if the "primary_therapist_id" field was cleared in this mutation.
func (m *PatientMutation) PrimaryTherapistIDCleared() bool {
	_, ok := m.clearedFields[patient.FieldPrimaryTherapistID]
	return ok
}

// ResetPrimaryTherapistID resets all changes to the "primary_therapist_id" field.
func (m *PatientMutation) ResetPrimaryTherapistID() {
	m.primary_therapist = nil
	delete(m.clearedFields, patient.FieldPrimaryTherapistID)
}

// SetFileNumber sets the "file_number" field.
func (m *PatientMutation) SetFileNumber(s string) {
	m.file_number = &s
}

// FileNumber returns the value of the "file_number" field in the mutation.
func (m *PatientMutation) FileNumber() (r string, exists bool) {
	v := m.file_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFileNumber returns the old "file_number" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldFileNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileNumber: %w", err)
	}
	return oldValue.FileNumber, nil
}

// ClearFileNumber clears the value of the "file_number" field.
func (m *PatientMutation) ClearFileNumber() {
	m.file_number = nil
	m.clearedFields[patient.FieldFileNumber] = struct{}{}
}

// FileNumberCleared returns if the "file_number" field was cleared in this mutation.
func (m *PatientMutation) FileNumberCleared() bool {
	_, ok := m.clearedFields[patient.FieldFileNumber]
	return ok
}

// ResetFileNumber resets all changes to the "file_number" field.
func (m *PatientMutation) ResetFileNumber() {
	m.file_number = nil
	delete(m.clearedFields, patient.FieldFileNumber)
}

// SetStatus sets the "status" field.
func (m *PatientMutation) SetStatus(pa patient.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PatientMutation) Status() (r patient.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldStatus(ctx context.Context) (v patient.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PatientMutation) ResetStatus() {
	m.status = nil
}

// SetSessionCount sets the "session_count" field.
func (m *PatientMutation) SetSessionCount(i int) {
	m.session_count = &i
	m.addsession_count = nil
}

// SessionCount returns the value of the "session_count" field in the mutation.
func (m *PatientMutation) SessionCount() (r int, exists bool) {
	v := m.session_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionCount returns the old "session_count" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldSessionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionCount: %w", err)
	}
	return oldValue.SessionCount, nil
}

// AddSessionCount adds i to the "session_count" field.
func (m *PatientMutation) AddSessionCount(i int) {
	if m.addsession_count != nil {
		*m.addsession_count += i
	} else {
		m.addsession_count = &i
	}
}

// AddedSessionCount returns the value that was added to the "session_count" field in this mutation.
func (m *PatientMutation) AddedSessionCount() (r int, exists bool) {
	v := m.addsession_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessionCount resets all changes to the "session_count" field.
func (m *PatientMutation) ResetSessionCount() {
	m.session_count = nil
	m.addsession_count = nil
}

// SetTotalCancellations sets the "total_cancellations" field.
func (m *PatientMutation) SetTotalCancellations(i int) {
	m.total_cancellations = &i
	m.addtotal_cancellations = nil
}

// TotalCancellations returns the value of the "total_cancellations" field in the mutation.
func (m *PatientMutation) TotalCancellations() (r int, exists bool) {
	v := m.total_cancellations
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCancellations returns the old "total_cancellations" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldTotalCancellations(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCancellations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCancellations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCancellations: %w", err)
	}
	return oldValue.TotalCancellations, nil
}

// AddTotalCancellations adds i to the "total_cancellations" field.
func (m *PatientMutation) AddTotalCancellations(i int) {
	if m.addtotal_cancellations != nil {
		*m.addtotal_cancellations += i
	} else {
		m.addtotal_cancellations = &i
	}
}

// AddedTotalCancellations returns the value that was added to the "total_cancellations" field in this mutation.
func (m *PatientMutation) AddedTotalCancellations() (r int, exists bool) {
	v := m.addtotal_cancellations
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCancellations resets all changes to the "total_cancellations" field.
func (m *PatientMutation) ResetTotalCancellations() {
	m.total_cancellations = nil
	m.addtotal_cancellations = nil
}

// SetLastCancelReason sets the "last_cancel_reason" field.
func (m *PatientMutation) SetLastCancelReason(s string) {
	m.last_cancel_reason = &s
}

// LastCancelReason returns the value of the "last_cancel_reason" field in the mutation.
func (m *PatientMutation) LastCancelReason() (r string, exists bool) {
	v := m.last_cancel_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCancelReason returns the old "last_cancel_reason" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldLastCancelReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCancelReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCancelReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCancelReason: %w", err)
	}
	return oldValue.LastCancelReason, nil
}

// ClearLastCancelReason clears the value of the "last_cancel_reason" field.
func (m *PatientMutation) ClearLastCancelReason() {
	m.last_cancel_reason = nil
	m.clearedFields[patient.FieldLastCancelReason] = struct{}{}
}

// LastCancelReasonCleared returns if the "last_cancel_reason" field was cleared in this mutation.
func (m *PatientMutation) LastCancelReasonCleared() bool {
	_, ok := m.clearedFields[patient.FieldLastCancelReason]
	return ok
}

// ResetLastCancelReason resets all changes to the "last_cancel_reason" field.
func (m *PatientMutation) ResetLastCancelReason() {
	m.last_cancel_reason = nil
	delete(m.clearedFields, patient.FieldLastCancelReason)
}

// SetHasDiscount sets the "has_discount" field.
func (m *PatientMutation) SetHasDiscount(b bool) {
	m.has_discount = &b
}

// HasDiscount returns the value of the "has_discount" field in the mutation.
func (m *PatientMutation) HasDiscount() (r bool, exists bool) {
	v := m.has_discount
	if v == nil {
		return
	}
	return *v, true
}

// OldHasDiscount returns the old "has_discount" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldHasDiscount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasDiscount: %w", err)
	}
	return oldValue.HasDiscount, nil
}

// ResetHasDiscount resets all changes to the "has_discount" field.
func (m *PatientMutation) ResetHasDiscount() {
	m.has_discount = nil
}

// SetDiscountPercent sets the "discount_percent" field.
func (m *PatientMutation) SetDiscountPercent(i int) {
	m.discount_percent = &i
	m.adddiscount_percent = nil
}

// DiscountPercent returns the value of the "discount_percent" field in the mutation.
func (m *PatientMutation) DiscountPercent() (r int, exists bool) {
	v := m.discount_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPercent returns the old "discount_percent" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDiscountPercent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPercent: %w", err)
	}
	return oldValue.DiscountPercent, nil
}

// AddDiscountPercent adds i to the "discount_percent" field.
func (m *PatientMutation) AddDiscountPercent(i int) {
	if m.adddiscount_percent != nil {
		*m.adddiscount_percent += i
	} else {
		m.adddiscount_percent = &i
	}
}

// AddedDiscountPercent returns the value that was added to the "discount_percent" field in this mutation.
func (m *PatientMutation) AddedDiscountPercent() (r int, exists bool) {
	v := m.adddiscount_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountPercent resets all changes to the "discount_percent" field.
func (m *PatientMutation) ResetDiscountPercent() {
	m.discount_percent = nil
	m.adddiscount_percent = nil
}

// SetPaymentStatus sets the "payment_status" field.
func (m *PatientMutation) SetPaymentStatus(ps patient.PaymentStatus) {
	m.payment_status = &ps
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *PatientMutation) PaymentStatus() (r patient.PaymentStatus, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPaymentStatus(ctx context.Context) (v patient.PaymentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *PatientMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetTotalPaid sets the "total_paid" field.
func (m *PatientMutation) SetTotalPaid(i int64) {
	m.total_paid = &i
	m.addtotal_paid = nil
}

// TotalPaid returns the value of the "total_paid" field in the mutation.
func (m *PatientMutation) TotalPaid() (r int64, exists bool) {
	v := m.total_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPaid returns the old "total_paid" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldTotalPaid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPaid: %w", err)
	}
	return oldValue.TotalPaid, nil
}

// AddTotalPaid adds i to the "total_paid" field.
func (m *PatientMutation) AddTotalPaid(i int64) {
	if m.addtotal_paid != nil {
		*m.addtotal_paid += i
	} else {
		m.addtotal_paid = &i
	}
}

// AddedTotalPaid returns the value that was added to the "total_paid" field in this mutation.
func (m *PatientMutation) AddedTotalPaid() (r int64, exists bool) {
	v := m.addtotal_paid
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPaid resets all changes to the "total_paid" field.
func (m *PatientMutation) ResetTotalPaid() {
	m.total_paid = nil
	m.addtotal_paid = nil
}

// SetNotes sets the "notes" field.
func (m *PatientMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PatientMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *PatientMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[patient.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PatientMutation) NotesCleared() bool {
	_, ok := m.clearedFields[patient.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PatientMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, patient.FieldNotes)
}

// SetReferralSource sets the "referral_source" field.
func (m *PatientMutation) SetReferralSource(s string) {
	m.referral_source = &s
}

// ReferralSource returns the value of the "referral_source" field in the mutation.
func (m *PatientMutation) ReferralSource() (r string, exists bool) {
	v := m.referral_source
	if v == nil {
		return
	}
	return *v, true
}

// OldReferralSource returns the old "referral_source" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldReferralSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferralSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferralSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferralSource: %w", err)
	}
	return oldValue.ReferralSource, nil
}

// ClearReferralSource clears the value of the "referral_source" field.
func (m *PatientMutation) ClearReferralSource() {
	m.referral_source = nil
	m.clearedFields[patient.FieldReferralSource] = struct{}{}
}

// ReferralSourceCleared returns if the "referral_source" field was cleared in this mutation.
func (m *PatientMutation) ReferralSourceCleared() bool {
	_, ok := m.clearedFields[patient.FieldReferralSource]
	return ok
}

// ResetReferralSource resets all changes to the "referral_source" field.
func (m *PatientMutation) ResetReferralSource() {
	m.referral_source = nil
	delete(m.clearedFields, patient.FieldReferralSource)
}

// SetChiefComplaint sets the "chief_complaint" field.
func (m *PatientMutation) SetChiefComplaint(s string) {
	m.chief_complaint = &s
}

// ChiefComplaint returns the value of the "chief_complaint" field in the mutation.
func (m *PatientMutation) ChiefComplaint() (r string, exists bool) {
	v := m.chief_complaint
	if v == nil {
		return
	}
	return *v, true
}

// OldChiefComplaint returns the old "chief_complaint" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldChiefComplaint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChiefComplaint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChiefComplaint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChiefComplaint: %w", err)
	}
	return oldValue.ChiefComplaint, nil
}

// ClearChiefComplaint clears the value of the "chief_complaint" field.
func (m *PatientMutation) ClearChiefComplaint() {
	m.chief_complaint = nil
	m.clearedFields[patient.FieldChiefComplaint] = struct{}{}
}

// ChiefComplaintCleared returns if the "chief_complaint" field was cleared in this mutation.
func (m *PatientMutation) ChiefComplaintCleared() bool {
	_, ok := m.clearedFields[patient.FieldChiefComplaint]
	return ok
}

// ResetChiefComplaint resets all changes to the "chief_complaint" field.
func (m *PatientMutation) ResetChiefComplaint() {
	m.chief_complaint = nil
	delete(m.clearedFields, patient.FieldChiefComplaint)
}

// SetIsChild sets the "is_child" field.
func (m *PatientMutation) SetIsChild(b bool) {
	m.is_child = &b
}

// IsChild returns the value of the "is_child" field in the mutation.
func (m *PatientMutation) IsChild() (r bool, exists bool) {
	v := m.is_child
	if v == nil {
		return
	}
	return *v, true
}

// OldIsChild returns the old "is_child" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldIsChild(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsChild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsChild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsChild: %w", err)
	}
	return oldValue.IsChild, nil
}

// ResetIsChild resets all changes to the "is_child" field.
func (m *PatientMutation) ResetIsChild() {
	m.is_child = nil
}

// SetChildBirthDate sets the "child_birth_date" field.
func (m *PatientMutation) SetChildBirthDate(t time.Time) {
	m.child_birth_date = &t
}

// ChildBirthDate returns the value of the "child_birth_date" field in the mutation.
func (m *PatientMutation) ChildBirthDate() (r time.Time, exists bool) {
	v := m.child_birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldChildBirthDate returns the old "child_birth_date" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldChildBirthDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildBirthDate: %w", err)
	}
	return oldValue.ChildBirthDate, nil
}

// ClearChildBirthDate clears the value of the "child_birth_date" field.
func (m *PatientMutation) ClearChildBirthDate() {
	m.child_birth_date = nil
	m.clearedFields[patient.FieldChildBirthDate] = struct{}{}
}

// ChildBirthDateCleared returns if the "child_birth_date" field was cleared in this mutation.
func (m *PatientMutation) ChildBirthDateCleared() bool {
	_, ok := m.clearedFields[patient.FieldChildBirthDate]
	return ok
}

// ResetChildBirthDate resets all changes to the "child_birth_date" field.
func (m *PatientMutation) ResetChildBirthDate() {
	m.child_birth_date = nil
	delete(m.clearedFields, patient.FieldChildBirthDate)
}

// SetChildSchool sets the "child_school" field.
func (m *PatientMutation) SetChildSchool(s string) {
	m.child_school = &s
}

// ChildSchool returns the value of the "child_school" field in the mutation.
func (m *PatientMutation) ChildSchool() (r string, exists bool) {
	v := m.child_school
	if v == nil {
		return
	}
	return *v, true
}

// OldChildSchool returns the old "child_school" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldChildSchool(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildSchool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildSchool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildSchool: %w", err)
	}
	return oldValue.ChildSchool, nil
}

// ClearChildSchool clears the value of the "child_school" field.
func (m *PatientMutation) ClearChildSchool() {
	m.child_school = nil
	m.clearedFields[patient.FieldChildSchool] = struct{}{}
}

// ChildSchoolCleared returns if the "child_school" field was cleared in this mutation.
func (m *PatientMutation) ChildSchoolCleared() bool {
	_, ok := m.clearedFields[patient.FieldChildSchool]
	return ok
}

// ResetChildSchool resets all changes to the "child_school" field.
func (m *PatientMutation) ResetChildSchool() {
	m.child_school = nil
	delete(m.clearedFields, patient.FieldChildSchool)
}

// SetChildGrade sets the "child_grade" field.
func (m *PatientMutation) SetChildGrade(s string) {
	m.child_grade = &s
}

// ChildGrade returns the value of the "child_grade" field in the mutation.
func (m *PatientMutation) ChildGrade() (r string, exists bool) {
	v := m.child_grade
	if v == nil {
		return
	}
	return *v, true
}

// OldChildGrade returns the old "child_grade" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldChildGrade(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildGrade: %w", err)
	}
	return oldValue.ChildGrade, nil
}

// ClearChildGrade clears the value of the "child_grade" field.
func (m *PatientMutation) ClearChildGrade() {
	m.child_grade = nil
	m.clearedFields[patient.FieldChildGrade] = struct{}{}
}

// ChildGradeCleared returns if the "child_grade" field was cleared in this mutation.
func (m *PatientMutation) ChildGradeCleared() bool {
	_, ok := m.clearedFields[patient.FieldChildGrade]
	return ok
}

// ResetChildGrade resets all changes to the "child_grade" field.
func (m *PatientMutation) ResetChildGrade() {
	m.child_grade = nil
	delete(m.clearedFields, patient.FieldChildGrade)
}

// SetParentName sets the "parent_name" field.
func (m *PatientMutation) SetParentName(s string) {
	m.parent_name = &s
}

// ParentName returns the value of the "parent_name" field in the mutation.
func (m *PatientMutation) ParentName() (r string, exists bool) {
	v := m.parent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldParentName returns the old "parent_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldParentName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentName: %w", err)
	}
	return oldValue.ParentName, nil
}

// ClearParentName clears the value of the "parent_name" field.
func (m *PatientMutation) ClearParentName() {
	m.parent_name = nil
	m.clearedFields[patient.FieldParentName] = struct{}{}
}

// ParentNameCleared returns if the "parent_name" field was cleared in this mutation.
func (m *PatientMutation) ParentNameCleared() bool {
	_, ok := m.clearedFields[patient.FieldParentName]
	return ok
}

// ResetParentName resets all changes to the "parent_name" field.
func (m *PatientMutation) ResetParentName() {
	m.parent_name = nil
	delete(m.clearedFields, patient.FieldParentName)
}

// SetParentPhone sets the "parent_phone" field.
func (m *PatientMutation) SetParentPhone(s string) {
	m.parent_phone = &s
}

// ParentPhone returns the value of the "parent_phone" field in the mutation.
func (m *PatientMutation) ParentPhone() (r string, exists bool) {
	v := m.parent_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldParentPhone returns the old "parent_phone" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldParentPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentPhone: %w", err)
	}
	return oldValue.ParentPhone, nil
}

// ClearParentPhone clears the value of the "parent_phone" field.
func (m *PatientMutation) ClearParentPhone() {
	m.parent_phone = nil
	m.clearedFields[patient.FieldParentPhone] = struct{}{}
}

// ParentPhoneCleared returns if the "parent_phone" field was cleared in this mutation.
func (m *PatientMutation) ParentPhoneCleared() bool {
	_, ok := m.clearedFields[patient.FieldParentPhone]
	return ok
}

// ResetParentPhone resets all changes to the "parent_phone" field.
func (m *PatientMutation) ResetParentPhone() {
	m.parent_phone = nil
	delete(m.clearedFields, patient.FieldParentPhone)
}

// SetParentRelation sets the "parent_relation" field.
func (m *PatientMutation) SetParentRelation(s string) {
	m.parent_relation = &s
}

// ParentRelation returns the value of the "parent_relation" field in the mutation.
func (m *PatientMutation) ParentRelation() (r string, exists bool) {
	v := m.parent_relation
	if v == nil {
		return
	}
	return *v, true
}

// OldParentRelation returns the old "parent_relation" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldParentRelation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentRelation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentRelation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentRelation: %w", err)
	}
	return oldValue.ParentRelation, nil
}

// ClearParentRelation clears the value of the "parent_relation" field.
func (m *PatientMutation) ClearParentRelation() {
	m.parent_relation = nil
	m.clearedFields[patient.FieldParentRelation] = struct{}{}
}

// ParentRelationCleared returns if the "parent_relation" field was cleared in this mutation.
func (m *PatientMutation) ParentRelationCleared() bool {
	_, ok := m.clearedFields[patient.FieldParentRelation]
	return ok
}

// ResetParentRelation resets all changes to the "parent_relation" field.
func (m *PatientMutation) ResetParentRelation() {
	m.parent_relation = nil
	delete(m.clearedFields, patient.FieldParentRelation)
}

// SetDevelopmentalHistory sets the "developmental_history" field.
func (m *PatientMutation) SetDevelopmentalHistory(value map[string]interface{}) {
	m.developmental_history = &value
}

// DevelopmentalHistory returns the value of the "developmental_history" field in the mutation.
func (m *PatientMutation) DevelopmentalHistory() (r map[string]interface{}, exists bool) {
	v := m.developmental_history
	if v == nil {
		return
	}
	return *v, true
}

// OldDevelopmentalHistory returns the old "developmental_history" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDevelopmentalHistory(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevelopmentalHistory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevelopmentalHistory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevelopmentalHistory: %w", err)
	}
	return oldValue.DevelopmentalHistory, nil
}

// ClearDevelopmentalHistory clears the value of the "developmental_history" field.
func (m *PatientMutation) ClearDevelopmentalHistory() {
	m.developmental_history = nil
	m.clearedFields[patient.FieldDevelopmentalHistory] = struct{}{}
}

// DevelopmentalHistoryCleared returns if the "developmental_history" field was cleared in this mutation.
func (m *PatientMutation) DevelopmentalHistoryCleared() bool {
	_, ok := m.clearedFields[patient.FieldDevelopmentalHistory]
	return ok
}

// ResetDevelopmentalHistory resets all changes to the "developmental_history" field.
func (m *PatientMutation) ResetDevelopmentalHistory() {
	m.developmental_history = nil
	delete(m.clearedFields, patient.FieldDevelopmentalHistory)
}

// ClearClinic clears the "clinic" edge to the Clinic entity.
func (m *PatientMutation) ClearClinic() {
	m.clearedclinic = true
	m.clearedFields[patient.FieldClinicID] = struct{}{}
}

// ClinicCleared reports if the "clinic" edge to the Clinic entity was cleared.
func (m *PatientMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicIDs returns the "clinic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) ClinicIDs() (ids []uuid.UUID) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic resets all changes to the "clinic" edge.
func (m *PatientMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *PatientMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[patient.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PatientMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PatientMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPrimaryTherapist clears the "primary_therapist" edge to the ClinicMember entity.
func (m *PatientMutation) ClearPrimaryTherapist() {
	m.clearedprimary_therapist = true
	m.clearedFields[patient.FieldPrimaryTherapistID] = struct{}{}
}

// PrimaryTherapistCleared reports if the "primary_therapist" edge to the ClinicMember entity was cleared.
func (m *PatientMutation) PrimaryTherapistCleared() bool {
	return m.PrimaryTherapistIDCleared() || m.clearedprimary_therapist
}

// PrimaryTherapistIDs returns the "primary_therapist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryTherapistID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) PrimaryTherapistIDs() (ids []uuid.UUID) {
	if id := m.primary_therapist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryTherapist resets all changes to the "primary_therapist" edge.
func (m *PatientMutation) ResetPrimaryTherapist() {
	m.primary_therapist = nil
	m.clearedprimary_therapist = false
}

// AddReportIDs adds the "reports" edge to the PatientReport entity by ids.
func (m *PatientMutation) AddReportIDs(ids ...uuid.UUID) {
	if m.reports == nil {
		m.reports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the PatientReport entity.
func (m *PatientMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the PatientReport entity was cleared.
func (m *PatientMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the PatientReport entity by IDs.
func (m *PatientMutation) RemoveReportIDs(ids ...uuid.UUID) {
	if m.removedreports == nil {
		m.removedreports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the PatientReport entity.
func (m *PatientMutation) RemovedReportsIDs() (ids []uuid.UUID) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *PatientMutation) ReportsIDs() (ids []uuid.UUID) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *PatientMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// AddFileIDs adds the "files" edge to the PatientFile entity by ids.
func (m *PatientMutation) AddFileIDs(ids ...uuid.UUID) {
	if m.files == nil {
		m.files = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the PatientFile entity.
func (m *PatientMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the PatientFile entity was cleared.
func (m *PatientMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the PatientFile entity by IDs.
func (m *PatientMutation) RemoveFileIDs(ids ...uuid.UUID) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the PatientFile entity.
func (m *PatientMutation) RemovedFilesIDs() (ids []uuid.UUID) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *PatientMutation) FilesIDs() (ids []uuid.UUID) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *PatientMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddPrescriptionIDs adds the "prescriptions" edge to the PatientPrescription entity by ids.
func (m *PatientMutation) AddPrescriptionIDs(ids ...uuid.UUID) {
	if m.prescriptions == nil {
		m.prescriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.prescriptions[ids[i]] = struct{}{}
	}
}

// ClearPrescriptions clears the "prescriptions" edge to the PatientPrescription entity.
func (m *PatientMutation) ClearPrescriptions() {
	m.clearedprescriptions = true
}

// PrescriptionsCleared reports if the "prescriptions" edge to the PatientPrescription entity was cleared.
func (m *PatientMutation) PrescriptionsCleared() bool {
	return m.clearedprescriptions
}

// RemovePrescriptionIDs removes the "prescriptions" edge to the PatientPrescription entity by IDs.
func (m *PatientMutation) RemovePrescriptionIDs(ids ...uuid.UUID) {
	if m.removedprescriptions == nil {
		m.removedprescriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.prescriptions, ids[i])
		m.removedprescriptions[ids[i]] = struct{}{}
	}
}

// RemovedPrescriptions returns the removed IDs of the "prescriptions" edge to the PatientPrescription entity.
func (m *PatientMutation) RemovedPrescriptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedprescriptions {
		ids = append(ids, id)
	}
	return
}

// PrescriptionsIDs returns the "prescriptions" edge IDs in the mutation.
func (m *PatientMutation) PrescriptionsIDs() (ids []uuid.UUID) {
	for id := range m.prescriptions {
		ids = append(ids, id)
	}
	return
}

// ResetPrescriptions resets all changes to the "prescriptions" edge.
func (m *PatientMutation) ResetPrescriptions() {
	m.prescriptions = nil
	m.clearedprescriptions = false
	m.removedprescriptions = nil
}

// AddTestIDs adds the "tests" edge to the PatientTest entity by ids.
func (m *PatientMutation) AddTestIDs(ids ...uuid.UUID) {
	if m.tests == nil {
		m.tests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the PatientTest entity.
func (m *PatientMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the PatientTest entity was cleared.
func (m *PatientMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the PatientTest entity by IDs.
func (m *PatientMutation) RemoveTestIDs(ids ...uuid.UUID) {
	if m.removedtests == nil {
		m.removedtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the PatientTest entity.
func (m *PatientMutation) RemovedTestsIDs() (ids []uuid.UUID) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *PatientMutation) TestsIDs() (ids []uuid.UUID) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *PatientMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the PatientMutation builder.
func (m *PatientMutation) Where(ps ...predicate.Patient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Patient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, patient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patient.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, patient.FieldDeletedAt)
	}
	if m.clinic != nil {
		fields = append(fields, patient.FieldClinicID)
	}
	if m.user != nil {
		fields = append(fields, patient.FieldUserID)
	}
	if m.primary_therapist != nil {
		fields = append(fields, patient.FieldPrimaryTherapistID)
	}
	if m.file_number != nil {
		fields = append(fields, patient.FieldFileNumber)
	}
	if m.status != nil {
		fields = append(fields, patient.FieldStatus)
	}
	if m.session_count != nil {
		fields = append(fields, patient.FieldSessionCount)
	}
	if m.total_cancellations != nil {
		fields = append(fields, patient.FieldTotalCancellations)
	}
	if m.last_cancel_reason != nil {
		fields = append(fields, patient.FieldLastCancelReason)
	}
	if m.has_discount != nil {
		fields = append(fields, patient.FieldHasDiscount)
	}
	if m.discount_percent != nil {
		fields = append(fields, patient.FieldDiscountPercent)
	}
	if m.payment_status != nil {
		fields = append(fields, patient.FieldPaymentStatus)
	}
	if m.total_paid != nil {
		fields = append(fields, patient.FieldTotalPaid)
	}
	if m.notes != nil {
		fields = append(fields, patient.FieldNotes)
	}
	if m.referral_source != nil {
		fields = append(fields, patient.FieldReferralSource)
	}
	if m.chief_complaint != nil {
		fields = append(fields, patient.FieldChiefComplaint)
	}
	if m.is_child != nil {
		fields = append(fields, patient.FieldIsChild)
	}
	if m.child_birth_date != nil {
		fields = append(fields, patient.FieldChildBirthDate)
	}
	if m.child_school != nil {
		fields = append(fields, patient.FieldChildSchool)
	}
	if m.child_grade != nil {
		fields = append(fields, patient.FieldChildGrade)
	}
	if m.parent_name != nil {
		fields = append(fields, patient.FieldParentName)
	}
	if m.parent_phone != nil {
		fields = append(fields, patient.FieldParentPhone)
	}
	if m.parent_relation != nil {
		fields = append(fields, patient.FieldParentRelation)
	}
	if m.developmental_history != nil {
		fields = append(fields, patient.FieldDevelopmentalHistory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldCreatedAt:
		return m.CreatedAt()
	case patient.FieldUpdatedAt:
		return m.UpdatedAt()
	case patient.FieldDeletedAt:
		return m.DeletedAt()
	case patient.FieldClinicID:
		return m.ClinicID()
	case patient.FieldUserID:
		return m.UserID()
	case patient.FieldPrimaryTherapistID:
		return m.PrimaryTherapistID()
	case patient.FieldFileNumber:
		return m.FileNumber()
	case patient.FieldStatus:
		return m.Status()
	case patient.FieldSessionCount:
		return m.SessionCount()
	case patient.FieldTotalCancellations:
		return m.TotalCancellations()
	case patient.FieldLastCancelReason:
		return m.LastCancelReason()
	case patient.FieldHasDiscount:
		return m.HasDiscount()
	case patient.FieldDiscountPercent:
		return m.DiscountPercent()
	case patient.FieldPaymentStatus:
		return m.PaymentStatus()
	case patient.FieldTotalPaid:
		return m.TotalPaid()
	case patient.FieldNotes:
		return m.Notes()
	case patient.FieldReferralSource:
		return m.ReferralSource()
	case patient.FieldChiefComplaint:
		return m.ChiefComplaint()
	case patient.FieldIsChild:
		return m.IsChild()
	case patient.FieldChildBirthDate:
		return m.ChildBirthDate()
	case patient.FieldChildSchool:
		return m.ChildSchool()
	case patient.FieldChildGrade:
		return m.ChildGrade()
	case patient.FieldParentName:
		return m.ParentName()
	case patient.FieldParentPhone:
		return m.ParentPhone()
	case patient.FieldParentRelation:
		return m.ParentRelation()
	case patient.FieldDevelopmentalHistory:
		return m.DevelopmentalHistory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patient.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case patient.FieldClinicID:
		return m.OldClinicID(ctx)
	case patient.FieldUserID:
		return m.OldUserID(ctx)
	case patient.FieldPrimaryTherapistID:
		return m.OldPrimaryTherapistID(ctx)
	case patient.FieldFileNumber:
		return m.OldFileNumber(ctx)
	case patient.FieldStatus:
		return m.OldStatus(ctx)
	case patient.FieldSessionCount:
		return m.OldSessionCount(ctx)
	case patient.FieldTotalCancellations:
		return m.OldTotalCancellations(ctx)
	case patient.FieldLastCancelReason:
		return m.OldLastCancelReason(ctx)
	case patient.FieldHasDiscount:
		return m.OldHasDiscount(ctx)
	case patient.FieldDiscountPercent:
		return m.OldDiscountPercent(ctx)
	case patient.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case patient.FieldTotalPaid:
		return m.OldTotalPaid(ctx)
	case patient.FieldNotes:
		return m.OldNotes(ctx)
	case patient.FieldReferralSource:
		return m.OldReferralSource(ctx)
	case patient.FieldChiefComplaint:
		return m.OldChiefComplaint(ctx)
	case patient.FieldIsChild:
		return m.OldIsChild(ctx)
	case patient.FieldChildBirthDate:
		return m.OldChildBirthDate(ctx)
	case patient.FieldChildSchool:
		return m.OldChildSchool(ctx)
	case patient.FieldChildGrade:
		return m.OldChildGrade(ctx)
	case patient.FieldParentName:
		return m.OldParentName(ctx)
	case patient.FieldParentPhone:
		return m.OldParentPhone(ctx)
	case patient.FieldParentRelation:
		return m.OldParentRelation(ctx)
	case patient.FieldDevelopmentalHistory:
		return m.OldDevelopmentalHistory(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patient.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case patient.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case patient.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case patient.FieldPrimaryTherapistID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryTherapistID(v)
		return nil
	case patient.FieldFileNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileNumber(v)
		return nil
	case patient.FieldStatus:
		v, ok := value.(patient.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case patient.FieldSessionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionCount(v)
		return nil
	case patient.FieldTotalCancellations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCancellations(v)
		return nil
	case patient.FieldLastCancelReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCancelReason(v)
		return nil
	case patient.FieldHasDiscount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasDiscount(v)
		return nil
	case patient.FieldDiscountPercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPercent(v)
		return nil
	case patient.FieldPaymentStatus:
		v, ok := value.(patient.PaymentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case patient.FieldTotalPaid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPaid(v)
		return nil
	case patient.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case patient.FieldReferralSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferralSource(v)
		return nil
	case patient.FieldChiefComplaint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChiefComplaint(v)
		return nil
	case patient.FieldIsChild:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChild(v)
		return nil
	case patient.FieldChildBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildBirthDate(v)
		return nil
	case patient.FieldChildSchool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildSchool(v)
		return nil
	case patient.FieldChildGrade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildGrade(v)
		return nil
	case patient.FieldParentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentName(v)
		return nil
	case patient.FieldParentPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentPhone(v)
		return nil
	case patient.FieldParentRelation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentRelation(v)
		return nil
	case patient.FieldDevelopmentalHistory:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevelopmentalHistory(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.addsession_count != nil {
		fields = append(fields, patient.FieldSessionCount)
	}
	if m.addtotal_cancellations != nil {
		fields = append(fields, patient.FieldTotalCancellations)
	}
	if m.adddiscount_percent != nil {
		fields = append(fields, patient.FieldDiscountPercent)
	}
	if m.addtotal_paid != nil {
		fields = append(fields, patient.FieldTotalPaid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldSessionCount:
		return m.AddedSessionCount()
	case patient.FieldTotalCancellations:
		return m.AddedTotalCancellations()
	case patient.FieldDiscountPercent:
		return m.AddedDiscountPercent()
	case patient.FieldTotalPaid:
		return m.AddedTotalPaid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldSessionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionCount(v)
		return nil
	case patient.FieldTotalCancellations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCancellations(v)
		return nil
	case patient.FieldDiscountPercent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPercent(v)
		return nil
	case patient.FieldTotalPaid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPaid(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patient.FieldDeletedAt) {
		fields = append(fields, patient.FieldDeletedAt)
	}
	if m.FieldCleared(patient.FieldPrimaryTherapistID) {
		fields = append(fields, patient.FieldPrimaryTherapistID)
	}
	if m.FieldCleared(patient.FieldFileNumber) {
		fields = append(fields, patient.FieldFileNumber)
	}
	if m.FieldCleared(patient.FieldLastCancelReason) {
		fields = append(fields, patient.FieldLastCancelReason)
	}
	if m.FieldCleared(patient.FieldNotes) {
		fields = append(fields, patient.FieldNotes)
	}
	if m.FieldCleared(patient.FieldReferralSource) {
		fields = append(fields, patient.FieldReferralSource)
	}
	if m.FieldCleared(patient.FieldChiefComplaint) {
		fields = append(fields, patient.FieldChiefComplaint)
	}
	if m.FieldCleared(patient.FieldChildBirthDate) {
		fields = append(fields, patient.FieldChildBirthDate)
	}
	if m.FieldCleared(patient.FieldChildSchool) {
		fields = append(fields, patient.FieldChildSchool)
	}
	if m.FieldCleared(patient.FieldChildGrade) {
		fields = append(fields, patient.FieldChildGrade)
	}
	if m.FieldCleared(patient.FieldParentName) {
		fields = append(fields, patient.FieldParentName)
	}
	if m.FieldCleared(patient.FieldParentPhone) {
		fields = append(fields, patient.FieldParentPhone)
	}
	if m.FieldCleared(patient.FieldParentRelation) {
		fields = append(fields, patient.FieldParentRelation)
	}
	if m.FieldCleared(patient.FieldDevelopmentalHistory) {
		fields = append(fields, patient.FieldDevelopmentalHistory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	switch name {
	case patient.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case patient.FieldPrimaryTherapistID:
		m.ClearPrimaryTherapistID()
		return nil
	case patient.FieldFileNumber:
		m.ClearFileNumber()
		return nil
	case patient.FieldLastCancelReason:
		m.ClearLastCancelReason()
		return nil
	case patient.FieldNotes:
		m.ClearNotes()
		return nil
	case patient.FieldReferralSource:
		m.ClearReferralSource()
		return nil
	case patient.FieldChiefComplaint:
		m.ClearChiefComplaint()
		return nil
	case patient.FieldChildBirthDate:
		m.ClearChildBirthDate()
		return nil
	case patient.FieldChildSchool:
		m.ClearChildSchool()
		return nil
	case patient.FieldChildGrade:
		m.ClearChildGrade()
		return nil
	case patient.FieldParentName:
		m.ClearParentName()
		return nil
	case patient.FieldParentPhone:
		m.ClearParentPhone()
		return nil
	case patient.FieldParentRelation:
		m.ClearParentRelation()
		return nil
	case patient.FieldDevelopmentalHistory:
		m.ClearDevelopmentalHistory()
		return nil
	}
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patient.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case patient.FieldClinicID:
		m.ResetClinicID()
		return nil
	case patient.FieldUserID:
		m.ResetUserID()
		return nil
	case patient.FieldPrimaryTherapistID:
		m.ResetPrimaryTherapistID()
		return nil
	case patient.FieldFileNumber:
		m.ResetFileNumber()
		return nil
	case patient.FieldStatus:
		m.ResetStatus()
		return nil
	case patient.FieldSessionCount:
		m.ResetSessionCount()
		return nil
	case patient.FieldTotalCancellations:
		m.ResetTotalCancellations()
		return nil
	case patient.FieldLastCancelReason:
		m.ResetLastCancelReason()
		return nil
	case patient.FieldHasDiscount:
		m.ResetHasDiscount()
		return nil
	case patient.FieldDiscountPercent:
		m.ResetDiscountPercent()
		return nil
	case patient.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case patient.FieldTotalPaid:
		m.ResetTotalPaid()
		return nil
	case patient.FieldNotes:
		m.ResetNotes()
		return nil
	case patient.FieldReferralSource:
		m.ResetReferralSource()
		return nil
	case patient.FieldChiefComplaint:
		m.ResetChiefComplaint()
		return nil
	case patient.FieldIsChild:
		m.ResetIsChild()
		return nil
	case patient.FieldChildBirthDate:
		m.ResetChildBirthDate()
		return nil
	case patient.FieldChildSchool:
		m.ResetChildSchool()
		return nil
	case patient.FieldChildGrade:
		m.ResetChildGrade()
		return nil
	case patient.FieldParentName:
		m.ResetParentName()
		return nil
	case patient.FieldParentPhone:
		m.ResetParentPhone()
		return nil
	case patient.FieldParentRelation:
		m.ResetParentRelation()
		return nil
	case patient.FieldDevelopmentalHistory:
		m.ResetDevelopmentalHistory()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clinic != nil {
		edges = append(edges, patient.EdgeClinic)
	}
	if m.user != nil {
		edges = append(edges, patient.EdgeUser)
	}
	if m.primary_therapist != nil {
		edges = append(edges, patient.EdgePrimaryTherapist)
	}
	if m.reports != nil {
		edges = append(edges, patient.EdgeReports)
	}
	if m.files != nil {
		edges = append(edges, patient.EdgeFiles)
	}
	if m.prescriptions != nil {
		edges = append(edges, patient.EdgePrescriptions)
	}
	if m.tests != nil {
		edges = append(edges, patient.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgePrimaryTherapist:
		if id := m.primary_therapist; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePrescriptions:
		ids := make([]ent.Value, 0, len(m.prescriptions))
		for id := range m.prescriptions {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedreports != nil {
		edges = append(edges, patient.EdgeReports)
	}
	if m.removedfiles != nil {
		edges = append(edges, patient.EdgeFiles)
	}
	if m.removedprescriptions != nil {
		edges = append(edges, patient.EdgePrescriptions)
	}
	if m.removedtests != nil {
		edges = append(edges, patient.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePrescriptions:
		ids := make([]ent.Value, 0, len(m.removedprescriptions))
		for id := range m.removedprescriptions {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedclinic {
		edges = append(edges, patient.EdgeClinic)
	}
	if m.cleareduser {
		edges = append(edges, patient.EdgeUser)
	}
	if m.clearedprimary_therapist {
		edges = append(edges, patient.EdgePrimaryTherapist)
	}
	if m.clearedreports {
		edges = append(edges, patient.EdgeReports)
	}
	if m.clearedfiles {
		edges = append(edges, patient.EdgeFiles)
	}
	if m.clearedprescriptions {
		edges = append(edges, patient.EdgePrescriptions)
	}
	if m.clearedtests {
		edges = append(edges, patient.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeClinic:
		return m.clearedclinic
	case patient.EdgeUser:
		return m.cleareduser
	case patient.EdgePrimaryTherapist:
		return m.clearedprimary_therapist
	case patient.EdgeReports:
		return m.clearedreports
	case patient.EdgeFiles:
		return m.clearedfiles
	case patient.EdgePrescriptions:
		return m.clearedprescriptions
	case patient.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	case patient.EdgeClinic:
		m.ClearClinic()
		return nil
	case patient.EdgeUser:
		m.ClearUser()
		return nil
	case patient.EdgePrimaryTherapist:
		m.ClearPrimaryTherapist()
		return nil
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeClinic:
		m.ResetClinic()
		return nil
	case patient.EdgeUser:
		m.ResetUser()
		return nil
	case patient.EdgePrimaryTherapist:
		m.ResetPrimaryTherapist()
		return nil
	case patient.EdgeReports:
		m.ResetReports()
		return nil
	case patient.EdgeFiles:
		m.ResetFiles()
		return nil
	case patient.EdgePrescriptions:
		m.ResetPrescriptions()
		return nil
	case patient.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PatientFileMutation represents an operation that mutates the PatientFile nodes in the graph.
type PatientFileMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	clinic_id       *uuid.UUID
	linked_type     *string
	linked_id       *uuid.UUID
	file_name       *string
	file_key        *string
	file_size       *int64
	addfile_size    *int64
	mime_type       *string
	description     *string
	clearedFields   map[string]struct{}
	patient         *uuid.UUID
	clearedpatient  bool
	uploader        *uuid.UUID
	cleareduploader bool
	done            bool
	oldValue        func(context.Context) (*PatientFile, error)
	predicates      []predicate.PatientFile
}

var _ ent.Mutation = (*PatientFileMutation)(nil)

// patientfileOption allows management of the mutation configuration using functional options.
type patientfileOption func(*PatientFileMutation)

// newPatientFileMutation creates new mutation for the PatientFile entity.
func newPatientFileMutation(c config, op Op, opts ...patientfileOption) *PatientFileMutation {
	m := &PatientFileMutation{
		config:        c,
		op:            op,
		typ:           TypePatientFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientFileID sets the ID field of the mutation.
func withPatientFileID(id uuid.UUID) patientfileOption {
	return func(m *PatientFileMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientFile
		)
		m.oldValue = func(ctx context.Context) (*PatientFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientFile sets the old PatientFile of the mutation.
func withPatientFile(node *PatientFile) patientfileOption {
	return func(m *PatientFileMutation) {
		m.oldValue = func(context.Context) (*PatientFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PatientFile entities.
func (m *PatientFileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientFileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientFileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PatientFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPatientID sets the "patient_id" field.
func (m *PatientFileMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *PatientFileMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *PatientFileMutation) ResetPatientID() {
	m.patient = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *PatientFileMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PatientFileMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PatientFileMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetUploadedBy sets the "uploaded_by" field.
func (m *PatientFileMutation) SetUploadedBy(u uuid.UUID) {
	m.uploader = &u
}

// UploadedBy returns the value of the "uploaded_by" field in the mutation.
func (m *PatientFileMutation) UploadedBy() (r uuid.UUID, exists bool) {
	v := m.uploader
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedBy returns the old "uploaded_by" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldUploadedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedBy: %w", err)
	}
	return oldValue.UploadedBy, nil
}

// ResetUploadedBy resets all changes to the "uploaded_by" field.
func (m *PatientFileMutation) ResetUploadedBy() {
	m.uploader = nil
}

// SetLinkedType sets the "linked_type" field.
func (m *PatientFileMutation) SetLinkedType(s string) {
	m.linked_type = &s
}

// LinkedType returns the value of the "linked_type" field in the mutation.
func (m *PatientFileMutation) LinkedType() (r string, exists bool) {
	v := m.linked_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedType returns the old "linked_type" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldLinkedType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedType: %w", err)
	}
	return oldValue.LinkedType, nil
}

// ClearLinkedType clears the value of the "linked_type" field.
func (m *PatientFileMutation) ClearLinkedType() {
	m.linked_type = nil
	m.clearedFields[patientfile.FieldLinkedType] = struct{}{}
}

// LinkedTypeCleared returns if the "linked_type" field was cleared in this mutation.
func (m *PatientFileMutation) LinkedTypeCleared() bool {
	_, ok := m.clearedFields[patientfile.FieldLinkedType]
	return ok
}

// ResetLinkedType resets all changes to the "linked_type" field.
func (m *PatientFileMutation) ResetLinkedType() {
	m.linked_type = nil
	delete(m.clearedFields, patientfile.FieldLinkedType)
}

// SetLinkedID sets the "linked_id" field.
func (m *PatientFileMutation) SetLinkedID(u uuid.UUID) {
	m.linked_id = &u
}

// LinkedID returns the value of the "linked_id" field in the mutation.
func (m *PatientFileMutation) LinkedID() (r uuid.UUID, exists bool) {
	v := m.linked_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedID returns the old "linked_id" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldLinkedID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedID: %w", err)
	}
	return oldValue.LinkedID, nil
}

// ClearLinkedID clears the value of the "linked_id" field.
func (m *PatientFileMutation) ClearLinkedID() {
	m.linked_id = nil
	m.clearedFields[patientfile.FieldLinkedID] = struct{}{}
}

// LinkedIDCleared returns if the "linked_id" field was cleared in this mutation.
func (m *PatientFileMutation) LinkedIDCleared() bool {
	_, ok := m.clearedFields[patientfile.FieldLinkedID]
	return ok
}

// ResetLinkedID resets all changes to the "linked_id" field.
func (m *PatientFileMutation) ResetLinkedID() {
	m.linked_id = nil
	delete(m.clearedFields, patientfile.FieldLinkedID)
}

// SetFileName sets the "file_name" field.
func (m *PatientFileMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *PatientFileMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *PatientFileMutation) ResetFileName() {
	m.file_name = nil
}

// SetFileKey sets the "file_key" field.
func (m *PatientFileMutation) SetFileKey(s string) {
	m.file_key = &s
}

// FileKey returns the value of the "file_key" field in the mutation.
func (m *PatientFileMutation) FileKey() (r string, exists bool) {
	v := m.file_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFileKey returns the old "file_key" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldFileKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileKey: %w", err)
	}
	return oldValue.FileKey, nil
}

// ResetFileKey resets all changes to the "file_key" field.
func (m *PatientFileMutation) ResetFileKey() {
	m.file_key = nil
}

// SetFileSize sets the "file_size" field.
func (m *PatientFileMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *PatientFileMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldFileSize(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *PatientFileMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *PatientFileMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *PatientFileMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[patientfile.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *PatientFileMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[patientfile.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *PatientFileMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, patientfile.FieldFileSize)
}

// SetMimeType sets the "mime_type" field.
func (m *PatientFileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *PatientFileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *PatientFileMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[patientfile.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *PatientFileMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[patientfile.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *PatientFileMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, patientfile.FieldMimeType)
}

// SetDescription sets the "description" field.
func (m *PatientFileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PatientFileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PatientFile entity.
// If the PatientFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientFileMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PatientFileMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[patientfile.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PatientFileMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[patientfile.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PatientFileMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, patientfile.FieldDescription)
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *PatientFileMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[patientfile.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *PatientFileMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PatientFileMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *PatientFileMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetUploaderID sets the "uploader" edge to the User entity by id.
func (m *PatientFileMutation) SetUploaderID(id uuid.UUID) {
	m.uploader = &id
}

// ClearUploader clears the "uploader" edge to the User entity.
func (m *PatientFileMutation) ClearUploader() {
	m.cleareduploader = true
	m.clearedFields[patientfile.FieldUploadedBy] = struct{}{}
}

// UploaderCleared reports if the "uploader" edge to the User entity was cleared.
func (m *PatientFileMutation) UploaderCleared() bool {
	return m.cleareduploader
}

// UploaderID returns the "uploader" edge ID in the mutation.
func (m *PatientFileMutation) UploaderID() (id uuid.UUID, exists bool) {
	if m.uploader != nil {
		return *m.uploader, true
	}
	return
}

// UploaderIDs returns the "uploader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploaderID instead. It exists only for internal usage by the builders.
func (m *PatientFileMutation) UploaderIDs() (ids []uuid.UUID) {
	if id := m.uploader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploader resets all changes to the "uploader" edge.
func (m *PatientFileMutation) ResetUploader() {
	m.uploader = nil
	m.cleareduploader = false
}

// Where appends a list predicates to the PatientFileMutation builder.
func (m *PatientFileMutation) Where(ps ...predicate.PatientFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PatientFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PatientFile).
func (m *PatientFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientFileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, patientfile.FieldCreatedAt)
	}
	if m.patient != nil {
		fields = append(fields, patientfile.FieldPatientID)
	}
	if m.clinic_id != nil {
		fields = append(fields, patientfile.FieldClinicID)
	}
	if m.uploader != nil {
		fields = append(fields, patientfile.FieldUploadedBy)
	}
	if m.linked_type != nil {
		fields = append(fields, patientfile.FieldLinkedType)
	}
	if m.linked_id != nil {
		fields = append(fields, patientfile.FieldLinkedID)
	}
	if m.file_name != nil {
		fields = append(fields, patientfile.FieldFileName)
	}
	if m.file_key != nil {
		fields = append(fields, patientfile.FieldFileKey)
	}
	if m.file_size != nil {
		fields = append(fields, patientfile.FieldFileSize)
	}
	if m.mime_type != nil {
		fields = append(fields, patientfile.FieldMimeType)
	}
	if m.description != nil {
		fields = append(fields, patientfile.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientfile.FieldCreatedAt:
		return m.CreatedAt()
	case patientfile.FieldPatientID:
		return m.PatientID()
	case patientfile.FieldClinicID:
		return m.ClinicID()
	case patientfile.FieldUploadedBy:
		return m.UploadedBy()
	case patientfile.FieldLinkedType:
		return m.LinkedType()
	case patientfile.FieldLinkedID:
		return m.LinkedID()
	case patientfile.FieldFileName:
		return m.FileName()
	case patientfile.FieldFileKey:
		return m.FileKey()
	case patientfile.FieldFileSize:
		return m.FileSize()
	case patientfile.FieldMimeType:
		return m.MimeType()
	case patientfile.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patientfile.FieldPatientID:
		return m.OldPatientID(ctx)
	case patientfile.FieldClinicID:
		return m.OldClinicID(ctx)
	case patientfile.FieldUploadedBy:
		return m.OldUploadedBy(ctx)
	case patientfile.FieldLinkedType:
		return m.OldLinkedType(ctx)
	case patientfile.FieldLinkedID:
		return m.OldLinkedID(ctx)
	case patientfile.FieldFileName:
		return m.OldFileName(ctx)
	case patientfile.FieldFileKey:
		return m.OldFileKey(ctx)
	case patientfile.FieldFileSize:
		return m.OldFileSize(ctx)
	case patientfile.FieldMimeType:
		return m.OldMimeType(ctx)
	case patientfile.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown PatientFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patientfile.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case patientfile.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case patientfile.FieldUploadedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedBy(v)
		return nil
	case patientfile.FieldLinkedType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedType(v)
		return nil
	case patientfile.FieldLinkedID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedID(v)
		return nil
	case patientfile.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case patientfile.FieldFileKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileKey(v)
		return nil
	case patientfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case patientfile.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case patientfile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown PatientFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientFileMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, patientfile.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patientfile.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patientfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown PatientFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patientfile.FieldLinkedType) {
		fields = append(fields, patientfile.FieldLinkedType)
	}
	if m.FieldCleared(patientfile.FieldLinkedID) {
		fields = append(fields, patientfile.FieldLinkedID)
	}
	if m.FieldCleared(patientfile.FieldFileSize) {
		fields = append(fields, patientfile.FieldFileSize)
	}
	if m.FieldCleared(patientfile.FieldMimeType) {
		fields = append(fields, patientfile.FieldMimeType)
	}
	if m.FieldCleared(patientfile.FieldDescription) {
		fields = append(fields, patientfile.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientFileMutation) ClearField(name string) error {
	switch name {
	case patientfile.FieldLinkedType:
		m.ClearLinkedType()
		return nil
	case patientfile.FieldLinkedID:
		m.ClearLinkedID()
		return nil
	case patientfile.FieldFileSize:
		m.ClearFileSize()
		return nil
	case patientfile.FieldMimeType:
		m.ClearMimeType()
		return nil
	case patientfile.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PatientFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientFileMutation) ResetField(name string) error {
	switch name {
	case patientfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patientfile.FieldPatientID:
		m.ResetPatientID()
		return nil
	case patientfile.FieldClinicID:
		m.ResetClinicID()
		return nil
	case patientfile.FieldUploadedBy:
		m.ResetUploadedBy()
		return nil
	case patientfile.FieldLinkedType:
		m.ResetLinkedType()
		return nil
	case patientfile.FieldLinkedID:
		m.ResetLinkedID()
		return nil
	case patientfile.FieldFileName:
		m.ResetFileName()
		return nil
	case patientfile.FieldFileKey:
		m.ResetFileKey()
		return nil
	case patientfile.FieldFileSize:
		m.ResetFileSize()
		return nil
	case patientfile.FieldMimeType:
		m.ResetMimeType()
		return nil
	case patientfile.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown PatientFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.patient != nil {
		edges = append(edges, patientfile.EdgePatient)
	}
	if m.uploader != nil {
		edges = append(edges, patientfile.EdgeUploader)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientfile.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case patientfile.EdgeUploader:
		if id := m.uploader; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpatient {
		edges = append(edges, patientfile.EdgePatient)
	}
	if m.cleareduploader {
		edges = append(edges, patientfile.EdgeUploader)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientFileMutation) EdgeCleared(name string) bool {
	switch name {
	case patientfile.EdgePatient:
		return m.clearedpatient
	case patientfile.EdgeUploader:
		return m.cleareduploader
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientFileMutation) ClearEdge(name string) error {
	switch name {
	case patientfile.EdgePatient:
		m.ClearPatient()
		return nil
	case patientfile.EdgeUploader:
		m.ClearUploader()
		return nil
	}
	return fmt.Errorf("unknown PatientFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientFileMutation) ResetEdge(name string) error {
	switch name {
	case patientfile.EdgePatient:
		m.ResetPatient()
		return nil
	case patientfile.EdgeUploader:
		m.ResetUploader()
		return nil
	}
	return fmt.Errorf("unknown PatientFile edge %s", name)
}

// PatientPrescriptionMutation represents an operation that mutates the PatientPrescription nodes in the graph.
type PatientPrescriptionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	clinic_id        *uuid.UUID
	title            *string
	notes            *string
	file_key         *string
	file_name        *string
	prescribed_date  *time.Time
	clearedFields    map[string]struct{}
	patient          *uuid.UUID
	clearedpatient   bool
	therapist        *uuid.UUID
	clearedtherapist bool
	done             bool
	oldValue         func(context.Context) (*PatientPrescription, error)
	predicates       []predicate.PatientPrescription
}

var _ ent.Mutation = (*PatientPrescriptionMutation)(nil)

// patientprescriptionOption allows management of the mutation configuration using functional options.
type patientprescriptionOption func(*PatientPrescriptionMutation)

// newPatientPrescriptionMutation creates new mutation for the PatientPrescription entity.
func newPatientPrescriptionMutation(c config, op Op, opts ...patientprescriptionOption) *PatientPrescriptionMutation {
	m := &PatientPrescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePatientPrescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientPrescriptionID sets the ID field of the mutation.
func withPatientPrescriptionID(id uuid.UUID) patientprescriptionOption {
	return func(m *PatientPrescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientPrescription
		)
		m.oldValue = func(ctx context.Context) (*PatientPrescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientPrescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientPrescription sets the old PatientPrescription of the mutation.
func withPatientPrescription(node *PatientPrescription) patientprescriptionOption {
	return func(m *PatientPrescriptionMutation) {
		m.oldValue = func(context.Context) (*PatientPrescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientPrescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientPrescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PatientPrescription entities.
func (m *PatientPrescriptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientPrescriptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientPrescriptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PatientPrescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientPrescriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientPrescriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientPrescriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientPrescriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientPrescriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientPrescriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPatientID sets the "patient_id" field.
func (m *PatientPrescriptionMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *PatientPrescriptionMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *PatientPrescriptionMutation) ResetPatientID() {
	m.patient = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *PatientPrescriptionMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PatientPrescriptionMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PatientPrescriptionMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetTherapistID sets the "therapist_id" field.
func (m *PatientPrescriptionMutation) SetTherapistID(u uuid.UUID) {
	m.therapist = &u
}

// TherapistID returns the value of the "therapist_id" field in the mutation.
func (m *PatientPrescriptionMutation) TherapistID() (r uuid.UUID, exists bool) {
	v := m.therapist
	if v == nil {
		return
	}
	return *v, true
}

// OldTherapistID returns the old "therapist_id" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldTherapistID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTherapistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTherapistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTherapistID: %w", err)
	}
	return oldValue.TherapistID, nil
}

// ResetTherapistID resets all changes to the "therapist_id" field.
func (m *PatientPrescriptionMutation) ResetTherapistID() {
	m.therapist = nil
}

// SetTitle sets the "title" field.
func (m *PatientPrescriptionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PatientPrescriptionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PatientPrescriptionMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[patientprescription.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PatientPrescriptionMutation) TitleCleared() bool {
	_, ok := m.clearedFields[patientprescription.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PatientPrescriptionMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, patientprescription.FieldTitle)
}

// SetNotes sets the "notes" field.
func (m *PatientPrescriptionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PatientPrescriptionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *PatientPrescriptionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[patientprescription.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PatientPrescriptionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[patientprescription.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PatientPrescriptionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, patientprescription.FieldNotes)
}

// SetFileKey sets the "file_key" field.
func (m *PatientPrescriptionMutation) SetFileKey(s string) {
	m.file_key = &s
}

// FileKey returns the value of the "file_key" field in the mutation.
func (m *PatientPrescriptionMutation) FileKey() (r string, exists bool) {
	v := m.file_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFileKey returns the old "file_key" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldFileKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileKey: %w", err)
	}
	return oldValue.FileKey, nil
}

// ClearFileKey clears the value of the "file_key" field.
func (m *PatientPrescriptionMutation) ClearFileKey() {
	m.file_key = nil
	m.clearedFields[patientprescription.FieldFileKey] = struct{}{}
}

// FileKeyCleared returns if the "file_key" field was cleared in this mutation.
func (m *PatientPrescriptionMutation) FileKeyCleared() bool {
	_, ok := m.clearedFields[patientprescription.FieldFileKey]
	return ok
}

// ResetFileKey resets all changes to the "file_key" field.
func (m *PatientPrescriptionMutation) ResetFileKey() {
	m.file_key = nil
	delete(m.clearedFields, patientprescription.FieldFileKey)
}

// SetFileName sets the "file_name" field.
func (m *PatientPrescriptionMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *PatientPrescriptionMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "file_name" field.
func (m *PatientPrescriptionMutation) ClearFileName() {
	m.file_name = nil
	m.clearedFields[patientprescription.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "file_name" field was cleared in this mutation.
func (m *PatientPrescriptionMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[patientprescription.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "file_name" field.
func (m *PatientPrescriptionMutation) ResetFileName() {
	m.file_name = nil
	delete(m.clearedFields, patientprescription.FieldFileName)
}

// SetPrescribedDate sets the "prescribed_date" field.
func (m *PatientPrescriptionMutation) SetPrescribedDate(t time.Time) {
	m.prescribed_date = &t
}

// PrescribedDate returns the value of the "prescribed_date" field in the mutation.
func (m *PatientPrescriptionMutation) PrescribedDate() (r time.Time, exists bool) {
	v := m.prescribed_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPrescribedDate returns the old "prescribed_date" field's value of the PatientPrescription entity.
// If the PatientPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientPrescriptionMutation) OldPrescribedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrescribedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrescribedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrescribedDate: %w", err)
	}
	return oldValue.PrescribedDate, nil
}

// ResetPrescribedDate resets all changes to the "prescribed_date" field.
func (m *PatientPrescriptionMutation) ResetPrescribedDate() {
	m.prescribed_date = nil
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *PatientPrescriptionMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[patientprescription.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *PatientPrescriptionMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PatientPrescriptionMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *PatientPrescriptionMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// ClearTherapist clears the "therapist" edge to the ClinicMember entity.
func (m *PatientPrescriptionMutation) ClearTherapist() {
	m.clearedtherapist = true
	m.clearedFields[patientprescription.FieldTherapistID] = struct{}{}
}

// TherapistCleared reports if the "therapist" edge to the ClinicMember entity was cleared.
func (m *PatientPrescriptionMutation) TherapistCleared() bool {
	return m.clearedtherapist
}

// TherapistIDs returns the "therapist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TherapistID instead. It exists only for internal usage by the builders.
func (m *PatientPrescriptionMutation) TherapistIDs() (ids []uuid.UUID) {
	if id := m.therapist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTherapist resets all changes to the "therapist" edge.
func (m *PatientPrescriptionMutation) ResetTherapist() {
	m.therapist = nil
	m.clearedtherapist = false
}

// Where appends a list predicates to the PatientPrescriptionMutation builder.
func (m *PatientPrescriptionMutation) Where(ps ...predicate.PatientPrescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientPrescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientPrescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PatientPrescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientPrescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientPrescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PatientPrescription).
func (m *PatientPrescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientPrescriptionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, patientprescription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patientprescription.FieldUpdatedAt)
	}
	if m.patient != nil {
		fields = append(fields, patientprescription.FieldPatientID)
	}
	if m.clinic_id != nil {
		fields = append(fields, patientprescription.FieldClinicID)
	}
	if m.therapist != nil {
		fields = append(fields, patientprescription.FieldTherapistID)
	}
	if m.title != nil {
		fields = append(fields, patientprescription.FieldTitle)
	}
	if m.notes != nil {
		fields = append(fields, patientprescription.FieldNotes)
	}
	if m.file_key != nil {
		fields = append(fields, patientprescription.FieldFileKey)
	}
	if m.file_name != nil {
		fields = append(fields, patientprescription.FieldFileName)
	}
	if m.prescribed_date != nil {
		fields = append(fields, patientprescription.FieldPrescribedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientPrescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientprescription.FieldCreatedAt:
		return m.CreatedAt()
	case patientprescription.FieldUpdatedAt:
		return m.UpdatedAt()
	case patientprescription.FieldPatientID:
		return m.PatientID()
	case patientprescription.FieldClinicID:
		return m.ClinicID()
	case patientprescription.FieldTherapistID:
		return m.TherapistID()
	case patientprescription.FieldTitle:
		return m.Title()
	case patientprescription.FieldNotes:
		return m.Notes()
	case patientprescription.FieldFileKey:
		return m.FileKey()
	case patientprescription.FieldFileName:
		return m.FileName()
	case patientprescription.FieldPrescribedDate:
		return m.PrescribedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientPrescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientprescription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patientprescription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patientprescription.FieldPatientID:
		return m.OldPatientID(ctx)
	case patientprescription.FieldClinicID:
		return m.OldClinicID(ctx)
	case patientprescription.FieldTherapistID:
		return m.OldTherapistID(ctx)
	case patientprescription.FieldTitle:
		return m.OldTitle(ctx)
	case patientprescription.FieldNotes:
		return m.OldNotes(ctx)
	case patientprescription.FieldFileKey:
		return m.OldFileKey(ctx)
	case patientprescription.FieldFileName:
		return m.OldFileName(ctx)
	case patientprescription.FieldPrescribedDate:
		return m.OldPrescribedDate(ctx)
	}
	return nil, fmt.Errorf("unknown PatientPrescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientPrescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientprescription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patientprescription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patientprescription.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case patientprescription.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case patientprescription.FieldTherapistID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTherapistID(v)
		return nil
	case patientprescription.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case patientprescription.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case patientprescription.FieldFileKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileKey(v)
		return nil
	case patientprescription.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case patientprescription.FieldPrescribedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrescribedDate(v)
		return nil
	}
	return fmt.Errorf("unknown PatientPrescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientPrescriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientPrescriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientPrescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PatientPrescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientPrescriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patientprescription.FieldTitle) {
		fields = append(fields, patientprescription.FieldTitle)
	}
	if m.FieldCleared(patientprescription.FieldNotes) {
		fields = append(fields, patientprescription.FieldNotes)
	}
	if m.FieldCleared(patientprescription.FieldFileKey) {
		fields = append(fields, patientprescription.FieldFileKey)
	}
	if m.FieldCleared(patientprescription.FieldFileName) {
		fields = append(fields, patientprescription.FieldFileName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientPrescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientPrescriptionMutation) ClearField(name string) error {
	switch name {
	case patientprescription.FieldTitle:
		m.ClearTitle()
		return nil
	case patientprescription.FieldNotes:
		m.ClearNotes()
		return nil
	case patientprescription.FieldFileKey:
		m.ClearFileKey()
		return nil
	case patientprescription.FieldFileName:
		m.ClearFileName()
		return nil
	}
	return fmt.Errorf("unknown PatientPrescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientPrescriptionMutation) ResetField(name string) error {
	switch name {
	case patientprescription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patientprescription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patientprescription.FieldPatientID:
		m.ResetPatientID()
		return nil
	case patientprescription.FieldClinicID:
		m.ResetClinicID()
		return nil
	case patientprescription.FieldTherapistID:
		m.ResetTherapistID()
		return nil
	case patientprescription.FieldTitle:
		m.ResetTitle()
		return nil
	case patientprescription.FieldNotes:
		m.ResetNotes()
		return nil
	case patientprescription.FieldFileKey:
		m.ResetFileKey()
		return nil
	case patientprescription.FieldFileName:
		m.ResetFileName()
		return nil
	case patientprescription.FieldPrescribedDate:
		m.ResetPrescribedDate()
		return nil
	}
	return fmt.Errorf("unknown PatientPrescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientPrescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.patient != nil {
		edges = append(edges, patientprescription.EdgePatient)
	}
	if m.therapist != nil {
		edges = append(edges, patientprescription.EdgeTherapist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientPrescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientprescription.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case patientprescription.EdgeTherapist:
		if id := m.therapist; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientPrescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientPrescriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientPrescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpatient {
		edges = append(edges, patientprescription.EdgePatient)
	}
	if m.clearedtherapist {
		edges = append(edges, patientprescription.EdgeTherapist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientPrescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case patientprescription.EdgePatient:
		return m.clearedpatient
	case patientprescription.EdgeTherapist:
		return m.clearedtherapist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientPrescriptionMutation) ClearEdge(name string) error {
	switch name {
	case patientprescription.EdgePatient:
		m.ClearPatient()
		return nil
	case patientprescription.EdgeTherapist:
		m.ClearTherapist()
		return nil
	}
	return fmt.Errorf("unknown PatientPrescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientPrescriptionMutation) ResetEdge(name string) error {
	switch name {
	case patientprescription.EdgePatient:
		m.ResetPatient()
		return nil
	case patientprescription.EdgeTherapist:
		m.ResetTherapist()
		return nil
	}
	return fmt.Errorf("unknown PatientPrescription edge %s", name)
}

// PatientReportMutation represents an operation that mutates the PatientReport nodes in the graph.
type PatientReportMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	clinic_id        *uuid.UUID
	appointment_id   *uuid.UUID
	title            *string
	content          *string
	report_date      *time.Time
	clearedFields    map[string]struct{}
	patient          *uuid.UUID
	clearedpatient   bool
	therapist        *uuid.UUID
	clearedtherapist bool
	done             bool
	oldValue         func(context.Context) (*PatientReport, error)
	predicates       []predicate.PatientReport
}

var _ ent.Mutation = (*PatientReportMutation)(nil)

// patientreportOption allows management of the mutation configuration using functional options.
type patientreportOption func(*PatientReportMutation)

// newPatientReportMutation creates new mutation for the PatientReport entity.
func newPatientReportMutation(c config, op Op, opts ...patientreportOption) *PatientReportMutation {
	m := &PatientReportMutation{
		config:        c,
		op:            op,
		typ:           TypePatientReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientReportID sets the ID field of the mutation.
func withPatientReportID(id uuid.UUID) patientreportOption {
	return func(m *PatientReportMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientReport
		)
		m.oldValue = func(ctx context.Context) (*PatientReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientReport sets the old PatientReport of the mutation.
func withPatientReport(node *PatientReport) patientreportOption {
	return func(m *PatientReportMutation) {
		m.oldValue = func(context.Context) (*PatientReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PatientReport entities.
func (m *PatientReportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientReportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientReportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PatientReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPatientID sets the "patient_id" field.
func (m *PatientReportMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *PatientReportMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *PatientReportMutation) ResetPatientID() {
	m.patient = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *PatientReportMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PatientReportMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PatientReportMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetTherapistID sets the "therapist_id" field.
func (m *PatientReportMutation) SetTherapistID(u uuid.UUID) {
	m.therapist = &u
}

// TherapistID returns the value of the "therapist_id" field in the mutation.
func (m *PatientReportMutation) TherapistID() (r uuid.UUID, exists bool) {
	v := m.therapist
	if v == nil {
		return
	}
	return *v, true
}

// OldTherapistID returns the old "therapist_id" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldTherapistID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTherapistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTherapistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTherapistID: %w", err)
	}
	return oldValue.TherapistID, nil
}

// ResetTherapistID resets all changes to the "therapist_id" field.
func (m *PatientReportMutation) ResetTherapistID() {
	m.therapist = nil
}

// SetAppointmentID sets the "appointment_id" field.
func (m *PatientReportMutation) SetAppointmentID(u uuid.UUID) {
	m.appointment_id = &u
}

// AppointmentID returns the value of the "appointment_id" field in the mutation.
func (m *PatientReportMutation) AppointmentID() (r uuid.UUID, exists bool) {
	v := m.appointment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentID returns the old "appointment_id" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldAppointmentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentID: %w", err)
	}
	return oldValue.AppointmentID, nil
}

// ClearAppointmentID clears the value of the "appointment_id" field.
func (m *PatientReportMutation) ClearAppointmentID() {
	m.appointment_id = nil
	m.clearedFields[patientreport.FieldAppointmentID] = struct{}{}
}

// AppointmentIDCleared returns if the "appointment_id" field was cleared in this mutation.
func (m *PatientReportMutation) AppointmentIDCleared() bool {
	_, ok := m.clearedFields[patientreport.FieldAppointmentID]
	return ok
}

// ResetAppointmentID resets all changes to the "appointment_id" field.
func (m *PatientReportMutation) ResetAppointmentID() {
	m.appointment_id = nil
	delete(m.clearedFields, patientreport.FieldAppointmentID)
}

// SetTitle sets the "title" field.
func (m *PatientReportMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PatientReportMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PatientReportMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[patientreport.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PatientReportMutation) TitleCleared() bool {
	_, ok := m.clearedFields[patientreport.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PatientReportMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, patientreport.FieldTitle)
}

// SetContent sets the "content" field.
func (m *PatientReportMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PatientReportMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PatientReportMutation) ClearContent() {
	m.content = nil
	m.clearedFields[patientreport.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PatientReportMutation) ContentCleared() bool {
	_, ok := m.clearedFields[patientreport.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PatientReportMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, patientreport.FieldContent)
}

// SetReportDate sets the "report_date" field.
func (m *PatientReportMutation) SetReportDate(t time.Time) {
	m.report_date = &t
}

// ReportDate returns the value of the "report_date" field in the mutation.
func (m *PatientReportMutation) ReportDate() (r time.Time, exists bool) {
	v := m.report_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "report_date" field's value of the PatientReport entity.
// If the PatientReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientReportMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "report_date" field.
func (m *PatientReportMutation) ResetReportDate() {
	m.report_date = nil
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *PatientReportMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[patientreport.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *PatientReportMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PatientReportMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *PatientReportMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// ClearTherapist clears the "therapist" edge to the ClinicMember entity.
func (m *PatientReportMutation) ClearTherapist() {
	m.clearedtherapist = true
	m.clearedFields[patientreport.FieldTherapistID] = struct{}{}
}

// TherapistCleared reports if the "therapist" edge to the ClinicMember entity was cleared.
func (m *PatientReportMutation) TherapistCleared() bool {
	return m.clearedtherapist
}

// TherapistIDs returns the "therapist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TherapistID instead. It exists only for internal usage by the builders.
func (m *PatientReportMutation) TherapistIDs() (ids []uuid.UUID) {
	if id := m.therapist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTherapist resets all changes to the "therapist" edge.
func (m *PatientReportMutation) ResetTherapist() {
	m.therapist = nil
	m.clearedtherapist = false
}

// Where appends a list predicates to the PatientReportMutation builder.
func (m *PatientReportMutation) Where(ps ...predicate.PatientReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PatientReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PatientReport).
func (m *PatientReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientReportMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, patientreport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patientreport.FieldUpdatedAt)
	}
	if m.patient != nil {
		fields = append(fields, patientreport.FieldPatientID)
	}
	if m.clinic_id != nil {
		fields = append(fields, patientreport.FieldClinicID)
	}
	if m.therapist != nil {
		fields = append(fields, patientreport.FieldTherapistID)
	}
	if m.appointment_id != nil {
		fields = append(fields, patientreport.FieldAppointmentID)
	}
	if m.title != nil {
		fields = append(fields, patientreport.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, patientreport.FieldContent)
	}
	if m.report_date != nil {
		fields = append(fields, patientreport.FieldReportDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientreport.FieldCreatedAt:
		return m.CreatedAt()
	case patientreport.FieldUpdatedAt:
		return m.UpdatedAt()
	case patientreport.FieldPatientID:
		return m.PatientID()
	case patientreport.FieldClinicID:
		return m.ClinicID()
	case patientreport.FieldTherapistID:
		return m.TherapistID()
	case patientreport.FieldAppointmentID:
		return m.AppointmentID()
	case patientreport.FieldTitle:
		return m.Title()
	case patientreport.FieldContent:
		return m.Content()
	case patientreport.FieldReportDate:
		return m.ReportDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patientreport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patientreport.FieldPatientID:
		return m.OldPatientID(ctx)
	case patientreport.FieldClinicID:
		return m.OldClinicID(ctx)
	case patientreport.FieldTherapistID:
		return m.OldTherapistID(ctx)
	case patientreport.FieldAppointmentID:
		return m.OldAppointmentID(ctx)
	case patientreport.FieldTitle:
		return m.OldTitle(ctx)
	case patientreport.FieldContent:
		return m.OldContent(ctx)
	case patientreport.FieldReportDate:
		return m.OldReportDate(ctx)
	}
	return nil, fmt.Errorf("unknown PatientReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patientreport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patientreport.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case patientreport.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case patientreport.FieldTherapistID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTherapistID(v)
		return nil
	case patientreport.FieldAppointmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentID(v)
		return nil
	case patientreport.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case patientreport.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case patientreport.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	}
	return fmt.Errorf("unknown PatientReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PatientReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patientreport.FieldAppointmentID) {
		fields = append(fields, patientreport.FieldAppointmentID)
	}
	if m.FieldCleared(patientreport.FieldTitle) {
		fields = append(fields, patientreport.FieldTitle)
	}
	if m.FieldCleared(patientreport.FieldContent) {
		fields = append(fields, patientreport.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientReportMutation) ClearField(name string) error {
	switch name {
	case patientreport.FieldAppointmentID:
		m.ClearAppointmentID()
		return nil
	case patientreport.FieldTitle:
		m.ClearTitle()
		return nil
	case patientreport.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown PatientReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientReportMutation) ResetField(name string) error {
	switch name {
	case patientreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patientreport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patientreport.FieldPatientID:
		m.ResetPatientID()
		return nil
	case patientreport.FieldClinicID:
		m.ResetClinicID()
		return nil
	case patientreport.FieldTherapistID:
		m.ResetTherapistID()
		return nil
	case patientreport.FieldAppointmentID:
		m.ResetAppointmentID()
		return nil
	case patientreport.FieldTitle:
		m.ResetTitle()
		return nil
	case patientreport.FieldContent:
		m.ResetContent()
		return nil
	case patientreport.FieldReportDate:
		m.ResetReportDate()
		return nil
	}
	return fmt.Errorf("unknown PatientReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.patient != nil {
		edges = append(edges, patientreport.EdgePatient)
	}
	if m.therapist != nil {
		edges = append(edges, patientreport.EdgeTherapist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientreport.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case patientreport.EdgeTherapist:
		if id := m.therapist; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpatient {
		edges = append(edges, patientreport.EdgePatient)
	}
	if m.clearedtherapist {
		edges = append(edges, patientreport.EdgeTherapist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientReportMutation) EdgeCleared(name string) bool {
	switch name {
	case patientreport.EdgePatient:
		return m.clearedpatient
	case patientreport.EdgeTherapist:
		return m.clearedtherapist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientReportMutation) ClearEdge(name string) error {
	switch name {
	case patientreport.EdgePatient:
		m.ClearPatient()
		return nil
	case patientreport.EdgeTherapist:
		m.ClearTherapist()
		return nil
	}
	return fmt.Errorf("unknown PatientReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientReportMutation) ResetEdge(name string) error {
	switch name {
	case patientreport.EdgePatient:
		m.ResetPatient()
		return nil
	case patientreport.EdgeTherapist:
		m.ResetTherapist()
		return nil
	}
	return fmt.Errorf("unknown PatientReport edge %s", name)
}

// PatientTestMutation represents an operation that mutates the PatientTest nodes in the graph.
type PatientTestMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	clinic_id            *uuid.UUID
	test_name            *string
	raw_scores           *map[string]interface{}
	computed_scores      *map[string]interface{}
	interpretation       *string
	test_date            *time.Time
	status               *patienttest.Status
	clearedFields        map[string]struct{}
	patient              *uuid.UUID
	clearedpatient       bool
	psych_test           *uuid.UUID
	clearedpsych_test    bool
	administrator        *uuid.UUID
	clearedadministrator bool
	done                 bool
	oldValue             func(context.Context) (*PatientTest, error)
	predicates           []predicate.PatientTest
}

var _ ent.Mutation = (*PatientTestMutation)(nil)

// patienttestOption allows management of the mutation configuration using functional options.
type patienttestOption func(*PatientTestMutation)

// newPatientTestMutation creates new mutation for the PatientTest entity.
func newPatientTestMutation(c config, op Op, opts ...patienttestOption) *PatientTestMutation {
	m := &PatientTestMutation{
		config:        c,
		op:            op,
		typ:           TypePatientTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientTestID sets the ID field of the mutation.
func withPatientTestID(id uuid.UUID) patienttestOption {
	return func(m *PatientTestMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientTest
		)
		m.oldValue = func(ctx context.Context) (*PatientTest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientTest sets the old PatientTest of the mutation.
func withPatientTest(node *PatientTest) patienttestOption {
	return func(m *PatientTestMutation) {
		m.oldValue = func(context.Context) (*PatientTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PatientTest entities.
func (m *PatientTestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientTestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientTestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PatientTest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientTestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientTestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientTestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientTestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientTestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientTestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPatientID sets the "patient_id" field.
func (m *PatientTestMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *PatientTestMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *PatientTestMutation) ResetPatientID() {
	m.patient = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *PatientTestMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PatientTestMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PatientTestMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetTestID sets the "test_id" field.
func (m *PatientTestMutation) SetTestID(u uuid.UUID) {
	m.psych_test = &u
}

// TestID returns the value of the "test_id" field in the mutation.
func (m *PatientTestMutation) TestID() (r uuid.UUID, exists bool) {
	v := m.psych_test
	if v == nil {
		return
	}
	return *v, true
}

// OldTestID returns the old "test_id" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldTestID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestID: %w", err)
	}
	return oldValue.TestID, nil
}

// ClearTestID clears the value of the "test_id" field.
func (m *PatientTestMutation) ClearTestID() {
	m.psych_test = nil
	m.clearedFields[patienttest.FieldTestID] = struct{}{}
}

// TestIDCleared returns if the "test_id" field was cleared in this mutation.
func (m *PatientTestMutation) TestIDCleared() bool {
	_, ok := m.clearedFields[patienttest.FieldTestID]
	return ok
}

// ResetTestID resets all changes to the "test_id" field.
func (m *PatientTestMutation) ResetTestID() {
	m.psych_test = nil
	delete(m.clearedFields, patienttest.FieldTestID)
}

// SetAdministeredBy sets the "administered_by" field.
func (m *PatientTestMutation) SetAdministeredBy(u uuid.UUID) {
	m.administrator = &u
}

// AdministeredBy returns the value of the "administered_by" field in the mutation.
func (m *PatientTestMutation) AdministeredBy() (r uuid.UUID, exists bool) {
	v := m.administrator
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministeredBy returns the old "administered_by" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldAdministeredBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministeredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministeredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministeredBy: %w", err)
	}
	return oldValue.AdministeredBy, nil
}

// ClearAdministeredBy clears the value of the "administered_by" field.
func (m *PatientTestMutation) ClearAdministeredBy() {
	m.administrator = nil
	m.clearedFields[patienttest.FieldAdministeredBy] = struct{}{}
}

// AdministeredByCleared returns if the "administered_by" field was cleared in this mutation.
func (m *PatientTestMutation) AdministeredByCleared() bool {
	_, ok := m.clearedFields[patienttest.FieldAdministeredBy]
	return ok
}

// ResetAdministeredBy resets all changes to the "administered_by" field.
func (m *PatientTestMutation) ResetAdministeredBy() {
	m.administrator = nil
	delete(m.clearedFields, patienttest.FieldAdministeredBy)
}

// SetTestName sets the "test_name" field.
func (m *PatientTestMutation) SetTestName(s string) {
	m.test_name = &s
}

// TestName returns the value of the "test_name" field in the mutation.
func (m *PatientTestMutation) TestName() (r string, exists bool) {
	v := m.test_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTestName returns the old "test_name" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldTestName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestName: %w", err)
	}
	return oldValue.TestName, nil
}

// ClearTestName clears the value of the "test_name" field.
func (m *PatientTestMutation) ClearTestName() {
	m.test_name = nil
	m.clearedFields[patienttest.FieldTestName] = struct{}{}
}

// TestNameCleared returns if the "test_name" field was cleared in this mutation.
func (m *PatientTestMutation) TestNameCleared() bool {
	_, ok := m.clearedFields[patienttest.FieldTestName]
	return ok
}

// ResetTestName resets all changes to the "test_name" field.
func (m *PatientTestMutation) ResetTestName() {
	m.test_name = nil
	delete(m.clearedFields, patienttest.FieldTestName)
}

// SetRawScores sets the "raw_scores" field.
func (m *PatientTestMutation) SetRawScores(value map[string]interface{}) {
	m.raw_scores = &value
}

// RawScores returns the value of the "raw_scores" field in the mutation.
func (m *PatientTestMutation) RawScores() (r map[string]interface{}, exists bool) {
	v := m.raw_scores
	if v == nil {
		return
	}
	return *v, true
}

// OldRawScores returns the old "raw_scores" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldRawScores(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawScores: %w", err)
	}
	return oldValue.RawScores, nil
}

// ClearRawScores clears the value of the "raw_scores" field.
func (m *PatientTestMutation) ClearRawScores() {
	m.raw_scores = nil
	m.clearedFields[patienttest.FieldRawScores] = struct{}{}
}

// RawScoresCleared returns if the "raw_scores" field was cleared in this mutation.
func (m *PatientTestMutation) RawScoresCleared() bool {
	_, ok := m.clearedFields[patienttest.FieldRawScores]
	return ok
}

// ResetRawScores resets all changes to the "raw_scores" field.
func (m *PatientTestMutation) ResetRawScores() {
	m.raw_scores = nil
	delete(m.clearedFields, patienttest.FieldRawScores)
}

// SetComputedScores sets the "computed_scores" field.
func (m *PatientTestMutation) SetComputedScores(value map[string]interface{}) {
	m.computed_scores = &value
}

// ComputedScores returns the value of the "computed_scores" field in the mutation.
func (m *PatientTestMutation) ComputedScores() (r map[string]interface{}, exists bool) {
	v := m.computed_scores
	if v == nil {
		return
	}
	return *v, true
}

// OldComputedScores returns the old "computed_scores" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldComputedScores(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComputedScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComputedScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComputedScores: %w", err)
	}
	return oldValue.ComputedScores, nil
}

// ClearComputedScores clears the value of the "computed_scores" field.
func (m *PatientTestMutation) ClearComputedScores() {
	m.computed_scores = nil
	m.clearedFields[patienttest.FieldComputedScores] = struct{}{}
}

// ComputedScoresCleared returns if the "computed_scores" field was cleared in this mutation.
func (m *PatientTestMutation) ComputedScoresCleared() bool {
	_, ok := m.clearedFields[patienttest.FieldComputedScores]
	return ok
}

// ResetComputedScores resets all changes to the "computed_scores" field.
func (m *PatientTestMutation) ResetComputedScores() {
	m.computed_scores = nil
	delete(m.clearedFields, patienttest.FieldComputedScores)
}

// SetInterpretation sets the "interpretation" field.
func (m *PatientTestMutation) SetInterpretation(s string) {
	m.interpretation = &s
}

// Interpretation returns the value of the "interpretation" field in the mutation.
func (m *PatientTestMutation) Interpretation() (r string, exists bool) {
	v := m.interpretation
	if v == nil {
		return
	}
	return *v, true
}

// OldInterpretation returns the old "interpretation" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldInterpretation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterpretation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterpretation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterpretation: %w", err)
	}
	return oldValue.Interpretation, nil
}

// ClearInterpretation clears the value of the "interpretation" field.
func (m *PatientTestMutation) ClearInterpretation() {
	m.interpretation = nil
	m.clearedFields[patienttest.FieldInterpretation] = struct{}{}
}

// InterpretationCleared returns if the "interpretation" field was cleared in this mutation.
func (m *PatientTestMutation) InterpretationCleared() bool {
	_, ok := m.clearedFields[patienttest.FieldInterpretation]
	return ok
}

// ResetInterpretation resets all changes to the "interpretation" field.
func (m *PatientTestMutation) ResetInterpretation() {
	m.interpretation = nil
	delete(m.clearedFields, patienttest.FieldInterpretation)
}

// SetTestDate sets the "test_date" field.
func (m *PatientTestMutation) SetTestDate(t time.Time) {
	m.test_date = &t
}

// TestDate returns the value of the "test_date" field in the mutation.
func (m *PatientTestMutation) TestDate() (r time.Time, exists bool) {
	v := m.test_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTestDate returns the old "test_date" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldTestDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestDate: %w", err)
	}
	return oldValue.TestDate, nil
}

// ResetTestDate resets all changes to the "test_date" field.
func (m *PatientTestMutation) ResetTestDate() {
	m.test_date = nil
}

// SetStatus sets the "status" field.
func (m *PatientTestMutation) SetStatus(pa patienttest.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PatientTestMutation) Status() (r patienttest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PatientTest entity.
// If the PatientTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientTestMutation) OldStatus(ctx context.Context) (v patienttest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PatientTestMutation) ResetStatus() {
	m.status = nil
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *PatientTestMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[patienttest.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *PatientTestMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PatientTestMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *PatientTestMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetPsychTestID sets the "psych_test" edge to the PsychTest entity by id.
func (m *PatientTestMutation) SetPsychTestID(id uuid.UUID) {
	m.psych_test = &id
}

// ClearPsychTest clears the "psych_test" edge to the PsychTest entity.
func (m *PatientTestMutation) ClearPsychTest() {
	m.clearedpsych_test = true
	m.clearedFields[patienttest.FieldTestID] = struct{}{}
}

// PsychTestCleared reports if the "psych_test" edge to the PsychTest entity was cleared.
func (m *PatientTestMutation) PsychTestCleared() bool {
	return m.TestIDCleared() || m.clearedpsych_test
}

// PsychTestID returns the "psych_test" edge ID in the mutation.
func (m *PatientTestMutation) PsychTestID() (id uuid.UUID, exists bool) {
	if m.psych_test != nil {
		return *m.psych_test, true
	}
	return
}

// PsychTestIDs returns the "psych_test" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PsychTestID instead. It exists only for internal usage by the builders.
func (m *PatientTestMutation) PsychTestIDs() (ids []uuid.UUID) {
	if id := m.psych_test; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPsychTest resets all changes to the "psych_test" edge.
func (m *PatientTestMutation) ResetPsychTest() {
	m.psych_test = nil
	m.clearedpsych_test = false
}

// SetAdministratorID sets the "administrator" edge to the ClinicMember entity by id.
func (m *PatientTestMutation) SetAdministratorID(id uuid.UUID) {
	m.administrator = &id
}

// ClearAdministrator clears the "administrator" edge to the ClinicMember entity.
func (m *PatientTestMutation) ClearAdministrator() {
	m.clearedadministrator = true
	m.clearedFields[patienttest.FieldAdministeredBy] = struct{}{}
}

// AdministratorCleared reports if the "administrator" edge to the ClinicMember entity was cleared.
func (m *PatientTestMutation) AdministratorCleared() bool {
	return m.AdministeredByCleared() || m.clearedadministrator
}

// AdministratorID returns the "administrator" edge ID in the mutation.
func (m *PatientTestMutation) AdministratorID() (id uuid.UUID, exists bool) {
	if m.administrator != nil {
		return *m.administrator, true
	}
	return
}

// AdministratorIDs returns the "administrator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdministratorID instead. It exists only for internal usage by the builders.
func (m *PatientTestMutation) AdministratorIDs() (ids []uuid.UUID) {
	if id := m.administrator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdministrator resets all changes to the "administrator" edge.
func (m *PatientTestMutation) ResetAdministrator() {
	m.administrator = nil
	m.clearedadministrator = false
}

// Where appends a list predicates to the PatientTestMutation builder.
func (m *PatientTestMutation) Where(ps ...predicate.PatientTest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientTestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientTestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PatientTest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientTestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientTestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PatientTest).
func (m *PatientTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientTestMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, patienttest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patienttest.FieldUpdatedAt)
	}
	if m.patient != nil {
		fields = append(fields, patienttest.FieldPatientID)
	}
	if m.clinic_id != nil {
		fields = append(fields, patienttest.FieldClinicID)
	}
	if m.psych_test != nil {
		fields = append(fields, patienttest.FieldTestID)
	}
	if m.administrator != nil {
		fields = append(fields, patienttest.FieldAdministeredBy)
	}
	if m.test_name != nil {
		fields = append(fields, patienttest.FieldTestName)
	}
	if m.raw_scores != nil {
		fields = append(fields, patienttest.FieldRawScores)
	}
	if m.computed_scores != nil {
		fields = append(fields, patienttest.FieldComputedScores)
	}
	if m.interpretation != nil {
		fields = append(fields, patienttest.FieldInterpretation)
	}
	if m.test_date != nil {
		fields = append(fields, patienttest.FieldTestDate)
	}
	if m.status != nil {
		fields = append(fields, patienttest.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patienttest.FieldCreatedAt:
		return m.CreatedAt()
	case patienttest.FieldUpdatedAt:
		return m.UpdatedAt()
	case patienttest.FieldPatientID:
		return m.PatientID()
	case patienttest.FieldClinicID:
		return m.ClinicID()
	case patienttest.FieldTestID:
		return m.TestID()
	case patienttest.FieldAdministeredBy:
		return m.AdministeredBy()
	case patienttest.FieldTestName:
		return m.TestName()
	case patienttest.FieldRawScores:
		return m.RawScores()
	case patienttest.FieldComputedScores:
		return m.ComputedScores()
	case patienttest.FieldInterpretation:
		return m.Interpretation()
	case patienttest.FieldTestDate:
		return m.TestDate()
	case patienttest.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patienttest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patienttest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patienttest.FieldPatientID:
		return m.OldPatientID(ctx)
	case patienttest.FieldClinicID:
		return m.OldClinicID(ctx)
	case patienttest.FieldTestID:
		return m.OldTestID(ctx)
	case patienttest.FieldAdministeredBy:
		return m.OldAdministeredBy(ctx)
	case patienttest.FieldTestName:
		return m.OldTestName(ctx)
	case patienttest.FieldRawScores:
		return m.OldRawScores(ctx)
	case patienttest.FieldComputedScores:
		return m.OldComputedScores(ctx)
	case patienttest.FieldInterpretation:
		return m.OldInterpretation(ctx)
	case patienttest.FieldTestDate:
		return m.OldTestDate(ctx)
	case patienttest.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PatientTest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patienttest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patienttest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patienttest.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case patienttest.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case patienttest.FieldTestID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestID(v)
		return nil
	case patienttest.FieldAdministeredBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministeredBy(v)
		return nil
	case patienttest.FieldTestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestName(v)
		return nil
	case patienttest.FieldRawScores:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawScores(v)
		return nil
	case patienttest.FieldComputedScores:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComputedScores(v)
		return nil
	case patienttest.FieldInterpretation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterpretation(v)
		return nil
	case patienttest.FieldTestDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestDate(v)
		return nil
	case patienttest.FieldStatus:
		v, ok := value.(patienttest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PatientTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientTestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientTestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PatientTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientTestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patienttest.FieldTestID) {
		fields = append(fields, patienttest.FieldTestID)
	}
	if m.FieldCleared(patienttest.FieldAdministeredBy) {
		fields = append(fields, patienttest.FieldAdministeredBy)
	}
	if m.FieldCleared(patienttest.FieldTestName) {
		fields = append(fields, patienttest.FieldTestName)
	}
	if m.FieldCleared(patienttest.FieldRawScores) {
		fields = append(fields, patienttest.FieldRawScores)
	}
	if m.FieldCleared(patienttest.FieldComputedScores) {
		fields = append(fields, patienttest.FieldComputedScores)
	}
	if m.FieldCleared(patienttest.FieldInterpretation) {
		fields = append(fields, patienttest.FieldInterpretation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientTestMutation) ClearField(name string) error {
	switch name {
	case patienttest.FieldTestID:
		m.ClearTestID()
		return nil
	case patienttest.FieldAdministeredBy:
		m.ClearAdministeredBy()
		return nil
	case patienttest.FieldTestName:
		m.ClearTestName()
		return nil
	case patienttest.FieldRawScores:
		m.ClearRawScores()
		return nil
	case patienttest.FieldComputedScores:
		m.ClearComputedScores()
		return nil
	case patienttest.FieldInterpretation:
		m.ClearInterpretation()
		return nil
	}
	return fmt.Errorf("unknown PatientTest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientTestMutation) ResetField(name string) error {
	switch name {
	case patienttest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patienttest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patienttest.FieldPatientID:
		m.ResetPatientID()
		return nil
	case patienttest.FieldClinicID:
		m.ResetClinicID()
		return nil
	case patienttest.FieldTestID:
		m.ResetTestID()
		return nil
	case patienttest.FieldAdministeredBy:
		m.ResetAdministeredBy()
		return nil
	case patienttest.FieldTestName:
		m.ResetTestName()
		return nil
	case patienttest.FieldRawScores:
		m.ResetRawScores()
		return nil
	case patienttest.FieldComputedScores:
		m.ResetComputedScores()
		return nil
	case patienttest.FieldInterpretation:
		m.ResetInterpretation()
		return nil
	case patienttest.FieldTestDate:
		m.ResetTestDate()
		return nil
	case patienttest.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PatientTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.patient != nil {
		edges = append(edges, patienttest.EdgePatient)
	}
	if m.psych_test != nil {
		edges = append(edges, patienttest.EdgePsychTest)
	}
	if m.administrator != nil {
		edges = append(edges, patienttest.EdgeAdministrator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientTestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patienttest.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case patienttest.EdgePsychTest:
		if id := m.psych_test; id != nil {
			return []ent.Value{*id}
		}
	case patienttest.EdgeAdministrator:
		if id := m.administrator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpatient {
		edges = append(edges, patienttest.EdgePatient)
	}
	if m.clearedpsych_test {
		edges = append(edges, patienttest.EdgePsychTest)
	}
	if m.clearedadministrator {
		edges = append(edges, patienttest.EdgeAdministrator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientTestMutation) EdgeCleared(name string) bool {
	switch name {
	case patienttest.EdgePatient:
		return m.clearedpatient
	case patienttest.EdgePsychTest:
		return m.clearedpsych_test
	case patienttest.EdgeAdministrator:
		return m.clearedadministrator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientTestMutation) ClearEdge(name string) error {
	switch name {
	case patienttest.EdgePatient:
		m.ClearPatient()
		return nil
	case patienttest.EdgePsychTest:
		m.ClearPsychTest()
		return nil
	case patienttest.EdgeAdministrator:
		m.ClearAdministrator()
		return nil
	}
	return fmt.Errorf("unknown PatientTest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientTestMutation) ResetEdge(name string) error {
	switch name {
	case patienttest.EdgePatient:
		m.ResetPatient()
		return nil
	case patienttest.EdgePsychTest:
		m.ResetPsychTest()
		return nil
	case patienttest.EdgeAdministrator:
		m.ResetAdministrator()
		return nil
	}
	return fmt.Errorf("unknown PatientTest edge %s", name)
}

// PaymentRequestMutation represents an operation that mutates the PaymentRequest nodes in the graph.
type PaymentRequestMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	clinic_id          *uuid.UUID
	user_id            *uuid.UUID
	appointment_id     *uuid.UUID
	amount             *int64
	addamount          *int64
	description        *string
	status             *paymentrequest.Status
	source             *paymentrequest.Source
	zarinpal_authority *string
	zarinpal_ref_id    *string
	zarinpal_card_pan  *string
	zarinpal_card_hash *string
	paid_at            *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PaymentRequest, error)
	predicates         []predicate.PaymentRequest
}

var _ ent.Mutation = (*PaymentRequestMutation)(nil)

// paymentrequestOption allows management of the mutation configuration using functional options.
type paymentrequestOption func(*PaymentRequestMutation)

// newPaymentRequestMutation creates new mutation for the PaymentRequest entity.
func newPaymentRequestMutation(c config, op Op, opts ...paymentrequestOption) *PaymentRequestMutation {
	m := &PaymentRequestMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentRequestID sets the ID field of the mutation.
func withPaymentRequestID(id uuid.UUID) paymentrequestOption {
	return func(m *PaymentRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentRequest
		)
		m.oldValue = func(ctx context.Context) (*PaymentRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentRequest sets the old PaymentRequest of the mutation.
func withPaymentRequest(node *PaymentRequest) paymentrequestOption {
	return func(m *PaymentRequestMutation) {
		m.oldValue = func(context.Context) (*PaymentRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentRequest entities.
func (m *PaymentRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *PaymentRequestMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *PaymentRequestMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *PaymentRequestMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetUserID sets the "user_id" field.
func (m *PaymentRequestMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentRequestMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentRequestMutation) ResetUserID() {
	m.user_id = nil
}

// SetAppointmentID sets the "appointment_id" field.
func (m *PaymentRequestMutation) SetAppointmentID(u uuid.UUID) {
	m.appointment_id = &u
}

// AppointmentID returns the value of the "appointment_id" field in the mutation.
func (m *PaymentRequestMutation) AppointmentID() (r uuid.UUID, exists bool) {
	v := m.appointment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentID returns the old "appointment_id" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldAppointmentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentID: %w", err)
	}
	return oldValue.AppointmentID, nil
}

// ClearAppointmentID clears the value of the "appointment_id" field.
func (m *PaymentRequestMutation) ClearAppointmentID() {
	m.appointment_id = nil
	m.clearedFields[paymentrequest.FieldAppointmentID] = struct{}{}
}

// AppointmentIDCleared returns if the "appointment_id" field was cleared in this mutation.
func (m *PaymentRequestMutation) AppointmentIDCleared() bool {
	_, ok := m.clearedFields[paymentrequest.FieldAppointmentID]
	return ok
}

// ResetAppointmentID resets all changes to the "appointment_id" field.
func (m *PaymentRequestMutation) ResetAppointmentID() {
	m.appointment_id = nil
	delete(m.clearedFields, paymentrequest.FieldAppointmentID)
}

// SetAmount sets the "amount" field.
func (m *PaymentRequestMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentRequestMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *PaymentRequestMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentRequestMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentRequestMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDescription sets the "description" field.
func (m *PaymentRequestMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PaymentRequestMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PaymentRequestMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *PaymentRequestMutation) SetStatus(pa paymentrequest.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentRequestMutation) Status() (r paymentrequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldStatus(ctx context.Context) (v paymentrequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentRequestMutation) ResetStatus() {
	m.status = nil
}

// SetSource sets the "source" field.
func (m *PaymentRequestMutation) SetSource(pa paymentrequest.Source) {
	m.source = &pa
}

// Source returns the value of the "source" field in the mutation.
func (m *PaymentRequestMutation) Source() (r paymentrequest.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldSource(ctx context.Context) (v paymentrequest.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PaymentRequestMutation) ResetSource() {
	m.source = nil
}

// SetZarinpalAuthority sets the "zarinpal_authority" field.
func (m *PaymentRequestMutation) SetZarinpalAuthority(s string) {
	m.zarinpal_authority = &s
}

// ZarinpalAuthority returns the value of the "zarinpal_authority" field in the mutation.
func (m *PaymentRequestMutation) ZarinpalAuthority() (r string, exists bool) {
	v := m.zarinpal_authority
	if v == nil {
		return
	}
	return *v, true
}

// OldZarinpalAuthority returns the old "zarinpal_authority" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldZarinpalAuthority(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZarinpalAuthority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZarinpalAuthority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZarinpalAuthority: %w", err)
	}
	return oldValue.ZarinpalAuthority, nil
}

// ClearZarinpalAuthority clears the value of the "zarinpal_authority" field.
func (m *PaymentRequestMutation) ClearZarinpalAuthority() {
	m.zarinpal_authority = nil
	m.clearedFields[paymentrequest.FieldZarinpalAuthority] = struct{}{}
}

// ZarinpalAuthorityCleared returns if the "zarinpal_authority" field was cleared in this mutation.
func (m *PaymentRequestMutation) ZarinpalAuthorityCleared() bool {
	_, ok := m.clearedFields[paymentrequest.FieldZarinpalAuthority]
	return ok
}

// ResetZarinpalAuthority resets all changes to the "zarinpal_authority" field.
func (m *PaymentRequestMutation) ResetZarinpalAuthority() {
	m.zarinpal_authority = nil
	delete(m.clearedFields, paymentrequest.FieldZarinpalAuthority)
}

// SetZarinpalRefID sets the "zarinpal_ref_id" field.
func (m *PaymentRequestMutation) SetZarinpalRefID(s string) {
	m.zarinpal_ref_id = &s
}

// ZarinpalRefID returns the value of the "zarinpal_ref_id" field in the mutation.
func (m *PaymentRequestMutation) ZarinpalRefID() (r string, exists bool) {
	v := m.zarinpal_ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZarinpalRefID returns the old "zarinpal_ref_id" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldZarinpalRefID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZarinpalRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZarinpalRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZarinpalRefID: %w", err)
	}
	return oldValue.ZarinpalRefID, nil
}

// ClearZarinpalRefID clears the value of the "zarinpal_ref_id" field.
func (m *PaymentRequestMutation) ClearZarinpalRefID() {
	m.zarinpal_ref_id = nil
	m.clearedFields[paymentrequest.FieldZarinpalRefID] = struct{}{}
}

// ZarinpalRefIDCleared returns if the "zarinpal_ref_id" field was cleared in this mutation.
func (m *PaymentRequestMutation) ZarinpalRefIDCleared() bool {
	_, ok := m.clearedFields[paymentrequest.FieldZarinpalRefID]
	return ok
}

// ResetZarinpalRefID resets all changes to the "zarinpal_ref_id" field.
func (m *PaymentRequestMutation) ResetZarinpalRefID() {
	m.zarinpal_ref_id = nil
	delete(m.clearedFields, paymentrequest.FieldZarinpalRefID)
}

// SetZarinpalCardPan sets the "zarinpal_card_pan" field.
func (m *PaymentRequestMutation) SetZarinpalCardPan(s string) {
	m.zarinpal_card_pan = &s
}

// ZarinpalCardPan returns the value of the "zarinpal_card_pan" field in the mutation.
func (m *PaymentRequestMutation) ZarinpalCardPan() (r string, exists bool) {
	v := m.zarinpal_card_pan
	if v == nil {
		return
	}
	return *v, true
}

// OldZarinpalCardPan returns the old "zarinpal_card_pan" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldZarinpalCardPan(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZarinpalCardPan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZarinpalCardPan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZarinpalCardPan: %w", err)
	}
	return oldValue.ZarinpalCardPan, nil
}

// ClearZarinpalCardPan clears the value of the "zarinpal_card_pan" field.
func (m *PaymentRequestMutation) ClearZarinpalCardPan() {
	m.zarinpal_card_pan = nil
	m.clearedFields[paymentrequest.FieldZarinpalCardPan] = struct{}{}
}

// ZarinpalCardPanCleared returns if the "zarinpal_card_pan" field was cleared in this mutation.
func (m *PaymentRequestMutation) ZarinpalCardPanCleared() bool {
	_, ok := m.clearedFields[paymentrequest.FieldZarinpalCardPan]
	return ok
}

// ResetZarinpalCardPan resets all changes to the "zarinpal_card_pan" field.
func (m *PaymentRequestMutation) ResetZarinpalCardPan() {
	m.zarinpal_card_pan = nil
	delete(m.clearedFields, paymentrequest.FieldZarinpalCardPan)
}

// SetZarinpalCardHash sets the "zarinpal_card_hash" field.
func (m *PaymentRequestMutation) SetZarinpalCardHash(s string) {
	m.zarinpal_card_hash = &s
}

// ZarinpalCardHash returns the value of the "zarinpal_card_hash" field in the mutation.
func (m *PaymentRequestMutation) ZarinpalCardHash() (r string, exists bool) {
	v := m.zarinpal_card_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldZarinpalCardHash returns the old "zarinpal_card_hash" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldZarinpalCardHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZarinpalCardHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZarinpalCardHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZarinpalCardHash: %w", err)
	}
	return oldValue.ZarinpalCardHash, nil
}

// ClearZarinpalCardHash clears the value of the "zarinpal_card_hash" field.
func (m *PaymentRequestMutation) ClearZarinpalCardHash() {
	m.zarinpal_card_hash = nil
	m.clearedFields[paymentrequest.FieldZarinpalCardHash] = struct{}{}
}

// ZarinpalCardHashCleared returns if the "zarinpal_card_hash" field was cleared in this mutation.
func (m *PaymentRequestMutation) ZarinpalCardHashCleared() bool {
	_, ok := m.clearedFields[paymentrequest.FieldZarinpalCardHash]
	return ok
}

// ResetZarinpalCardHash resets all changes to the "zarinpal_card_hash" field.
func (m *PaymentRequestMutation) ResetZarinpalCardHash() {
	m.zarinpal_card_hash = nil
	delete(m.clearedFields, paymentrequest.FieldZarinpalCardHash)
}

// SetPaidAt sets the "paid_at" field.
func (m *PaymentRequestMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PaymentRequestMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the PaymentRequest entity.
// If the PaymentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequestMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *PaymentRequestMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[paymentrequest.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *PaymentRequestMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[paymentrequest.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PaymentRequestMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, paymentrequest.FieldPaidAt)
}

// Where appends a list predicates to the PaymentRequestMutation builder.
func (m *PaymentRequestMutation) Where(ps ...predicate.PaymentRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentRequest).
func (m *PaymentRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentRequestMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, paymentrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentrequest.FieldUpdatedAt)
	}
	if m.clinic_id != nil {
		fields = append(fields, paymentrequest.FieldClinicID)
	}
	if m.user_id != nil {
		fields = append(fields, paymentrequest.FieldUserID)
	}
	if m.appointment_id != nil {
		fields = append(fields, paymentrequest.FieldAppointmentID)
	}
	if m.amount != nil {
		fields = append(fields, paymentrequest.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, paymentrequest.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, paymentrequest.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, paymentrequest.FieldSource)
	}
	if m.zarinpal_authority != nil {
		fields = append(fields, paymentrequest.FieldZarinpalAuthority)
	}
	if m.zarinpal_ref_id != nil {
		fields = append(fields, paymentrequest.FieldZarinpalRefID)
	}
	if m.zarinpal_card_pan != nil {
		fields = append(fields, paymentrequest.FieldZarinpalCardPan)
	}
	if m.zarinpal_card_hash != nil {
		fields = append(fields, paymentrequest.FieldZarinpalCardHash)
	}
	if m.paid_at != nil {
		fields = append(fields, paymentrequest.FieldPaidAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentrequest.FieldCreatedAt:
		return m.CreatedAt()
	case paymentrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentrequest.FieldClinicID:
		return m.ClinicID()
	case paymentrequest.FieldUserID:
		return m.UserID()
	case paymentrequest.FieldAppointmentID:
		return m.AppointmentID()
	case paymentrequest.FieldAmount:
		return m.Amount()
	case paymentrequest.FieldDescription:
		return m.Description()
	case paymentrequest.FieldStatus:
		return m.Status()
	case paymentrequest.FieldSource:
		return m.Source()
	case paymentrequest.FieldZarinpalAuthority:
		return m.ZarinpalAuthority()
	case paymentrequest.FieldZarinpalRefID:
		return m.ZarinpalRefID()
	case paymentrequest.FieldZarinpalCardPan:
		return m.ZarinpalCardPan()
	case paymentrequest.FieldZarinpalCardHash:
		return m.ZarinpalCardHash()
	case paymentrequest.FieldPaidAt:
		return m.PaidAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentrequest.FieldClinicID:
		return m.OldClinicID(ctx)
	case paymentrequest.FieldUserID:
		return m.OldUserID(ctx)
	case paymentrequest.FieldAppointmentID:
		return m.OldAppointmentID(ctx)
	case paymentrequest.FieldAmount:
		return m.OldAmount(ctx)
	case paymentrequest.FieldDescription:
		return m.OldDescription(ctx)
	case paymentrequest.FieldStatus:
		return m.OldStatus(ctx)
	case paymentrequest.FieldSource:
		return m.OldSource(ctx)
	case paymentrequest.FieldZarinpalAuthority:
		return m.OldZarinpalAuthority(ctx)
	case paymentrequest.FieldZarinpalRefID:
		return m.OldZarinpalRefID(ctx)
	case paymentrequest.FieldZarinpalCardPan:
		return m.OldZarinpalCardPan(ctx)
	case paymentrequest.FieldZarinpalCardHash:
		return m.OldZarinpalCardHash(ctx)
	case paymentrequest.FieldPaidAt:
		return m.OldPaidAt(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentrequest.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case paymentrequest.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentrequest.FieldAppointmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentID(v)
		return nil
	case paymentrequest.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentrequest.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case paymentrequest.FieldStatus:
		v, ok := value.(paymentrequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentrequest.FieldSource:
		v, ok := value.(paymentrequest.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case paymentrequest.FieldZarinpalAuthority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZarinpalAuthority(v)
		return nil
	case paymentrequest.FieldZarinpalRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZarinpalRefID(v)
		return nil
	case paymentrequest.FieldZarinpalCardPan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZarinpalCardPan(v)
		return nil
	case paymentrequest.FieldZarinpalCardHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZarinpalCardHash(v)
		return nil
	case paymentrequest.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentRequestMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, paymentrequest.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentrequest.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentrequest.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentrequest.FieldAppointmentID) {
		fields = append(fields, paymentrequest.FieldAppointmentID)
	}
	if m.FieldCleared(paymentrequest.FieldZarinpalAuthority) {
		fields = append(fields, paymentrequest.FieldZarinpalAuthority)
	}
	if m.FieldCleared(paymentrequest.FieldZarinpalRefID) {
		fields = append(fields, paymentrequest.FieldZarinpalRefID)
	}
	if m.FieldCleared(paymentrequest.FieldZarinpalCardPan) {
		fields = append(fields, paymentrequest.FieldZarinpalCardPan)
	}
	if m.FieldCleared(paymentrequest.FieldZarinpalCardHash) {
		fields = append(fields, paymentrequest.FieldZarinpalCardHash)
	}
	if m.FieldCleared(paymentrequest.FieldPaidAt) {
		fields = append(fields, paymentrequest.FieldPaidAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentRequestMutation) ClearField(name string) error {
	switch name {
	case paymentrequest.FieldAppointmentID:
		m.ClearAppointmentID()
		return nil
	case paymentrequest.FieldZarinpalAuthority:
		m.ClearZarinpalAuthority()
		return nil
	case paymentrequest.FieldZarinpalRefID:
		m.ClearZarinpalRefID()
		return nil
	case paymentrequest.FieldZarinpalCardPan:
		m.ClearZarinpalCardPan()
		return nil
	case paymentrequest.FieldZarinpalCardHash:
		m.ClearZarinpalCardHash()
		return nil
	case paymentrequest.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentRequestMutation) ResetField(name string) error {
	switch name {
	case paymentrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentrequest.FieldClinicID:
		m.ResetClinicID()
		return nil
	case paymentrequest.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentrequest.FieldAppointmentID:
		m.ResetAppointmentID()
		return nil
	case paymentrequest.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentrequest.FieldDescription:
		m.ResetDescription()
		return nil
	case paymentrequest.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentrequest.FieldSource:
		m.ResetSource()
		return nil
	case paymentrequest.FieldZarinpalAuthority:
		m.ResetZarinpalAuthority()
		return nil
	case paymentrequest.FieldZarinpalRefID:
		m.ResetZarinpalRefID()
		return nil
	case paymentrequest.FieldZarinpalCardPan:
		m.ResetZarinpalCardPan()
		return nil
	case paymentrequest.FieldZarinpalCardHash:
		m.ResetZarinpalCardHash()
		return nil
	case paymentrequest.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentRequest edge %s", name)
}

// PsychTestMutation represents an operation that mutates the PsychTest nodes in the graph.
type PsychTestMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	name           *string
	name_fa        *string
	description    *string
	category       *string
	age_range      *string
	schema_data    *map[string]interface{}
	scoring_method *string
	is_active      *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PsychTest, error)
	predicates     []predicate.PsychTest
}

var _ ent.Mutation = (*PsychTestMutation)(nil)

// psychtestOption allows management of the mutation configuration using functional options.
type psychtestOption func(*PsychTestMutation)

// newPsychTestMutation creates new mutation for the PsychTest entity.
func newPsychTestMutation(c config, op Op, opts ...psychtestOption) *PsychTestMutation {
	m := &PsychTestMutation{
		config:        c,
		op:            op,
		typ:           TypePsychTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPsychTestID sets the ID field of the mutation.
func withPsychTestID(id uuid.UUID) psychtestOption {
	return func(m *PsychTestMutation) {
		var (
			err   error
			once  sync.Once
			value *PsychTest
		)
		m.oldValue = func(ctx context.Context) (*PsychTest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PsychTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPsychTest sets the old PsychTest of the mutation.
func withPsychTest(node *PsychTest) psychtestOption {
	return func(m *PsychTestMutation) {
		m.oldValue = func(context.Context) (*PsychTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PsychTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PsychTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PsychTest entities.
func (m *PsychTestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PsychTestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PsychTestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PsychTest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PsychTestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PsychTestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PsychTestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetName sets the "name" field.
func (m *PsychTestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PsychTestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PsychTestMutation) ResetName() {
	m.name = nil
}

// SetNameFa sets the "name_fa" field.
func (m *PsychTestMutation) SetNameFa(s string) {
	m.name_fa = &s
}

// NameFa returns the value of the "name_fa" field in the mutation.
func (m *PsychTestMutation) NameFa() (r string, exists bool) {
	v := m.name_fa
	if v == nil {
		return
	}
	return *v, true
}

// OldNameFa returns the old "name_fa" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldNameFa(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameFa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameFa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameFa: %w", err)
	}
	return oldValue.NameFa, nil
}

// ClearNameFa clears the value of the "name_fa" field.
func (m *PsychTestMutation) ClearNameFa() {
	m.name_fa = nil
	m.clearedFields[psychtest.FieldNameFa] = struct{}{}
}

// NameFaCleared returns if the "name_fa" field was cleared in this mutation.
func (m *PsychTestMutation) NameFaCleared() bool {
	_, ok := m.clearedFields[psychtest.FieldNameFa]
	return ok
}

// ResetNameFa resets all changes to the "name_fa" field.
func (m *PsychTestMutation) ResetNameFa() {
	m.name_fa = nil
	delete(m.clearedFields, psychtest.FieldNameFa)
}

// SetDescription sets the "description" field.
func (m *PsychTestMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PsychTestMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PsychTestMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[psychtest.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PsychTestMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[psychtest.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PsychTestMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, psychtest.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *PsychTestMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *PsychTestMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *PsychTestMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[psychtest.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *PsychTestMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[psychtest.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *PsychTestMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, psychtest.FieldCategory)
}

// SetAgeRange sets the "age_range" field.
func (m *PsychTestMutation) SetAgeRange(s string) {
	m.age_range = &s
}

// AgeRange returns the value of the "age_range" field in the mutation.
func (m *PsychTestMutation) AgeRange() (r string, exists bool) {
	v := m.age_range
	if v == nil {
		return
	}
	return *v, true
}

// OldAgeRange returns the old "age_range" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldAgeRange(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgeRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgeRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgeRange: %w", err)
	}
	return oldValue.AgeRange, nil
}

// ClearAgeRange clears the value of the "age_range" field.
func (m *PsychTestMutation) ClearAgeRange() {
	m.age_range = nil
	m.clearedFields[psychtest.FieldAgeRange] = struct{}{}
}

// AgeRangeCleared returns if the "age_range" field was cleared in this mutation.
func (m *PsychTestMutation) AgeRangeCleared() bool {
	_, ok := m.clearedFields[psychtest.FieldAgeRange]
	return ok
}

// ResetAgeRange resets all changes to the "age_range" field.
func (m *PsychTestMutation) ResetAgeRange() {
	m.age_range = nil
	delete(m.clearedFields, psychtest.FieldAgeRange)
}

// SetSchemaData sets the "schema_data" field.
func (m *PsychTestMutation) SetSchemaData(value map[string]interface{}) {
	m.schema_data = &value
}

// SchemaData returns the value of the "schema_data" field in the mutation.
func (m *PsychTestMutation) SchemaData() (r map[string]interface{}, exists bool) {
	v := m.schema_data
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemaData returns the old "schema_data" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldSchemaData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchemaData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchemaData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemaData: %w", err)
	}
	return oldValue.SchemaData, nil
}

// ClearSchemaData clears the value of the "schema_data" field.
func (m *PsychTestMutation) ClearSchemaData() {
	m.schema_data = nil
	m.clearedFields[psychtest.FieldSchemaData] = struct{}{}
}

// SchemaDataCleared returns if the "schema_data" field was cleared in this mutation.
func (m *PsychTestMutation) SchemaDataCleared() bool {
	_, ok := m.clearedFields[psychtest.FieldSchemaData]
	return ok
}

// ResetSchemaData resets all changes to the "schema_data" field.
func (m *PsychTestMutation) ResetSchemaData() {
	m.schema_data = nil
	delete(m.clearedFields, psychtest.FieldSchemaData)
}

// SetScoringMethod sets the "scoring_method" field.
func (m *PsychTestMutation) SetScoringMethod(s string) {
	m.scoring_method = &s
}

// ScoringMethod returns the value of the "scoring_method" field in the mutation.
func (m *PsychTestMutation) ScoringMethod() (r string, exists bool) {
	v := m.scoring_method
	if v == nil {
		return
	}
	return *v, true
}

// OldScoringMethod returns the old "scoring_method" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldScoringMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoringMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoringMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoringMethod: %w", err)
	}
	return oldValue.ScoringMethod, nil
}

// ClearScoringMethod clears the value of the "scoring_method" field.
func (m *PsychTestMutation) ClearScoringMethod() {
	m.scoring_method = nil
	m.clearedFields[psychtest.FieldScoringMethod] = struct{}{}
}

// ScoringMethodCleared returns if the "scoring_method" field was cleared in this mutation.
func (m *PsychTestMutation) ScoringMethodCleared() bool {
	_, ok := m.clearedFields[psychtest.FieldScoringMethod]
	return ok
}

// ResetScoringMethod resets all changes to the "scoring_method" field.
func (m *PsychTestMutation) ResetScoringMethod() {
	m.scoring_method = nil
	delete(m.clearedFields, psychtest.FieldScoringMethod)
}

// SetIsActive sets the "is_active" field.
func (m *PsychTestMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PsychTestMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PsychTest entity.
// If the PsychTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PsychTestMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PsychTestMutation) ResetIsActive() {
	m.is_active = nil
}

// Where appends a list predicates to the PsychTestMutation builder.
func (m *PsychTestMutation) Where(ps ...predicate.PsychTest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PsychTestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PsychTestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PsychTest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PsychTestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PsychTestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PsychTest).
func (m *PsychTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PsychTestMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, psychtest.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, psychtest.FieldName)
	}
	if m.name_fa != nil {
		fields = append(fields, psychtest.FieldNameFa)
	}
	if m.description != nil {
		fields = append(fields, psychtest.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, psychtest.FieldCategory)
	}
	if m.age_range != nil {
		fields = append(fields, psychtest.FieldAgeRange)
	}
	if m.schema_data != nil {
		fields = append(fields, psychtest.FieldSchemaData)
	}
	if m.scoring_method != nil {
		fields = append(fields, psychtest.FieldScoringMethod)
	}
	if m.is_active != nil {
		fields = append(fields, psychtest.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PsychTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case psychtest.FieldCreatedAt:
		return m.CreatedAt()
	case psychtest.FieldName:
		return m.Name()
	case psychtest.FieldNameFa:
		return m.NameFa()
	case psychtest.FieldDescription:
		return m.Description()
	case psychtest.FieldCategory:
		return m.Category()
	case psychtest.FieldAgeRange:
		return m.AgeRange()
	case psychtest.FieldSchemaData:
		return m.SchemaData()
	case psychtest.FieldScoringMethod:
		return m.ScoringMethod()
	case psychtest.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PsychTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case psychtest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case psychtest.FieldName:
		return m.OldName(ctx)
	case psychtest.FieldNameFa:
		return m.OldNameFa(ctx)
	case psychtest.FieldDescription:
		return m.OldDescription(ctx)
	case psychtest.FieldCategory:
		return m.OldCategory(ctx)
	case psychtest.FieldAgeRange:
		return m.OldAgeRange(ctx)
	case psychtest.FieldSchemaData:
		return m.OldSchemaData(ctx)
	case psychtest.FieldScoringMethod:
		return m.OldScoringMethod(ctx)
	case psychtest.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown PsychTest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PsychTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case psychtest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case psychtest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case psychtest.FieldNameFa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameFa(v)
		return nil
	case psychtest.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case psychtest.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case psychtest.FieldAgeRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgeRange(v)
		return nil
	case psychtest.FieldSchemaData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemaData(v)
		return nil
	case psychtest.FieldScoringMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoringMethod(v)
		return nil
	case psychtest.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown PsychTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PsychTestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PsychTestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PsychTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PsychTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PsychTestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(psychtest.FieldNameFa) {
		fields = append(fields, psychtest.FieldNameFa)
	}
	if m.FieldCleared(psychtest.FieldDescription) {
		fields = append(fields, psychtest.FieldDescription)
	}
	if m.FieldCleared(psychtest.FieldCategory) {
		fields = append(fields, psychtest.FieldCategory)
	}
	if m.FieldCleared(psychtest.FieldAgeRange) {
		fields = append(fields, psychtest.FieldAgeRange)
	}
	if m.FieldCleared(psychtest.FieldSchemaData) {
		fields = append(fields, psychtest.FieldSchemaData)
	}
	if m.FieldCleared(psychtest.FieldScoringMethod) {
		fields = append(fields, psychtest.FieldScoringMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PsychTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PsychTestMutation) ClearField(name string) error {
	switch name {
	case psychtest.FieldNameFa:
		m.ClearNameFa()
		return nil
	case psychtest.FieldDescription:
		m.ClearDescription()
		return nil
	case psychtest.FieldCategory:
		m.ClearCategory()
		return nil
	case psychtest.FieldAgeRange:
		m.ClearAgeRange()
		return nil
	case psychtest.FieldSchemaData:
		m.ClearSchemaData()
		return nil
	case psychtest.FieldScoringMethod:
		m.ClearScoringMethod()
		return nil
	}
	return fmt.Errorf("unknown PsychTest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PsychTestMutation) ResetField(name string) error {
	switch name {
	case psychtest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case psychtest.FieldName:
		m.ResetName()
		return nil
	case psychtest.FieldNameFa:
		m.ResetNameFa()
		return nil
	case psychtest.FieldDescription:
		m.ResetDescription()
		return nil
	case psychtest.FieldCategory:
		m.ResetCategory()
		return nil
	case psychtest.FieldAgeRange:
		m.ResetAgeRange()
		return nil
	case psychtest.FieldSchemaData:
		m.ResetSchemaData()
		return nil
	case psychtest.FieldScoringMethod:
		m.ResetScoringMethod()
		return nil
	case psychtest.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown PsychTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PsychTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PsychTestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PsychTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PsychTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PsychTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PsychTestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PsychTestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PsychTest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PsychTestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PsychTest edge %s", name)
}

// RecurringRuleMutation represents an operation that mutates the RecurringRule nodes in the graph.
type RecurringRuleMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	therapist_id       *uuid.UUID
	clinic_id          *uuid.UUID
	day_of_week        *int8
	addday_of_week     *int8
	start_hour         *int8
	addstart_hour      *int8
	start_minute       *int8
	addstart_minute    *int8
	end_hour           *int8
	addend_hour        *int8
	end_minute         *int8
	addend_minute      *int8
	session_price      *int64
	addsession_price   *int64
	reservation_fee    *int64
	addreservation_fee *int64
	valid_from         *time.Time
	valid_until        *time.Time
	is_active          *bool
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*RecurringRule, error)
	predicates         []predicate.RecurringRule
}

var _ ent.Mutation = (*RecurringRuleMutation)(nil)

// recurringruleOption allows management of the mutation configuration using functional options.
type recurringruleOption func(*RecurringRuleMutation)

// newRecurringRuleMutation creates new mutation for the RecurringRule entity.
func newRecurringRuleMutation(c config, op Op, opts ...recurringruleOption) *RecurringRuleMutation {
	m := &RecurringRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRecurringRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecurringRuleID sets the ID field of the mutation.
func withRecurringRuleID(id uuid.UUID) recurringruleOption {
	return func(m *RecurringRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *RecurringRule
		)
		m.oldValue = func(ctx context.Context) (*RecurringRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecurringRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecurringRule sets the old RecurringRule of the mutation.
func withRecurringRule(node *RecurringRule) recurringruleOption {
	return func(m *RecurringRuleMutation) {
		m.oldValue = func(context.Context) (*RecurringRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecurringRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecurringRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RecurringRule entities.
func (m *RecurringRuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecurringRuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecurringRuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecurringRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RecurringRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecurringRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecurringRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecurringRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecurringRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecurringRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTherapistID sets the "therapist_id" field.
func (m *RecurringRuleMutation) SetTherapistID(u uuid.UUID) {
	m.therapist_id = &u
}

// TherapistID returns the value of the "therapist_id" field in the mutation.
func (m *RecurringRuleMutation) TherapistID() (r uuid.UUID, exists bool) {
	v := m.therapist_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTherapistID returns the old "therapist_id" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldTherapistID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTherapistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTherapistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTherapistID: %w", err)
	}
	return oldValue.TherapistID, nil
}

// ResetTherapistID resets all changes to the "therapist_id" field.
func (m *RecurringRuleMutation) ResetTherapistID() {
	m.therapist_id = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *RecurringRuleMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *RecurringRuleMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *RecurringRuleMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetDayOfWeek sets the "day_of_week" field.
func (m *RecurringRuleMutation) SetDayOfWeek(i int8) {
	m.day_of_week = &i
	m.addday_of_week = nil
}

// DayOfWeek returns the value of the "day_of_week" field in the mutation.
func (m *RecurringRuleMutation) DayOfWeek() (r int8, exists bool) {
	v := m.day_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOfWeek returns the old "day_of_week" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldDayOfWeek(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOfWeek: %w", err)
	}
	return oldValue.DayOfWeek, nil
}

// AddDayOfWeek adds i to the "day_of_week" field.
func (m *RecurringRuleMutation) AddDayOfWeek(i int8) {
	if m.addday_of_week != nil {
		*m.addday_of_week += i
	} else {
		m.addday_of_week = &i
	}
}

// AddedDayOfWeek returns the value that was added to the "day_of_week" field in this mutation.
func (m *RecurringRuleMutation) AddedDayOfWeek() (r int8, exists bool) {
	v := m.addday_of_week
	if v == nil {
		return
	}
	return *v, true
}

// ResetDayOfWeek resets all changes to the "day_of_week" field.
func (m *RecurringRuleMutation) ResetDayOfWeek() {
	m.day_of_week = nil
	m.addday_of_week = nil
}

// SetStartHour sets the "start_hour" field.
func (m *RecurringRuleMutation) SetStartHour(i int8) {
	m.start_hour = &i
	m.addstart_hour = nil
}

// StartHour returns the value of the "start_hour" field in the mutation.
func (m *RecurringRuleMutation) StartHour() (r int8, exists bool) {
	v := m.start_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldStartHour returns the old "start_hour" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldStartHour(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartHour: %w", err)
	}
	return oldValue.StartHour, nil
}

// AddStartHour adds i to the "start_hour" field.
func (m *RecurringRuleMutation) AddStartHour(i int8) {
	if m.addstart_hour != nil {
		*m.addstart_hour += i
	} else {
		m.addstart_hour = &i
	}
}

// AddedStartHour returns the value that was added to the "start_hour" field in this mutation.
func (m *RecurringRuleMutation) AddedStartHour() (r int8, exists bool) {
	v := m.addstart_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartHour resets all changes to the "start_hour" field.
func (m *RecurringRuleMutation) ResetStartHour() {
	m.start_hour = nil
	m.addstart_hour = nil
}

// SetStartMinute sets the "start_minute" field.
func (m *RecurringRuleMutation) SetStartMinute(i int8) {
	m.start_minute = &i
	m.addstart_minute = nil
}

// StartMinute returns the value of the "start_minute" field in the mutation.
func (m *RecurringRuleMutation) StartMinute() (r int8, exists bool) {
	v := m.start_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMinute returns the old "start_minute" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldStartMinute(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMinute: %w", err)
	}
	return oldValue.StartMinute, nil
}

// AddStartMinute adds i to the "start_minute" field.
func (m *RecurringRuleMutation) AddStartMinute(i int8) {
	if m.addstart_minute != nil {
		*m.addstart_minute += i
	} else {
		m.addstart_minute = &i
	}
}

// AddedStartMinute returns the value that was added to the "start_minute" field in this mutation.
func (m *RecurringRuleMutation) AddedStartMinute() (r int8, exists bool) {
	v := m.addstart_minute
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartMinute resets all changes to the "start_minute" field.
func (m *RecurringRuleMutation) ResetStartMinute() {
	m.start_minute = nil
	m.addstart_minute = nil
}

// SetEndHour sets the "end_hour" field.
func (m *RecurringRuleMutation) SetEndHour(i int8) {
	m.end_hour = &i
	m.addend_hour = nil
}

// EndHour returns the value of the "end_hour" field in the mutation.
func (m *RecurringRuleMutation) EndHour() (r int8, exists bool) {
	v := m.end_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldEndHour returns the old "end_hour" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldEndHour(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndHour: %w", err)
	}
	return oldValue.EndHour, nil
}

// AddEndHour adds i to the "end_hour" field.
func (m *RecurringRuleMutation) AddEndHour(i int8) {
	if m.addend_hour != nil {
		*m.addend_hour += i
	} else {
		m.addend_hour = &i
	}
}

// AddedEndHour returns the value that was added to the "end_hour" field in this mutation.
func (m *RecurringRuleMutation) AddedEndHour() (r int8, exists bool) {
	v := m.addend_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndHour resets all changes to the "end_hour" field.
func (m *RecurringRuleMutation) ResetEndHour() {
	m.end_hour = nil
	m.addend_hour = nil
}

// SetEndMinute sets the "end_minute" field.
func (m *RecurringRuleMutation) SetEndMinute(i int8) {
	m.end_minute = &i
	m.addend_minute = nil
}

// EndMinute returns the value of the "end_minute" field in the mutation.
func (m *RecurringRuleMutation) EndMinute() (r int8, exists bool) {
	v := m.end_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldEndMinute returns the old "end_minute" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldEndMinute(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndMinute: %w", err)
	}
	return oldValue.EndMinute, nil
}

// AddEndMinute adds i to the "end_minute" field.
func (m *RecurringRuleMutation) AddEndMinute(i int8) {
	if m.addend_minute != nil {
		*m.addend_minute += i
	} else {
		m.addend_minute = &i
	}
}

// AddedEndMinute returns the value that was added to the "end_minute" field in this mutation.
func (m *RecurringRuleMutation) AddedEndMinute() (r int8, exists bool) {
	v := m.addend_minute
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndMinute resets all changes to the "end_minute" field.
func (m *RecurringRuleMutation) ResetEndMinute() {
	m.end_minute = nil
	m.addend_minute = nil
}

// SetSessionPrice sets the "session_price" field.
func (m *RecurringRuleMutation) SetSessionPrice(i int64) {
	m.session_price = &i
	m.addsession_price = nil
}

// SessionPrice returns the value of the "session_price" field in the mutation.
func (m *RecurringRuleMutation) SessionPrice() (r int64, exists bool) {
	v := m.session_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionPrice returns the old "session_price" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldSessionPrice(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionPrice: %w", err)
	}
	return oldValue.SessionPrice, nil
}

// AddSessionPrice adds i to the "session_price" field.
func (m *RecurringRuleMutation) AddSessionPrice(i int64) {
	if m.addsession_price != nil {
		*m.addsession_price += i
	} else {
		m.addsession_price = &i
	}
}

// AddedSessionPrice returns the value that was added to the "session_price" field in this mutation.
func (m *RecurringRuleMutation) AddedSessionPrice() (r int64, exists bool) {
	v := m.addsession_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearSessionPrice clears the value of the "session_price" field.
func (m *RecurringRuleMutation) ClearSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
	m.clearedFields[recurringrule.FieldSessionPrice] = struct{}{}
}

// SessionPriceCleared returns if the "session_price" field was cleared in this mutation.
func (m *RecurringRuleMutation) SessionPriceCleared() bool {
	_, ok := m.clearedFields[recurringrule.FieldSessionPrice]
	return ok
}

// ResetSessionPrice resets all changes to the "session_price" field.
func (m *RecurringRuleMutation) ResetSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
	delete(m.clearedFields, recurringrule.FieldSessionPrice)
}

// SetReservationFee sets the "reservation_fee" field.
func (m *RecurringRuleMutation) SetReservationFee(i int64) {
	m.reservation_fee = &i
	m.addreservation_fee = nil
}

// ReservationFee returns the value of the "reservation_fee" field in the mutation.
func (m *RecurringRuleMutation) ReservationFee() (r int64, exists bool) {
	v := m.reservation_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationFee returns the old "reservation_fee" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldReservationFee(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationFee: %w", err)
	}
	return oldValue.ReservationFee, nil
}

// AddReservationFee adds i to the "reservation_fee" field.
func (m *RecurringRuleMutation) AddReservationFee(i int64) {
	if m.addreservation_fee != nil {
		*m.addreservation_fee += i
	} else {
		m.addreservation_fee = &i
	}
}

// AddedReservationFee returns the value that was added to the "reservation_fee" field in this mutation.
func (m *RecurringRuleMutation) AddedReservationFee() (r int64, exists bool) {
	v := m.addreservation_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservationFee clears the value of the "reservation_fee" field.
func (m *RecurringRuleMutation) ClearReservationFee() {
	m.reservation_fee = nil
	m.addreservation_fee = nil
	m.clearedFields[recurringrule.FieldReservationFee] = struct{}{}
}

// ReservationFeeCleared returns if the "reservation_fee" field was cleared in this mutation.
func (m *RecurringRuleMutation) ReservationFeeCleared() bool {
	_, ok := m.clearedFields[recurringrule.FieldReservationFee]
	return ok
}

// ResetReservationFee resets all changes to the "reservation_fee" field.
func (m *RecurringRuleMutation) ResetReservationFee() {
	m.reservation_fee = nil
	m.addreservation_fee = nil
	delete(m.clearedFields, recurringrule.FieldReservationFee)
}

// SetValidFrom sets the "valid_from" field.
func (m *RecurringRuleMutation) SetValidFrom(t time.Time) {
	m.valid_from = &t
}

// ValidFrom returns the value of the "valid_from" field in the mutation.
func (m *RecurringRuleMutation) ValidFrom() (r time.Time, exists bool) {
	v := m.valid_from
	if v == nil {
		return
	}
	return *v, true
}

// OldValidFrom returns the old "valid_from" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldValidFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidFrom: %w", err)
	}
	return oldValue.ValidFrom, nil
}

// ResetValidFrom resets all changes to the "valid_from" field.
func (m *RecurringRuleMutation) ResetValidFrom() {
	m.valid_from = nil
}

// SetValidUntil sets the "valid_until" field.
func (m *RecurringRuleMutation) SetValidUntil(t time.Time) {
	m.valid_until = &t
}

// ValidUntil returns the value of the "valid_until" field in the mutation.
func (m *RecurringRuleMutation) ValidUntil() (r time.Time, exists bool) {
	v := m.valid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldValidUntil returns the old "valid_until" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldValidUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidUntil: %w", err)
	}
	return oldValue.ValidUntil, nil
}

// ClearValidUntil clears the value of the "valid_until" field.
func (m *RecurringRuleMutation) ClearValidUntil() {
	m.valid_until = nil
	m.clearedFields[recurringrule.FieldValidUntil] = struct{}{}
}

// ValidUntilCleared returns if the "valid_until" field was cleared in this mutation.
func (m *RecurringRuleMutation) ValidUntilCleared() bool {
	_, ok := m.clearedFields[recurringrule.FieldValidUntil]
	return ok
}

// ResetValidUntil resets all changes to the "valid_until" field.
func (m *RecurringRuleMutation) ResetValidUntil() {
	m.valid_until = nil
	delete(m.clearedFields, recurringrule.FieldValidUntil)
}

// SetIsActive sets the "is_active" field.
func (m *RecurringRuleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *RecurringRuleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the RecurringRule entity.
// If the RecurringRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringRuleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *RecurringRuleMutation) ResetIsActive() {
	m.is_active = nil
}

// Where appends a list predicates to the RecurringRuleMutation builder.
func (m *RecurringRuleMutation) Where(ps ...predicate.RecurringRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecurringRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecurringRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecurringRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecurringRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecurringRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecurringRule).
func (m *RecurringRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecurringRuleMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, recurringrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recurringrule.FieldUpdatedAt)
	}
	if m.therapist_id != nil {
		fields = append(fields, recurringrule.FieldTherapistID)
	}
	if m.clinic_id != nil {
		fields = append(fields, recurringrule.FieldClinicID)
	}
	if m.day_of_week != nil {
		fields = append(fields, recurringrule.FieldDayOfWeek)
	}
	if m.start_hour != nil {
		fields = append(fields, recurringrule.FieldStartHour)
	}
	if m.start_minute != nil {
		fields = append(fields, recurringrule.FieldStartMinute)
	}
	if m.end_hour != nil {
		fields = append(fields, recurringrule.FieldEndHour)
	}
	if m.end_minute != nil {
		fields = append(fields, recurringrule.FieldEndMinute)
	}
	if m.session_price != nil {
		fields = append(fields, recurringrule.FieldSessionPrice)
	}
	if m.reservation_fee != nil {
		fields = append(fields, recurringrule.FieldReservationFee)
	}
	if m.valid_from != nil {
		fields = append(fields, recurringrule.FieldValidFrom)
	}
	if m.valid_until != nil {
		fields = append(fields, recurringrule.FieldValidUntil)
	}
	if m.is_active != nil {
		fields = append(fields, recurringrule.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecurringRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recurringrule.FieldCreatedAt:
		return m.CreatedAt()
	case recurringrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case recurringrule.FieldTherapistID:
		return m.TherapistID()
	case recurringrule.FieldClinicID:
		return m.ClinicID()
	case recurringrule.FieldDayOfWeek:
		return m.DayOfWeek()
	case recurringrule.FieldStartHour:
		return m.StartHour()
	case recurringrule.FieldStartMinute:
		return m.StartMinute()
	case recurringrule.FieldEndHour:
		return m.EndHour()
	case recurringrule.FieldEndMinute:
		return m.EndMinute()
	case recurringrule.FieldSessionPrice:
		return m.SessionPrice()
	case recurringrule.FieldReservationFee:
		return m.ReservationFee()
	case recurringrule.FieldValidFrom:
		return m.ValidFrom()
	case recurringrule.FieldValidUntil:
		return m.ValidUntil()
	case recurringrule.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecurringRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recurringrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recurringrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recurringrule.FieldTherapistID:
		return m.OldTherapistID(ctx)
	case recurringrule.FieldClinicID:
		return m.OldClinicID(ctx)
	case recurringrule.FieldDayOfWeek:
		return m.OldDayOfWeek(ctx)
	case recurringrule.FieldStartHour:
		return m.OldStartHour(ctx)
	case recurringrule.FieldStartMinute:
		return m.OldStartMinute(ctx)
	case recurringrule.FieldEndHour:
		return m.OldEndHour(ctx)
	case recurringrule.FieldEndMinute:
		return m.OldEndMinute(ctx)
	case recurringrule.FieldSessionPrice:
		return m.OldSessionPrice(ctx)
	case recurringrule.FieldReservationFee:
		return m.OldReservationFee(ctx)
	case recurringrule.FieldValidFrom:
		return m.OldValidFrom(ctx)
	case recurringrule.FieldValidUntil:
		return m.OldValidUntil(ctx)
	case recurringrule.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown RecurringRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recurringrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recurringrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recurringrule.FieldTherapistID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTherapistID(v)
		return nil
	case recurringrule.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case recurringrule.FieldDayOfWeek:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOfWeek(v)
		return nil
	case recurringrule.FieldStartHour:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartHour(v)
		return nil
	case recurringrule.FieldStartMinute:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMinute(v)
		return nil
	case recurringrule.FieldEndHour:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndHour(v)
		return nil
	case recurringrule.FieldEndMinute:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndMinute(v)
		return nil
	case recurringrule.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionPrice(v)
		return nil
	case recurringrule.FieldReservationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationFee(v)
		return nil
	case recurringrule.FieldValidFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidFrom(v)
		return nil
	case recurringrule.FieldValidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidUntil(v)
		return nil
	case recurringrule.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown RecurringRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecurringRuleMutation) AddedFields() []string {
	var fields []string
	if m.addday_of_week != nil {
		fields = append(fields, recurringrule.FieldDayOfWeek)
	}
	if m.addstart_hour != nil {
		fields = append(fields, recurringrule.FieldStartHour)
	}
	if m.addstart_minute != nil {
		fields = append(fields, recurringrule.FieldStartMinute)
	}
	if m.addend_hour != nil {
		fields = append(fields, recurringrule.FieldEndHour)
	}
	if m.addend_minute != nil {
		fields = append(fields, recurringrule.FieldEndMinute)
	}
	if m.addsession_price != nil {
		fields = append(fields, recurringrule.FieldSessionPrice)
	}
	if m.addreservation_fee != nil {
		fields = append(fields, recurringrule.FieldReservationFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecurringRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recurringrule.FieldDayOfWeek:
		return m.AddedDayOfWeek()
	case recurringrule.FieldStartHour:
		return m.AddedStartHour()
	case recurringrule.FieldStartMinute:
		return m.AddedStartMinute()
	case recurringrule.FieldEndHour:
		return m.AddedEndHour()
	case recurringrule.FieldEndMinute:
		return m.AddedEndMinute()
	case recurringrule.FieldSessionPrice:
		return m.AddedSessionPrice()
	case recurringrule.FieldReservationFee:
		return m.AddedReservationFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recurringrule.FieldDayOfWeek:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayOfWeek(v)
		return nil
	case recurringrule.FieldStartHour:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartHour(v)
		return nil
	case recurringrule.FieldStartMinute:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartMinute(v)
		return nil
	case recurringrule.FieldEndHour:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndHour(v)
		return nil
	case recurringrule.FieldEndMinute:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndMinute(v)
		return nil
	case recurringrule.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionPrice(v)
		return nil
	case recurringrule.FieldReservationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationFee(v)
		return nil
	}
	return fmt.Errorf("unknown RecurringRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecurringRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recurringrule.FieldSessionPrice) {
		fields = append(fields, recurringrule.FieldSessionPrice)
	}
	if m.FieldCleared(recurringrule.FieldReservationFee) {
		fields = append(fields, recurringrule.FieldReservationFee)
	}
	if m.FieldCleared(recurringrule.FieldValidUntil) {
		fields = append(fields, recurringrule.FieldValidUntil)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecurringRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecurringRuleMutation) ClearField(name string) error {
	switch name {
	case recurringrule.FieldSessionPrice:
		m.ClearSessionPrice()
		return nil
	case recurringrule.FieldReservationFee:
		m.ClearReservationFee()
		return nil
	case recurringrule.FieldValidUntil:
		m.ClearValidUntil()
		return nil
	}
	return fmt.Errorf("unknown RecurringRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecurringRuleMutation) ResetField(name string) error {
	switch name {
	case recurringrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recurringrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recurringrule.FieldTherapistID:
		m.ResetTherapistID()
		return nil
	case recurringrule.FieldClinicID:
		m.ResetClinicID()
		return nil
	case recurringrule.FieldDayOfWeek:
		m.ResetDayOfWeek()
		return nil
	case recurringrule.FieldStartHour:
		m.ResetStartHour()
		return nil
	case recurringrule.FieldStartMinute:
		m.ResetStartMinute()
		return nil
	case recurringrule.FieldEndHour:
		m.ResetEndHour()
		return nil
	case recurringrule.FieldEndMinute:
		m.ResetEndMinute()
		return nil
	case recurringrule.FieldSessionPrice:
		m.ResetSessionPrice()
		return nil
	case recurringrule.FieldReservationFee:
		m.ResetReservationFee()
		return nil
	case recurringrule.FieldValidFrom:
		m.ResetValidFrom()
		return nil
	case recurringrule.FieldValidUntil:
		m.ResetValidUntil()
		return nil
	case recurringrule.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown RecurringRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecurringRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecurringRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecurringRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecurringRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecurringRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecurringRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecurringRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RecurringRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecurringRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RecurringRule edge %s", name)
}

// TherapistProfileMutation represents an operation that mutates the TherapistProfile nodes in the graph.
type TherapistProfileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	education               *string
	psychology_license      *string
	approach                *string
	specialties             *[]string
	appendspecialties       []string
	bio                     *string
	rating                  *float64
	addrating               *float64
	session_price           *int64
	addsession_price        *int64
	session_duration_min    *int
	addsession_duration_min *int
	is_accepting            *bool
	clearedFields           map[string]struct{}
	member                  *uuid.UUID
	clearedmember           bool
	done                    bool
	oldValue                func(context.Context) (*TherapistProfile, error)
	predicates              []predicate.TherapistProfile
}

var _ ent.Mutation = (*TherapistProfileMutation)(nil)

// therapistprofileOption allows management of the mutation configuration using functional options.
type therapistprofileOption func(*TherapistProfileMutation)

// newTherapistProfileMutation creates new mutation for the TherapistProfile entity.
func newTherapistProfileMutation(c config, op Op, opts ...therapistprofileOption) *TherapistProfileMutation {
	m := &TherapistProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeTherapistProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTherapistProfileID sets the ID field of the mutation.
func withTherapistProfileID(id uuid.UUID) therapistprofileOption {
	return func(m *TherapistProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *TherapistProfile
		)
		m.oldValue = func(ctx context.Context) (*TherapistProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TherapistProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTherapistProfile sets the old TherapistProfile of the mutation.
func withTherapistProfile(node *TherapistProfile) therapistprofileOption {
	return func(m *TherapistProfileMutation) {
		m.oldValue = func(context.Context) (*TherapistProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TherapistProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TherapistProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TherapistProfile entities.
func (m *TherapistProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TherapistProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TherapistProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TherapistProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TherapistProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TherapistProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TherapistProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TherapistProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TherapistProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TherapistProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicMemberID sets the "clinic_member_id" field.
func (m *TherapistProfileMutation) SetClinicMemberID(u uuid.UUID) {
	m.member = &u
}

// ClinicMemberID returns the value of the "clinic_member_id" field in the mutation.
func (m *TherapistProfileMutation) ClinicMemberID() (r uuid.UUID, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicMemberID returns the old "clinic_member_id" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldClinicMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicMemberID: %w", err)
	}
	return oldValue.ClinicMemberID, nil
}

// ResetClinicMemberID resets all changes to the "clinic_member_id" field.
func (m *TherapistProfileMutation) ResetClinicMemberID() {
	m.member = nil
}

// SetEducation sets the "education" field.
func (m *TherapistProfileMutation) SetEducation(s string) {
	m.education = &s
}

// Education returns the value of the "education" field in the mutation.
func (m *TherapistProfileMutation) Education() (r string, exists bool) {
	v := m.education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old "education" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldEducation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ClearEducation clears the value of the "education" field.
func (m *TherapistProfileMutation) ClearEducation() {
	m.education = nil
	m.clearedFields[therapistprofile.FieldEducation] = struct{}{}
}

// EducationCleared returns if the "education" field was cleared in this mutation.
func (m *TherapistProfileMutation) EducationCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldEducation]
	return ok
}

// ResetEducation resets all changes to the "education" field.
func (m *TherapistProfileMutation) ResetEducation() {
	m.education = nil
	delete(m.clearedFields, therapistprofile.FieldEducation)
}

// SetPsychologyLicense sets the "psychology_license" field.
func (m *TherapistProfileMutation) SetPsychologyLicense(s string) {
	m.psychology_license = &s
}

// PsychologyLicense returns the value of the "psychology_license" field in the mutation.
func (m *TherapistProfileMutation) PsychologyLicense() (r string, exists bool) {
	v := m.psychology_license
	if v == nil {
		return
	}
	return *v, true
}

// OldPsychologyLicense returns the old "psychology_license" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldPsychologyLicense(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPsychologyLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPsychologyLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPsychologyLicense: %w", err)
	}
	return oldValue.PsychologyLicense, nil
}

// ClearPsychologyLicense clears the value of the "psychology_license" field.
func (m *TherapistProfileMutation) ClearPsychologyLicense() {
	m.psychology_license = nil
	m.clearedFields[therapistprofile.FieldPsychologyLicense] = struct{}{}
}

// PsychologyLicenseCleared returns if the "psychology_license" field was cleared in this mutation.
func (m *TherapistProfileMutation) PsychologyLicenseCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldPsychologyLicense]
	return ok
}

// ResetPsychologyLicense resets all changes to the "psychology_license" field.
func (m *TherapistProfileMutation) ResetPsychologyLicense() {
	m.psychology_license = nil
	delete(m.clearedFields, therapistprofile.FieldPsychologyLicense)
}

// SetApproach sets the "approach" field.
func (m *TherapistProfileMutation) SetApproach(s string) {
	m.approach = &s
}

// Approach returns the value of the "approach" field in the mutation.
func (m *TherapistProfileMutation) Approach() (r string, exists bool) {
	v := m.approach
	if v == nil {
		return
	}
	return *v, true
}

// OldApproach returns the old "approach" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldApproach(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproach is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproach requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproach: %w", err)
	}
	return oldValue.Approach, nil
}

// ClearApproach clears the value of the "approach" field.
func (m *TherapistProfileMutation) ClearApproach() {
	m.approach = nil
	m.clearedFields[therapistprofile.FieldApproach] = struct{}{}
}

// ApproachCleared returns if the "approach" field was cleared in this mutation.
func (m *TherapistProfileMutation) ApproachCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldApproach]
	return ok
}

// ResetApproach resets all changes to the "approach" field.
func (m *TherapistProfileMutation) ResetApproach() {
	m.approach = nil
	delete(m.clearedFields, therapistprofile.FieldApproach)
}

// SetSpecialties sets the "specialties" field.
func (m *TherapistProfileMutation) SetSpecialties(s []string) {
	m.specialties = &s
	m.appendspecialties = nil
}

// Specialties returns the value of the "specialties" field in the mutation.
func (m *TherapistProfileMutation) Specialties() (r []string, exists bool) {
	v := m.specialties
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialties returns the old "specialties" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldSpecialties(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialties: %w", err)
	}
	return oldValue.Specialties, nil
}

// AppendSpecialties adds s to the "specialties" field.
func (m *TherapistProfileMutation) AppendSpecialties(s []string) {
	m.appendspecialties = append(m.appendspecialties, s...)
}

// AppendedSpecialties returns the list of values that were appended to the "specialties" field in this mutation.
func (m *TherapistProfileMutation) AppendedSpecialties() ([]string, bool) {
	if len(m.appendspecialties) == 0 {
		return nil, false
	}
	return m.appendspecialties, true
}

// ClearSpecialties clears the value of the "specialties" field.
func (m *TherapistProfileMutation) ClearSpecialties() {
	m.specialties = nil
	m.appendspecialties = nil
	m.clearedFields[therapistprofile.FieldSpecialties] = struct{}{}
}

// SpecialtiesCleared returns if the "specialties" field was cleared in this mutation.
func (m *TherapistProfileMutation) SpecialtiesCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldSpecialties]
	return ok
}

// ResetSpecialties resets all changes to the "specialties" field.
func (m *TherapistProfileMutation) ResetSpecialties() {
	m.specialties = nil
	m.appendspecialties = nil
	delete(m.clearedFields, therapistprofile.FieldSpecialties)
}

// SetBio sets the "bio" field.
func (m *TherapistProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *TherapistProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldBio(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *TherapistProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[therapistprofile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *TherapistProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *TherapistProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, therapistprofile.FieldBio)
}

// SetRating sets the "rating" field.
func (m *TherapistProfileMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *TherapistProfileMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *TherapistProfileMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *TherapistProfileMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *TherapistProfileMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetSessionPrice sets the "session_price" field.
func (m *TherapistProfileMutation) SetSessionPrice(i int64) {
	m.session_price = &i
	m.addsession_price = nil
}

// SessionPrice returns the value of the "session_price" field in the mutation.
func (m *TherapistProfileMutation) SessionPrice() (r int64, exists bool) {
	v := m.session_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionPrice returns the old "session_price" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldSessionPrice(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionPrice: %w", err)
	}
	return oldValue.SessionPrice, nil
}

// AddSessionPrice adds i to the "session_price" field.
func (m *TherapistProfileMutation) AddSessionPrice(i int64) {
	if m.addsession_price != nil {
		*m.addsession_price += i
	} else {
		m.addsession_price = &i
	}
}

// AddedSessionPrice returns the value that was added to the "session_price" field in this mutation.
func (m *TherapistProfileMutation) AddedSessionPrice() (r int64, exists bool) {
	v := m.addsession_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearSessionPrice clears the value of the "session_price" field.
func (m *TherapistProfileMutation) ClearSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
	m.clearedFields[therapistprofile.FieldSessionPrice] = struct{}{}
}

// SessionPriceCleared returns if the "session_price" field was cleared in this mutation.
func (m *TherapistProfileMutation) SessionPriceCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldSessionPrice]
	return ok
}

// ResetSessionPrice resets all changes to the "session_price" field.
func (m *TherapistProfileMutation) ResetSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
	delete(m.clearedFields, therapistprofile.FieldSessionPrice)
}

// SetSessionDurationMin sets the "session_duration_min" field.
func (m *TherapistProfileMutation) SetSessionDurationMin(i int) {
	m.session_duration_min = &i
	m.addsession_duration_min = nil
}

// SessionDurationMin returns the value of the "session_duration_min" field in the mutation.
func (m *TherapistProfileMutation) SessionDurationMin() (r int, exists bool) {
	v := m.session_duration_min
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionDurationMin returns the old "session_duration_min" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldSessionDurationMin(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionDurationMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionDurationMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionDurationMin: %w", err)
	}
	return oldValue.SessionDurationMin, nil
}

// AddSessionDurationMin adds i to the "session_duration_min" field.
func (m *TherapistProfileMutation) AddSessionDurationMin(i int) {
	if m.addsession_duration_min != nil {
		*m.addsession_duration_min += i
	} else {
		m.addsession_duration_min = &i
	}
}

// AddedSessionDurationMin returns the value that was added to the "session_duration_min" field in this mutation.
func (m *TherapistProfileMutation) AddedSessionDurationMin() (r int, exists bool) {
	v := m.addsession_duration_min
	if v == nil {
		return
	}
	return *v, true
}

// ClearSessionDurationMin clears the value of the "session_duration_min" field.
func (m *TherapistProfileMutation) ClearSessionDurationMin() {
	m.session_duration_min = nil
	m.addsession_duration_min = nil
	m.clearedFields[therapistprofile.FieldSessionDurationMin] = struct{}{}
}

// SessionDurationMinCleared returns if the "session_duration_min" field was cleared in this mutation.
func (m *TherapistProfileMutation) SessionDurationMinCleared() bool {
	_, ok := m.clearedFields[therapistprofile.FieldSessionDurationMin]
	return ok
}

// ResetSessionDurationMin resets all changes to the "session_duration_min" field.
func (m *TherapistProfileMutation) ResetSessionDurationMin() {
	m.session_duration_min = nil
	m.addsession_duration_min = nil
	delete(m.clearedFields, therapistprofile.FieldSessionDurationMin)
}

// SetIsAccepting sets the "is_accepting" field.
func (m *TherapistProfileMutation) SetIsAccepting(b bool) {
	m.is_accepting = &b
}

// IsAccepting returns the value of the "is_accepting" field in the mutation.
func (m *TherapistProfileMutation) IsAccepting() (r bool, exists bool) {
	v := m.is_accepting
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAccepting returns the old "is_accepting" field's value of the TherapistProfile entity.
// If the TherapistProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TherapistProfileMutation) OldIsAccepting(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAccepting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAccepting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAccepting: %w", err)
	}
	return oldValue.IsAccepting, nil
}

// ResetIsAccepting resets all changes to the "is_accepting" field.
func (m *TherapistProfileMutation) ResetIsAccepting() {
	m.is_accepting = nil
}

// SetMemberID sets the "member" edge to the ClinicMember entity by id.
func (m *TherapistProfileMutation) SetMemberID(id uuid.UUID) {
	m.member = &id
}

// ClearMember clears the "member" edge to the ClinicMember entity.
func (m *TherapistProfileMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[therapistprofile.FieldClinicMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the ClinicMember entity was cleared.
func (m *TherapistProfileMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberID returns the "member" edge ID in the mutation.
func (m *TherapistProfileMutation) MemberID() (id uuid.UUID, exists bool) {
	if m.member != nil {
		return *m.member, true
	}
	return
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *TherapistProfileMutation) MemberIDs() (ids []uuid.UUID) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *TherapistProfileMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// Where appends a list predicates to the TherapistProfileMutation builder.
func (m *TherapistProfileMutation) Where(ps ...predicate.TherapistProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TherapistProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TherapistProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TherapistProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TherapistProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TherapistProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TherapistProfile).
func (m *TherapistProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TherapistProfileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, therapistprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, therapistprofile.FieldUpdatedAt)
	}
	if m.member != nil {
		fields = append(fields, therapistprofile.FieldClinicMemberID)
	}
	if m.education != nil {
		fields = append(fields, therapistprofile.FieldEducation)
	}
	if m.psychology_license != nil {
		fields = append(fields, therapistprofile.FieldPsychologyLicense)
	}
	if m.approach != nil {
		fields = append(fields, therapistprofile.FieldApproach)
	}
	if m.specialties != nil {
		fields = append(fields, therapistprofile.FieldSpecialties)
	}
	if m.bio != nil {
		fields = append(fields, therapistprofile.FieldBio)
	}
	if m.rating != nil {
		fields = append(fields, therapistprofile.FieldRating)
	}
	if m.session_price != nil {
		fields = append(fields, therapistprofile.FieldSessionPrice)
	}
	if m.session_duration_min != nil {
		fields = append(fields, therapistprofile.FieldSessionDurationMin)
	}
	if m.is_accepting != nil {
		fields = append(fields, therapistprofile.FieldIsAccepting)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TherapistProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case therapistprofile.FieldCreatedAt:
		return m.CreatedAt()
	case therapistprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case therapistprofile.FieldClinicMemberID:
		return m.ClinicMemberID()
	case therapistprofile.FieldEducation:
		return m.Education()
	case therapistprofile.FieldPsychologyLicense:
		return m.PsychologyLicense()
	case therapistprofile.FieldApproach:
		return m.Approach()
	case therapistprofile.FieldSpecialties:
		return m.Specialties()
	case therapistprofile.FieldBio:
		return m.Bio()
	case therapistprofile.FieldRating:
		return m.Rating()
	case therapistprofile.FieldSessionPrice:
		return m.SessionPrice()
	case therapistprofile.FieldSessionDurationMin:
		return m.SessionDurationMin()
	case therapistprofile.FieldIsAccepting:
		return m.IsAccepting()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TherapistProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case therapistprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case therapistprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case therapistprofile.FieldClinicMemberID:
		return m.OldClinicMemberID(ctx)
	case therapistprofile.FieldEducation:
		return m.OldEducation(ctx)
	case therapistprofile.FieldPsychologyLicense:
		return m.OldPsychologyLicense(ctx)
	case therapistprofile.FieldApproach:
		return m.OldApproach(ctx)
	case therapistprofile.FieldSpecialties:
		return m.OldSpecialties(ctx)
	case therapistprofile.FieldBio:
		return m.OldBio(ctx)
	case therapistprofile.FieldRating:
		return m.OldRating(ctx)
	case therapistprofile.FieldSessionPrice:
		return m.OldSessionPrice(ctx)
	case therapistprofile.FieldSessionDurationMin:
		return m.OldSessionDurationMin(ctx)
	case therapistprofile.FieldIsAccepting:
		return m.OldIsAccepting(ctx)
	}
	return nil, fmt.Errorf("unknown TherapistProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TherapistProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case therapistprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case therapistprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case therapistprofile.FieldClinicMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicMemberID(v)
		return nil
	case therapistprofile.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case therapistprofile.FieldPsychologyLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPsychologyLicense(v)
		return nil
	case therapistprofile.FieldApproach:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproach(v)
		return nil
	case therapistprofile.FieldSpecialties:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialties(v)
		return nil
	case therapistprofile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case therapistprofile.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case therapistprofile.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionPrice(v)
		return nil
	case therapistprofile.FieldSessionDurationMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionDurationMin(v)
		return nil
	case therapistprofile.FieldIsAccepting:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAccepting(v)
		return nil
	}
	return fmt.Errorf("unknown TherapistProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TherapistProfileMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, therapistprofile.FieldRating)
	}
	if m.addsession_price != nil {
		fields = append(fields, therapistprofile.FieldSessionPrice)
	}
	if m.addsession_duration_min != nil {
		fields = append(fields, therapistprofile.FieldSessionDurationMin)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TherapistProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case therapistprofile.FieldRating:
		return m.AddedRating()
	case therapistprofile.FieldSessionPrice:
		return m.AddedSessionPrice()
	case therapistprofile.FieldSessionDurationMin:
		return m.AddedSessionDurationMin()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TherapistProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case therapistprofile.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case therapistprofile.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionPrice(v)
		return nil
	case therapistprofile.FieldSessionDurationMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionDurationMin(v)
		return nil
	}
	return fmt.Errorf("unknown TherapistProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TherapistProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(therapistprofile.FieldEducation) {
		fields = append(fields, therapistprofile.FieldEducation)
	}
	if m.FieldCleared(therapistprofile.FieldPsychologyLicense) {
		fields = append(fields, therapistprofile.FieldPsychologyLicense)
	}
	if m.FieldCleared(therapistprofile.FieldApproach) {
		fields = append(fields, therapistprofile.FieldApproach)
	}
	if m.FieldCleared(therapistprofile.FieldSpecialties) {
		fields = append(fields, therapistprofile.FieldSpecialties)
	}
	if m.FieldCleared(therapistprofile.FieldBio) {
		fields = append(fields, therapistprofile.FieldBio)
	}
	if m.FieldCleared(therapistprofile.FieldSessionPrice) {
		fields = append(fields, therapistprofile.FieldSessionPrice)
	}
	if m.FieldCleared(therapistprofile.FieldSessionDurationMin) {
		fields = append(fields, therapistprofile.FieldSessionDurationMin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TherapistProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TherapistProfileMutation) ClearField(name string) error {
	switch name {
	case therapistprofile.FieldEducation:
		m.ClearEducation()
		return nil
	case therapistprofile.FieldPsychologyLicense:
		m.ClearPsychologyLicense()
		return nil
	case therapistprofile.FieldApproach:
		m.ClearApproach()
		return nil
	case therapistprofile.FieldSpecialties:
		m.ClearSpecialties()
		return nil
	case therapistprofile.FieldBio:
		m.ClearBio()
		return nil
	case therapistprofile.FieldSessionPrice:
		m.ClearSessionPrice()
		return nil
	case therapistprofile.FieldSessionDurationMin:
		m.ClearSessionDurationMin()
		return nil
	}
	return fmt.Errorf("unknown TherapistProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TherapistProfileMutation) ResetField(name string) error {
	switch name {
	case therapistprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case therapistprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case therapistprofile.FieldClinicMemberID:
		m.ResetClinicMemberID()
		return nil
	case therapistprofile.FieldEducation:
		m.ResetEducation()
		return nil
	case therapistprofile.FieldPsychologyLicense:
		m.ResetPsychologyLicense()
		return nil
	case therapistprofile.FieldApproach:
		m.ResetApproach()
		return nil
	case therapistprofile.FieldSpecialties:
		m.ResetSpecialties()
		return nil
	case therapistprofile.FieldBio:
		m.ResetBio()
		return nil
	case therapistprofile.FieldRating:
		m.ResetRating()
		return nil
	case therapistprofile.FieldSessionPrice:
		m.ResetSessionPrice()
		return nil
	case therapistprofile.FieldSessionDurationMin:
		m.ResetSessionDurationMin()
		return nil
	case therapistprofile.FieldIsAccepting:
		m.ResetIsAccepting()
		return nil
	}
	return fmt.Errorf("unknown TherapistProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TherapistProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member != nil {
		edges = append(edges, therapistprofile.EdgeMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TherapistProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case therapistprofile.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TherapistProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TherapistProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TherapistProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmember {
		edges = append(edges, therapistprofile.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TherapistProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case therapistprofile.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TherapistProfileMutation) ClearEdge(name string) error {
	switch name {
	case therapistprofile.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown TherapistProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TherapistProfileMutation) ResetEdge(name string) error {
	switch name {
	case therapistprofile.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown TherapistProfile edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	clinic_id     *uuid.UUID
	user_id       *uuid.UUID
	subject       *string
	status        *ticket.Status
	priority      *ticket.Priority
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Ticket, error)
	predicates    []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id uuid.UUID) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticket entities.
func (m *TicketMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *TicketMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *TicketMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldClinicID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ClearClinicID clears the value of the "clinic_id" field.
func (m *TicketMutation) ClearClinicID() {
	m.clinic_id = nil
	m.clearedFields[ticket.FieldClinicID] = struct{}{}
}

// ClinicIDCleared returns if the "clinic_id" field was cleared in this mutation.
func (m *TicketMutation) ClinicIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldClinicID]
	return ok
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *TicketMutation) ResetClinicID() {
	m.clinic_id = nil
	delete(m.clearedFields, ticket.FieldClinicID)
}

// SetUserID sets the "user_id" field.
func (m *TicketMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TicketMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TicketMutation) ResetUserID() {
	m.user_id = nil
}

// SetSubject sets the "subject" field.
func (m *TicketMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *TicketMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *TicketMutation) ResetSubject() {
	m.subject = nil
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(t ticket.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r ticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v ticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TicketMutation) SetPriority(t ticket.Priority) {
	m.priority = &t
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketMutation) Priority() (r ticket.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPriority(ctx context.Context) (v ticket.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketMutation) ResetPriority() {
	m.priority = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	if m.clinic_id != nil {
		fields = append(fields, ticket.FieldClinicID)
	}
	if m.user_id != nil {
		fields = append(fields, ticket.FieldUserID)
	}
	if m.subject != nil {
		fields = append(fields, ticket.FieldSubject)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, ticket.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	case ticket.FieldClinicID:
		return m.ClinicID()
	case ticket.FieldUserID:
		return m.UserID()
	case ticket.FieldSubject:
		return m.Subject()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ticket.FieldClinicID:
		return m.OldClinicID(ctx)
	case ticket.FieldUserID:
		return m.OldUserID(ctx)
	case ticket.FieldSubject:
		return m.OldSubject(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ticket.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case ticket.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ticket.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(ticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldPriority:
		v, ok := value.(ticket.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldClinicID) {
		fields = append(fields, ticket.FieldClinicID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldClinicID:
		m.ClearClinicID()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ticket.FieldClinicID:
		m.ResetClinicID()
		return nil
	case ticket.FieldUserID:
		m.ResetUserID()
		return nil
	case ticket.FieldSubject:
		m.ResetSubject()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TicketMessageMutation represents an operation that mutates the TicketMessage nodes in the graph.
type TicketMessageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	ticket_id     *uuid.UUID
	sender_id     *uuid.UUID
	content       *string
	file_key      *string
	file_name     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TicketMessage, error)
	predicates    []predicate.TicketMessage
}

var _ ent.Mutation = (*TicketMessageMutation)(nil)

// ticketmessageOption allows management of the mutation configuration using functional options.
type ticketmessageOption func(*TicketMessageMutation)

// newTicketMessageMutation creates new mutation for the TicketMessage entity.
func newTicketMessageMutation(c config, op Op, opts ...ticketmessageOption) *TicketMessageMutation {
	m := &TicketMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeTicketMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketMessageID sets the ID field of the mutation.
func withTicketMessageID(id uuid.UUID) ticketmessageOption {
	return func(m *TicketMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *TicketMessage
		)
		m.oldValue = func(ctx context.Context) (*TicketMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TicketMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicketMessage sets the old TicketMessage of the mutation.
func withTicketMessage(node *TicketMessage) ticketmessageOption {
	return func(m *TicketMessageMutation) {
		m.oldValue = func(context.Context) (*TicketMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TicketMessage entities.
func (m *TicketMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TicketMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TicketMessage entity.
// If the TicketMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTicketID sets the "ticket_id" field.
func (m *TicketMessageMutation) SetTicketID(u uuid.UUID) {
	m.ticket_id = &u
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *TicketMessageMutation) TicketID() (r uuid.UUID, exists bool) {
	v := m.ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the TicketMessage entity.
// If the TicketMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMessageMutation) OldTicketID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *TicketMessageMutation) ResetTicketID() {
	m.ticket_id = nil
}

// SetSenderID sets the "sender_id" field.
func (m *TicketMessageMutation) SetSenderID(u uuid.UUID) {
	m.sender_id = &u
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *TicketMessageMutation) SenderID() (r uuid.UUID, exists bool) {
	v := m.sender_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the TicketMessage entity.
// If the TicketMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMessageMutation) OldSenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *TicketMessageMutation) ResetSenderID() {
	m.sender_id = nil
}

// SetContent sets the "content" field.
func (m *TicketMessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TicketMessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TicketMessage entity.
// If the TicketMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TicketMessageMutation) ResetContent() {
	m.content = nil
}

// SetFileKey sets the "file_key" field.
func (m *TicketMessageMutation) SetFileKey(s string) {
	m.file_key = &s
}

// FileKey returns the value of the "file_key" field in the mutation.
func (m *TicketMessageMutation) FileKey() (r string, exists bool) {
	v := m.file_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFileKey returns the old "file_key" field's value of the TicketMessage entity.
// If the TicketMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMessageMutation) OldFileKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileKey: %w", err)
	}
	return oldValue.FileKey, nil
}

// ClearFileKey clears the value of the "file_key" field.
func (m *TicketMessageMutation) ClearFileKey() {
	m.file_key = nil
	m.clearedFields[ticketmessage.FieldFileKey] = struct{}{}
}

// FileKeyCleared returns if the "file_key" field was cleared in this mutation.
func (m *TicketMessageMutation) FileKeyCleared() bool {
	_, ok := m.clearedFields[ticketmessage.FieldFileKey]
	return ok
}

// ResetFileKey resets all changes to the "file_key" field.
func (m *TicketMessageMutation) ResetFileKey() {
	m.file_key = nil
	delete(m.clearedFields, ticketmessage.FieldFileKey)
}

// SetFileName sets the "file_name" field.
func (m *TicketMessageMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *TicketMessageMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the TicketMessage entity.
// If the TicketMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMessageMutation) OldFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "file_name" field.
func (m *TicketMessageMutation) ClearFileName() {
	m.file_name = nil
	m.clearedFields[ticketmessage.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "file_name" field was cleared in this mutation.
func (m *TicketMessageMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[ticketmessage.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "file_name" field.
func (m *TicketMessageMutation) ResetFileName() {
	m.file_name = nil
	delete(m.clearedFields, ticketmessage.FieldFileName)
}

// Where appends a list predicates to the TicketMessageMutation builder.
func (m *TicketMessageMutation) Where(ps ...predicate.TicketMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TicketMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TicketMessage).
func (m *TicketMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMessageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, ticketmessage.FieldCreatedAt)
	}
	if m.ticket_id != nil {
		fields = append(fields, ticketmessage.FieldTicketID)
	}
	if m.sender_id != nil {
		fields = append(fields, ticketmessage.FieldSenderID)
	}
	if m.content != nil {
		fields = append(fields, ticketmessage.FieldContent)
	}
	if m.file_key != nil {
		fields = append(fields, ticketmessage.FieldFileKey)
	}
	if m.file_name != nil {
		fields = append(fields, ticketmessage.FieldFileName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticketmessage.FieldCreatedAt:
		return m.CreatedAt()
	case ticketmessage.FieldTicketID:
		return m.TicketID()
	case ticketmessage.FieldSenderID:
		return m.SenderID()
	case ticketmessage.FieldContent:
		return m.Content()
	case ticketmessage.FieldFileKey:
		return m.FileKey()
	case ticketmessage.FieldFileName:
		return m.FileName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticketmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticketmessage.FieldTicketID:
		return m.OldTicketID(ctx)
	case ticketmessage.FieldSenderID:
		return m.OldSenderID(ctx)
	case ticketmessage.FieldContent:
		return m.OldContent(ctx)
	case ticketmessage.FieldFileKey:
		return m.OldFileKey(ctx)
	case ticketmessage.FieldFileName:
		return m.OldFileName(ctx)
	}
	return nil, fmt.Errorf("unknown TicketMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticketmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticketmessage.FieldTicketID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case ticketmessage.FieldSenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case ticketmessage.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case ticketmessage.FieldFileKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileKey(v)
		return nil
	case ticketmessage.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	}
	return fmt.Errorf("unknown TicketMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TicketMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticketmessage.FieldFileKey) {
		fields = append(fields, ticketmessage.FieldFileKey)
	}
	if m.FieldCleared(ticketmessage.FieldFileName) {
		fields = append(fields, ticketmessage.FieldFileName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMessageMutation) ClearField(name string) error {
	switch name {
	case ticketmessage.FieldFileKey:
		m.ClearFileKey()
		return nil
	case ticketmessage.FieldFileName:
		m.ClearFileName()
		return nil
	}
	return fmt.Errorf("unknown TicketMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMessageMutation) ResetField(name string) error {
	switch name {
	case ticketmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticketmessage.FieldTicketID:
		m.ResetTicketID()
		return nil
	case ticketmessage.FieldSenderID:
		m.ResetSenderID()
		return nil
	case ticketmessage.FieldContent:
		m.ResetContent()
		return nil
	case ticketmessage.FieldFileKey:
		m.ResetFileKey()
		return nil
	case ticketmessage.FieldFileName:
		m.ResetFileName()
		return nil
	}
	return fmt.Errorf("unknown TicketMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TicketMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TicketMessage edge %s", name)
}

// TimeSlotMutation represents an operation that mutates the TimeSlot nodes in the graph.
type TimeSlotMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	therapist_id       *uuid.UUID
	clinic_id          *uuid.UUID
	start_time         *time.Time
	end_time           *time.Time
	status             *timeslot.Status
	session_price      *int64
	addsession_price   *int64
	reservation_fee    *int64
	addreservation_fee *int64
	is_recurring       *bool
	recurring_rule_id  *uuid.UUID
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*TimeSlot, error)
	predicates         []predicate.TimeSlot
}

var _ ent.Mutation = (*TimeSlotMutation)(nil)

// timeslotOption allows management of the mutation configuration using functional options.
type timeslotOption func(*TimeSlotMutation)

// newTimeSlotMutation creates new mutation for the TimeSlot entity.
func newTimeSlotMutation(c config, op Op, opts ...timeslotOption) *TimeSlotMutation {
	m := &TimeSlotMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeSlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeSlotID sets the ID field of the mutation.
func withTimeSlotID(id uuid.UUID) timeslotOption {
	return func(m *TimeSlotMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeSlot
		)
		m.oldValue = func(ctx context.Context) (*TimeSlot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeSlot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeSlot sets the old TimeSlot of the mutation.
func withTimeSlot(node *TimeSlot) timeslotOption {
	return func(m *TimeSlotMutation) {
		m.oldValue = func(context.Context) (*TimeSlot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeSlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeSlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TimeSlot entities.
func (m *TimeSlotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeSlotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeSlotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeSlot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeSlotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeSlotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeSlotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeSlotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeSlotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeSlotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTherapistID sets the "therapist_id" field.
func (m *TimeSlotMutation) SetTherapistID(u uuid.UUID) {
	m.therapist_id = &u
}

// TherapistID returns the value of the "therapist_id" field in the mutation.
func (m *TimeSlotMutation) TherapistID() (r uuid.UUID, exists bool) {
	v := m.therapist_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTherapistID returns the old "therapist_id" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldTherapistID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTherapistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTherapistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTherapistID: %w", err)
	}
	return oldValue.TherapistID, nil
}

// ResetTherapistID resets all changes to the "therapist_id" field.
func (m *TimeSlotMutation) ResetTherapistID() {
	m.therapist_id = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *TimeSlotMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *TimeSlotMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *TimeSlotMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *TimeSlotMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TimeSlotMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TimeSlotMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *TimeSlotMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *TimeSlotMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *TimeSlotMutation) ResetEndTime() {
	m.end_time = nil
}

// SetStatus sets the "status" field.
func (m *TimeSlotMutation) SetStatus(t timeslot.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TimeSlotMutation) Status() (r timeslot.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldStatus(ctx context.Context) (v timeslot.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TimeSlotMutation) ResetStatus() {
	m.status = nil
}

// SetSessionPrice sets the "session_price" field.
func (m *TimeSlotMutation) SetSessionPrice(i int64) {
	m.session_price = &i
	m.addsession_price = nil
}

// SessionPrice returns the value of the "session_price" field in the mutation.
func (m *TimeSlotMutation) SessionPrice() (r int64, exists bool) {
	v := m.session_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionPrice returns the old "session_price" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldSessionPrice(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionPrice: %w", err)
	}
	return oldValue.SessionPrice, nil
}

// AddSessionPrice adds i to the "session_price" field.
func (m *TimeSlotMutation) AddSessionPrice(i int64) {
	if m.addsession_price != nil {
		*m.addsession_price += i
	} else {
		m.addsession_price = &i
	}
}

// AddedSessionPrice returns the value that was added to the "session_price" field in this mutation.
func (m *TimeSlotMutation) AddedSessionPrice() (r int64, exists bool) {
	v := m.addsession_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearSessionPrice clears the value of the "session_price" field.
func (m *TimeSlotMutation) ClearSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
	m.clearedFields[timeslot.FieldSessionPrice] = struct{}{}
}

// SessionPriceCleared returns if the "session_price" field was cleared in this mutation.
func (m *TimeSlotMutation) SessionPriceCleared() bool {
	_, ok := m.clearedFields[timeslot.FieldSessionPrice]
	return ok
}

// ResetSessionPrice resets all changes to the "session_price" field.
func (m *TimeSlotMutation) ResetSessionPrice() {
	m.session_price = nil
	m.addsession_price = nil
	delete(m.clearedFields, timeslot.FieldSessionPrice)
}

// SetReservationFee sets the "reservation_fee" field.
func (m *TimeSlotMutation) SetReservationFee(i int64) {
	m.reservation_fee = &i
	m.addreservation_fee = nil
}

// ReservationFee returns the value of the "reservation_fee" field in the mutation.
func (m *TimeSlotMutation) ReservationFee() (r int64, exists bool) {
	v := m.reservation_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationFee returns the old "reservation_fee" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldReservationFee(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationFee: %w", err)
	}
	return oldValue.ReservationFee, nil
}

// AddReservationFee adds i to the "reservation_fee" field.
func (m *TimeSlotMutation) AddReservationFee(i int64) {
	if m.addreservation_fee != nil {
		*m.addreservation_fee += i
	} else {
		m.addreservation_fee = &i
	}
}

// AddedReservationFee returns the value that was added to the "reservation_fee" field in this mutation.
func (m *TimeSlotMutation) AddedReservationFee() (r int64, exists bool) {
	v := m.addreservation_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservationFee clears the value of the "reservation_fee" field.
func (m *TimeSlotMutation) ClearReservationFee() {
	m.reservation_fee = nil
	m.addreservation_fee = nil
	m.clearedFields[timeslot.FieldReservationFee] = struct{}{}
}

// ReservationFeeCleared returns if the "reservation_fee" field was cleared in this mutation.
func (m *TimeSlotMutation) ReservationFeeCleared() bool {
	_, ok := m.clearedFields[timeslot.FieldReservationFee]
	return ok
}

// ResetReservationFee resets all changes to the "reservation_fee" field.
func (m *TimeSlotMutation) ResetReservationFee() {
	m.reservation_fee = nil
	m.addreservation_fee = nil
	delete(m.clearedFields, timeslot.FieldReservationFee)
}

// SetIsRecurring sets the "is_recurring" field.
func (m *TimeSlotMutation) SetIsRecurring(b bool) {
	m.is_recurring = &b
}

// IsRecurring returns the value of the "is_recurring" field in the mutation.
func (m *TimeSlotMutation) IsRecurring() (r bool, exists bool) {
	v := m.is_recurring
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecurring returns the old "is_recurring" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldIsRecurring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecurring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecurring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecurring: %w", err)
	}
	return oldValue.IsRecurring, nil
}

// ResetIsRecurring resets all changes to the "is_recurring" field.
func (m *TimeSlotMutation) ResetIsRecurring() {
	m.is_recurring = nil
}

// SetRecurringRuleID sets the "recurring_rule_id" field.
func (m *TimeSlotMutation) SetRecurringRuleID(u uuid.UUID) {
	m.recurring_rule_id = &u
}

// RecurringRuleID returns the value of the "recurring_rule_id" field in the mutation.
func (m *TimeSlotMutation) RecurringRuleID() (r uuid.UUID, exists bool) {
	v := m.recurring_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurringRuleID returns the old "recurring_rule_id" field's value of the TimeSlot entity.
// If the TimeSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeSlotMutation) OldRecurringRuleID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurringRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurringRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurringRuleID: %w", err)
	}
	return oldValue.RecurringRuleID, nil
}

// ClearRecurringRuleID clears the value of the "recurring_rule_id" field.
func (m *TimeSlotMutation) ClearRecurringRuleID() {
	m.recurring_rule_id = nil
	m.clearedFields[timeslot.FieldRecurringRuleID] = struct{}{}
}

// RecurringRuleIDCleared returns if the "recurring_rule_id" field was cleared in this mutation.
func (m *TimeSlotMutation) RecurringRuleIDCleared() bool {
	_, ok := m.clearedFields[timeslot.FieldRecurringRuleID]
	return ok
}

// ResetRecurringRuleID resets all changes to the "recurring_rule_id" field.
func (m *TimeSlotMutation) ResetRecurringRuleID() {
	m.recurring_rule_id = nil
	delete(m.clearedFields, timeslot.FieldRecurringRuleID)
}

// Where appends a list predicates to the TimeSlotMutation builder.
func (m *TimeSlotMutation) Where(ps ...predicate.TimeSlot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeSlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeSlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeSlot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeSlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeSlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeSlot).
func (m *TimeSlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeSlotMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, timeslot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timeslot.FieldUpdatedAt)
	}
	if m.therapist_id != nil {
		fields = append(fields, timeslot.FieldTherapistID)
	}
	if m.clinic_id != nil {
		fields = append(fields, timeslot.FieldClinicID)
	}
	if m.start_time != nil {
		fields = append(fields, timeslot.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, timeslot.FieldEndTime)
	}
	if m.status != nil {
		fields = append(fields, timeslot.FieldStatus)
	}
	if m.session_price != nil {
		fields = append(fields, timeslot.FieldSessionPrice)
	}
	if m.reservation_fee != nil {
		fields = append(fields, timeslot.FieldReservationFee)
	}
	if m.is_recurring != nil {
		fields = append(fields, timeslot.FieldIsRecurring)
	}
	if m.recurring_rule_id != nil {
		fields = append(fields, timeslot.FieldRecurringRuleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeSlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeslot.FieldCreatedAt:
		return m.CreatedAt()
	case timeslot.FieldUpdatedAt:
		return m.UpdatedAt()
	case timeslot.FieldTherapistID:
		return m.TherapistID()
	case timeslot.FieldClinicID:
		return m.ClinicID()
	case timeslot.FieldStartTime:
		return m.StartTime()
	case timeslot.FieldEndTime:
		return m.EndTime()
	case timeslot.FieldStatus:
		return m.Status()
	case timeslot.FieldSessionPrice:
		return m.SessionPrice()
	case timeslot.FieldReservationFee:
		return m.ReservationFee()
	case timeslot.FieldIsRecurring:
		return m.IsRecurring()
	case timeslot.FieldRecurringRuleID:
		return m.RecurringRuleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeSlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeslot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeslot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case timeslot.FieldTherapistID:
		return m.OldTherapistID(ctx)
	case timeslot.FieldClinicID:
		return m.OldClinicID(ctx)
	case timeslot.FieldStartTime:
		return m.OldStartTime(ctx)
	case timeslot.FieldEndTime:
		return m.OldEndTime(ctx)
	case timeslot.FieldStatus:
		return m.OldStatus(ctx)
	case timeslot.FieldSessionPrice:
		return m.OldSessionPrice(ctx)
	case timeslot.FieldReservationFee:
		return m.OldReservationFee(ctx)
	case timeslot.FieldIsRecurring:
		return m.OldIsRecurring(ctx)
	case timeslot.FieldRecurringRuleID:
		return m.OldRecurringRuleID(ctx)
	}
	return nil, fmt.Errorf("unknown TimeSlot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeSlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeslot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeslot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case timeslot.FieldTherapistID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTherapistID(v)
		return nil
	case timeslot.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case timeslot.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case timeslot.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case timeslot.FieldStatus:
		v, ok := value.(timeslot.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case timeslot.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionPrice(v)
		return nil
	case timeslot.FieldReservationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationFee(v)
		return nil
	case timeslot.FieldIsRecurring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecurring(v)
		return nil
	case timeslot.FieldRecurringRuleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurringRuleID(v)
		return nil
	}
	return fmt.Errorf("unknown TimeSlot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeSlotMutation) AddedFields() []string {
	var fields []string
	if m.addsession_price != nil {
		fields = append(fields, timeslot.FieldSessionPrice)
	}
	if m.addreservation_fee != nil {
		fields = append(fields, timeslot.FieldReservationFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeSlotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeslot.FieldSessionPrice:
		return m.AddedSessionPrice()
	case timeslot.FieldReservationFee:
		return m.AddedReservationFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeSlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeslot.FieldSessionPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionPrice(v)
		return nil
	case timeslot.FieldReservationFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationFee(v)
		return nil
	}
	return fmt.Errorf("unknown TimeSlot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeSlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timeslot.FieldSessionPrice) {
		fields = append(fields, timeslot.FieldSessionPrice)
	}
	if m.FieldCleared(timeslot.FieldReservationFee) {
		fields = append(fields, timeslot.FieldReservationFee)
	}
	if m.FieldCleared(timeslot.FieldRecurringRuleID) {
		fields = append(fields, timeslot.FieldRecurringRuleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeSlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeSlotMutation) ClearField(name string) error {
	switch name {
	case timeslot.FieldSessionPrice:
		m.ClearSessionPrice()
		return nil
	case timeslot.FieldReservationFee:
		m.ClearReservationFee()
		return nil
	case timeslot.FieldRecurringRuleID:
		m.ClearRecurringRuleID()
		return nil
	}
	return fmt.Errorf("unknown TimeSlot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeSlotMutation) ResetField(name string) error {
	switch name {
	case timeslot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeslot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case timeslot.FieldTherapistID:
		m.ResetTherapistID()
		return nil
	case timeslot.FieldClinicID:
		m.ResetClinicID()
		return nil
	case timeslot.FieldStartTime:
		m.ResetStartTime()
		return nil
	case timeslot.FieldEndTime:
		m.ResetEndTime()
		return nil
	case timeslot.FieldStatus:
		m.ResetStatus()
		return nil
	case timeslot.FieldSessionPrice:
		m.ResetSessionPrice()
		return nil
	case timeslot.FieldReservationFee:
		m.ResetReservationFee()
		return nil
	case timeslot.FieldIsRecurring:
		m.ResetIsRecurring()
		return nil
	case timeslot.FieldRecurringRuleID:
		m.ResetRecurringRuleID()
		return nil
	}
	return fmt.Errorf("unknown TimeSlot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeSlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeSlotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeSlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeSlotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeSlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeSlotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeSlotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TimeSlot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeSlotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TimeSlot edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	_type             *transaction.Type
	amount            *int64
	addamount         *int64
	balance_before    *int64
	addbalance_before *int64
	balance_after     *int64
	addbalance_after  *int64
	entity_type       *string
	entity_id         *uuid.UUID
	description       *string
	clearedFields     map[string]struct{}
	wallet            *uuid.UUID
	clearedwallet     bool
	done              bool
	oldValue          func(context.Context) (*Transaction, error)
	predicates        []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id uuid.UUID) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWalletID sets the "wallet_id" field.
func (m *TransactionMutation) SetWalletID(u uuid.UUID) {
	m.wallet = &u
}

// WalletID returns the value of the "wallet_id" field in the mutation.
func (m *TransactionMutation) WalletID() (r uuid.UUID, exists bool) {
	v := m.wallet
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "wallet_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldWalletID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ResetWalletID resets all changes to the "wallet_id" field.
func (m *TransactionMutation) ResetWalletID() {
	m.wallet = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(t transaction.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r transaction.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v transaction.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TransactionMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetBalanceBefore sets the "balance_before" field.
func (m *TransactionMutation) SetBalanceBefore(i int64) {
	m.balance_before = &i
	m.addbalance_before = nil
}

// BalanceBefore returns the value of the "balance_before" field in the mutation.
func (m *TransactionMutation) BalanceBefore() (r int64, exists bool) {
	v := m.balance_before
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceBefore returns the old "balance_before" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBalanceBefore(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceBefore: %w", err)
	}
	return oldValue.BalanceBefore, nil
}

// AddBalanceBefore adds i to the "balance_before" field.
func (m *TransactionMutation) AddBalanceBefore(i int64) {
	if m.addbalance_before != nil {
		*m.addbalance_before += i
	} else {
		m.addbalance_before = &i
	}
}

// AddedBalanceBefore returns the value that was added to the "balance_before" field in this mutation.
func (m *TransactionMutation) AddedBalanceBefore() (r int64, exists bool) {
	v := m.addbalance_before
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceBefore resets all changes to the "balance_before" field.
func (m *TransactionMutation) ResetBalanceBefore() {
	m.balance_before = nil
	m.addbalance_before = nil
}

// SetBalanceAfter sets the "balance_after" field.
func (m *TransactionMutation) SetBalanceAfter(i int64) {
	m.balance_after = &i
	m.addbalance_after = nil
}

// BalanceAfter returns the value of the "balance_after" field in the mutation.
func (m *TransactionMutation) BalanceAfter() (r int64, exists bool) {
	v := m.balance_after
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceAfter returns the old "balance_after" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBalanceAfter(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceAfter: %w", err)
	}
	return oldValue.BalanceAfter, nil
}

// AddBalanceAfter adds i to the "balance_after" field.
func (m *TransactionMutation) AddBalanceAfter(i int64) {
	if m.addbalance_after != nil {
		*m.addbalance_after += i
	} else {
		m.addbalance_after = &i
	}
}

// AddedBalanceAfter returns the value that was added to the "balance_after" field in this mutation.
func (m *TransactionMutation) AddedBalanceAfter() (r int64, exists bool) {
	v := m.addbalance_after
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceAfter resets all changes to the "balance_after" field.
func (m *TransactionMutation) ResetBalanceAfter() {
	m.balance_after = nil
	m.addbalance_after = nil
}

// SetEntityType sets the "entity_type" field.
func (m *TransactionMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *TransactionMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldEntityType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *TransactionMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[transaction.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *TransactionMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[transaction.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *TransactionMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, transaction.FieldEntityType)
}

// SetEntityID sets the "entity_id" field.
func (m *TransactionMutation) SetEntityID(u uuid.UUID) {
	m.entity_id = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *TransactionMutation) EntityID() (r uuid.UUID, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldEntityID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *TransactionMutation) ClearEntityID() {
	m.entity_id = nil
	m.clearedFields[transaction.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *TransactionMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *TransactionMutation) ResetEntityID() {
	m.entity_id = nil
	delete(m.clearedFields, transaction.FieldEntityID)
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transaction.FieldDescription)
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *TransactionMutation) ClearWallet() {
	m.clearedwallet = true
	m.clearedFields[transaction.FieldWalletID] = struct{}{}
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *TransactionMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) WalletIDs() (ids []uuid.UUID) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *TransactionMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.wallet != nil {
		fields = append(fields, transaction.FieldWalletID)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.balance_before != nil {
		fields = append(fields, transaction.FieldBalanceBefore)
	}
	if m.balance_after != nil {
		fields = append(fields, transaction.FieldBalanceAfter)
	}
	if m.entity_type != nil {
		fields = append(fields, transaction.FieldEntityType)
	}
	if m.entity_id != nil {
		fields = append(fields, transaction.FieldEntityID)
	}
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldWalletID:
		return m.WalletID()
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldBalanceBefore:
		return m.BalanceBefore()
	case transaction.FieldBalanceAfter:
		return m.BalanceAfter()
	case transaction.FieldEntityType:
		return m.EntityType()
	case transaction.FieldEntityID:
		return m.EntityID()
	case transaction.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldWalletID:
		return m.OldWalletID(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldBalanceBefore:
		return m.OldBalanceBefore(ctx)
	case transaction.FieldBalanceAfter:
		return m.OldBalanceAfter(ctx)
	case transaction.FieldEntityType:
		return m.OldEntityType(ctx)
	case transaction.FieldEntityID:
		return m.OldEntityID(ctx)
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldWalletID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(transaction.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldBalanceBefore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceBefore(v)
		return nil
	case transaction.FieldBalanceAfter:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceAfter(v)
		return nil
	case transaction.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case transaction.FieldEntityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.addbalance_before != nil {
		fields = append(fields, transaction.FieldBalanceBefore)
	}
	if m.addbalance_after != nil {
		fields = append(fields, transaction.FieldBalanceAfter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	case transaction.FieldBalanceBefore:
		return m.AddedBalanceBefore()
	case transaction.FieldBalanceAfter:
		return m.AddedBalanceAfter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transaction.FieldBalanceBefore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceBefore(v)
		return nil
	case transaction.FieldBalanceAfter:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceAfter(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldEntityType) {
		fields = append(fields, transaction.FieldEntityType)
	}
	if m.FieldCleared(transaction.FieldEntityID) {
		fields = append(fields, transaction.FieldEntityID)
	}
	if m.FieldCleared(transaction.FieldDescription) {
		fields = append(fields, transaction.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldEntityType:
		m.ClearEntityType()
		return nil
	case transaction.FieldEntityID:
		m.ClearEntityID()
		return nil
	case transaction.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldWalletID:
		m.ResetWalletID()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldBalanceBefore:
		m.ResetBalanceBefore()
		return nil
	case transaction.FieldBalanceAfter:
		m.ResetBalanceAfter()
		return nil
	case transaction.FieldEntityType:
		m.ResetEntityType()
		return nil
	case transaction.FieldEntityID:
		m.ResetEntityID()
		return nil
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.wallet != nil {
		edges = append(edges, transaction.EdgeWallet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwallet {
		edges = append(edges, transaction.EdgeWallet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeWallet:
		return m.clearedwallet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeWallet:
		m.ResetWallet()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	first_name               *string
	last_name                *string
	phone                    *string
	email                    *string
	national_id              *string
	national_id_hash         *string
	gender                   *string
	marital_status           *string
	birth_year               *int
	addbirth_year            *int
	avatar_key               *string
	password_hash            *string
	must_change_password     *bool
	status                   *user.Status
	phone_verified           *bool
	email_verified           *bool
	twofa_phone_enabled      *bool
	twofa_email_enabled      *bool
	last_login_at            *time.Time
	failed_login_attempts    *int
	addfailed_login_attempts *int
	locked_until             *time.Time
	last_failed_login_at     *time.Time
	metadata                 *map[string]interface{}
	suspended_at             *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetNationalID sets the "national_id" field.
func (m *UserMutation) SetNationalID(s string) {
	m.national_id = &s
}

// NationalID returns the value of the "national_id" field in the mutation.
func (m *UserMutation) NationalID() (r string, exists bool) {
	v := m.national_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNationalID returns the old "national_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNationalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNationalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNationalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNationalID: %w", err)
	}
	return oldValue.NationalID, nil
}

// ClearNationalID clears the value of the "national_id" field.
func (m *UserMutation) ClearNationalID() {
	m.national_id = nil
	m.clearedFields[user.FieldNationalID] = struct{}{}
}

// NationalIDCleared returns if the "national_id" field was cleared in this mutation.
func (m *UserMutation) NationalIDCleared() bool {
	_, ok := m.clearedFields[user.FieldNationalID]
	return ok
}

// ResetNationalID resets all changes to the "national_id" field.
func (m *UserMutation) ResetNationalID() {
	m.national_id = nil
	delete(m.clearedFields, user.FieldNationalID)
}

// SetNationalIDHash sets the "national_id_hash" field.
func (m *UserMutation) SetNationalIDHash(s string) {
	m.national_id_hash = &s
}

// NationalIDHash returns the value of the "national_id_hash" field in the mutation.
func (m *UserMutation) NationalIDHash() (r string, exists bool) {
	v := m.national_id_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldNationalIDHash returns the old "national_id_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNationalIDHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNationalIDHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNationalIDHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNationalIDHash: %w", err)
	}
	return oldValue.NationalIDHash, nil
}

// ClearNationalIDHash clears the value of the "national_id_hash" field.
func (m *UserMutation) ClearNationalIDHash() {
	m.national_id_hash = nil
	m.clearedFields[user.FieldNationalIDHash] = struct{}{}
}

// NationalIDHashCleared returns if the "national_id_hash" field was cleared in this mutation.
func (m *UserMutation) NationalIDHashCleared() bool {
	_, ok := m.clearedFields[user.FieldNationalIDHash]
	return ok
}

// ResetNationalIDHash resets all changes to the "national_id_hash" field.
func (m *UserMutation) ResetNationalIDHash() {
	m.national_id_hash = nil
	delete(m.clearedFields, user.FieldNationalIDHash)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetMaritalStatus sets the "marital_status" field.
func (m *UserMutation) SetMaritalStatus(s string) {
	m.marital_status = &s
}

// MaritalStatus returns the value of the "marital_status" field in the mutation.
func (m *UserMutation) MaritalStatus() (r string, exists bool) {
	v := m.marital_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMaritalStatus returns the old "marital_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMaritalStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaritalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaritalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaritalStatus: %w", err)
	}
	return oldValue.MaritalStatus, nil
}

// ClearMaritalStatus clears the value of the "marital_status" field.
func (m *UserMutation) ClearMaritalStatus() {
	m.marital_status = nil
	m.clearedFields[user.FieldMaritalStatus] = struct{}{}
}

// MaritalStatusCleared returns if the "marital_status" field was cleared in this mutation.
func (m *UserMutation) MaritalStatusCleared() bool {
	_, ok := m.clearedFields[user.FieldMaritalStatus]
	return ok
}

// ResetMaritalStatus resets all changes to the "marital_status" field.
func (m *UserMutation) ResetMaritalStatus() {
	m.marital_status = nil
	delete(m.clearedFields, user.FieldMaritalStatus)
}

// SetBirthYear sets the "birth_year" field.
func (m *UserMutation) SetBirthYear(i int) {
	m.birth_year = &i
	m.addbirth_year = nil
}

// BirthYear returns the value of the "birth_year" field in the mutation.
func (m *UserMutation) BirthYear() (r int, exists bool) {
	v := m.birth_year
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthYear returns the old "birth_year" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthYear: %w", err)
	}
	return oldValue.BirthYear, nil
}

// AddBirthYear adds i to the "birth_year" field.
func (m *UserMutation) AddBirthYear(i int) {
	if m.addbirth_year != nil {
		*m.addbirth_year += i
	} else {
		m.addbirth_year = &i
	}
}

// AddedBirthYear returns the value that was added to the "birth_year" field in this mutation.
func (m *UserMutation) AddedBirthYear() (r int, exists bool) {
	v := m.addbirth_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearBirthYear clears the value of the "birth_year" field.
func (m *UserMutation) ClearBirthYear() {
	m.birth_year = nil
	m.addbirth_year = nil
	m.clearedFields[user.FieldBirthYear] = struct{}{}
}

// BirthYearCleared returns if the "birth_year" field was cleared in this mutation.
func (m *UserMutation) BirthYearCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthYear]
	return ok
}

// ResetBirthYear resets all changes to the "birth_year" field.
func (m *UserMutation) ResetBirthYear() {
	m.birth_year = nil
	m.addbirth_year = nil
	delete(m.clearedFields, user.FieldBirthYear)
}

// SetAvatarKey sets the "avatar_key" field.
func (m *UserMutation) SetAvatarKey(s string) {
	m.avatar_key = &s
}

// AvatarKey returns the value of the "avatar_key" field in the mutation.
func (m *UserMutation) AvatarKey() (r string, exists bool) {
	v := m.avatar_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarKey returns the old "avatar_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarKey: %w", err)
	}
	return oldValue.AvatarKey, nil
}

// ClearAvatarKey clears the value of the "avatar_key" field.
func (m *UserMutation) ClearAvatarKey() {
	m.avatar_key = nil
	m.clearedFields[user.FieldAvatarKey] = struct{}{}
}

// AvatarKeyCleared returns if the "avatar_key" field was cleared in this mutation.
func (m *UserMutation) AvatarKeyCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarKey]
	return ok
}

// ResetAvatarKey resets all changes to the "avatar_key" field.
func (m *UserMutation) ResetAvatarKey() {
	m.avatar_key = nil
	delete(m.clearedFields, user.FieldAvatarKey)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetMustChangePassword sets the "must_change_password" field.
func (m *UserMutation) SetMustChangePassword(b bool) {
	m.must_change_password = &b
}

// MustChangePassword returns the value of the "must_change_password" field in the mutation.
func (m *UserMutation) MustChangePassword() (r bool, exists bool) {
	v := m.must_change_password
	if v == nil {
		return
	}
	return *v, true
}

// OldMustChangePassword returns the old "must_change_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMustChangePassword(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMustChangePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMustChangePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMustChangePassword: %w", err)
	}
	return oldValue.MustChangePassword, nil
}

// ResetMustChangePassword resets all changes to the "must_change_password" field.
func (m *UserMutation) ResetMustChangePassword() {
	m.must_change_password = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetTwofaPhoneEnabled sets the "twofa_phone_enabled" field.
func (m *UserMutation) SetTwofaPhoneEnabled(b bool) {
	m.twofa_phone_enabled = &b
}

// TwofaPhoneEnabled returns the value of the "twofa_phone_enabled" field in the mutation.
func (m *UserMutation) TwofaPhoneEnabled() (r bool, exists bool) {
	v := m.twofa_phone_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTwofaPhoneEnabled returns the old "twofa_phone_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTwofaPhoneEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwofaPhoneEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwofaPhoneEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwofaPhoneEnabled: %w", err)
	}
	return oldValue.TwofaPhoneEnabled, nil
}

// ResetTwofaPhoneEnabled resets all changes to the "twofa_phone_enabled" field.
func (m *UserMutation) ResetTwofaPhoneEnabled() {
	m.twofa_phone_enabled = nil
}

// SetTwofaEmailEnabled sets the "twofa_email_enabled" field.
func (m *UserMutation) SetTwofaEmailEnabled(b bool) {
	m.twofa_email_enabled = &b
}

// TwofaEmailEnabled returns the value of the "twofa_email_enabled" field in the mutation.
func (m *UserMutation) TwofaEmailEnabled() (r bool, exists bool) {
	v := m.twofa_email_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTwofaEmailEnabled returns the old "twofa_email_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTwofaEmailEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwofaEmailEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwofaEmailEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwofaEmailEnabled: %w", err)
	}
	return oldValue.TwofaEmailEnabled, nil
}

// ResetTwofaEmailEnabled resets all changes to the "twofa_email_enabled" field.
func (m *UserMutation) ResetTwofaEmailEnabled() {
	m.twofa_email_enabled = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetFailedLoginAttempts sets the "failed_login_attempts" field.
func (m *UserMutation) SetFailedLoginAttempts(i int) {
	m.failed_login_attempts = &i
	m.addfailed_login_attempts = nil
}

// FailedLoginAttempts returns the value of the "failed_login_attempts" field in the mutation.
func (m *UserMutation) FailedLoginAttempts() (r int, exists bool) {
	v := m.failed_login_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedLoginAttempts returns the old "failed_login_attempts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFailedLoginAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedLoginAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedLoginAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedLoginAttempts: %w", err)
	}
	return oldValue.FailedLoginAttempts, nil
}

// AddFailedLoginAttempts adds i to the "failed_login_attempts" field.
func (m *UserMutation) AddFailedLoginAttempts(i int) {
	if m.addfailed_login_attempts != nil {
		*m.addfailed_login_attempts += i
	} else {
		m.addfailed_login_attempts = &i
	}
}

// AddedFailedLoginAttempts returns the value that was added to the "failed_login_attempts" field in this mutation.
func (m *UserMutation) AddedFailedLoginAttempts() (r int, exists bool) {
	v := m.addfailed_login_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedLoginAttempts resets all changes to the "failed_login_attempts" field.
func (m *UserMutation) ResetFailedLoginAttempts() {
	m.failed_login_attempts = nil
	m.addfailed_login_attempts = nil
}

// SetLockedUntil sets the "locked_until" field.
func (m *UserMutation) SetLockedUntil(t time.Time) {
	m.locked_until = &t
}

// LockedUntil returns the value of the "locked_until" field in the mutation.
func (m *UserMutation) LockedUntil() (r time.Time, exists bool) {
	v := m.locked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedUntil returns the old "locked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedUntil: %w", err)
	}
	return oldValue.LockedUntil, nil
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (m *UserMutation) ClearLockedUntil() {
	m.locked_until = nil
	m.clearedFields[user.FieldLockedUntil] = struct{}{}
}

// LockedUntilCleared returns if the "locked_until" field was cleared in this mutation.
func (m *UserMutation) LockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedUntil]
	return ok
}

// ResetLockedUntil resets all changes to the "locked_until" field.
func (m *UserMutation) ResetLockedUntil() {
	m.locked_until = nil
	delete(m.clearedFields, user.FieldLockedUntil)
}

// SetLastFailedLoginAt sets the "last_failed_login_at" field.
func (m *UserMutation) SetLastFailedLoginAt(t time.Time) {
	m.last_failed_login_at = &t
}

// LastFailedLoginAt returns the value of the "last_failed_login_at" field in the mutation.
func (m *UserMutation) LastFailedLoginAt() (r time.Time, exists bool) {
	v := m.last_failed_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailedLoginAt returns the old "last_failed_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastFailedLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailedLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailedLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailedLoginAt: %w", err)
	}
	return oldValue.LastFailedLoginAt, nil
}

// ClearLastFailedLoginAt clears the value of the "last_failed_login_at" field.
func (m *UserMutation) ClearLastFailedLoginAt() {
	m.last_failed_login_at = nil
	m.clearedFields[user.FieldLastFailedLoginAt] = struct{}{}
}

// LastFailedLoginAtCleared returns if the "last_failed_login_at" field was cleared in this mutation.
func (m *UserMutation) LastFailedLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastFailedLoginAt]
	return ok
}

// ResetLastFailedLoginAt resets all changes to the "last_failed_login_at" field.
func (m *UserMutation) ResetLastFailedLoginAt() {
	m.last_failed_login_at = nil
	delete(m.clearedFields, user.FieldLastFailedLoginAt)
}

// SetMetadata sets the "metadata" field.
func (m *UserMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[user.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[user.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, user.FieldMetadata)
}

// SetSuspendedAt sets the "suspended_at" field.
func (m *UserMutation) SetSuspendedAt(t time.Time) {
	m.suspended_at = &t
}

// SuspendedAt returns the value of the "suspended_at" field in the mutation.
func (m *UserMutation) SuspendedAt() (r time.Time, exists bool) {
	v := m.suspended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedAt returns the old "suspended_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSuspendedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedAt: %w", err)
	}
	return oldValue.SuspendedAt, nil
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (m *UserMutation) ClearSuspendedAt() {
	m.suspended_at = nil
	m.clearedFields[user.FieldSuspendedAt] = struct{}{}
}

// SuspendedAtCleared returns if the "suspended_at" field was cleared in this mutation.
func (m *UserMutation) SuspendedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldSuspendedAt]
	return ok
}

// ResetSuspendedAt resets all changes to the "suspended_at" field.
func (m *UserMutation) ResetSuspendedAt() {
	m.suspended_at = nil
	delete(m.clearedFields, user.FieldSuspendedAt)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.national_id != nil {
		fields = append(fields, user.FieldNationalID)
	}
	if m.national_id_hash != nil {
		fields = append(fields, user.FieldNationalIDHash)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.marital_status != nil {
		fields = append(fields, user.FieldMaritalStatus)
	}
	if m.birth_year != nil {
		fields = append(fields, user.FieldBirthYear)
	}
	if m.avatar_key != nil {
		fields = append(fields, user.FieldAvatarKey)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.must_change_password != nil {
		fields = append(fields, user.FieldMustChangePassword)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.twofa_phone_enabled != nil {
		fields = append(fields, user.FieldTwofaPhoneEnabled)
	}
	if m.twofa_email_enabled != nil {
		fields = append(fields, user.FieldTwofaEmailEnabled)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.failed_login_attempts != nil {
		fields = append(fields, user.FieldFailedLoginAttempts)
	}
	if m.locked_until != nil {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.last_failed_login_at != nil {
		fields = append(fields, user.FieldLastFailedLoginAt)
	}
	if m.metadata != nil {
		fields = append(fields, user.FieldMetadata)
	}
	if m.suspended_at != nil {
		fields = append(fields, user.FieldSuspendedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldEmail:
		return m.Email()
	case user.FieldNationalID:
		return m.NationalID()
	case user.FieldNationalIDHash:
		return m.NationalIDHash()
	case user.FieldGender:
		return m.Gender()
	case user.FieldMaritalStatus:
		return m.MaritalStatus()
	case user.FieldBirthYear:
		return m.BirthYear()
	case user.FieldAvatarKey:
		return m.AvatarKey()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldMustChangePassword:
		return m.MustChangePassword()
	case user.FieldStatus:
		return m.Status()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldTwofaPhoneEnabled:
		return m.TwofaPhoneEnabled()
	case user.FieldTwofaEmailEnabled:
		return m.TwofaEmailEnabled()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldFailedLoginAttempts:
		return m.FailedLoginAttempts()
	case user.FieldLockedUntil:
		return m.LockedUntil()
	case user.FieldLastFailedLoginAt:
		return m.LastFailedLoginAt()
	case user.FieldMetadata:
		return m.Metadata()
	case user.FieldSuspendedAt:
		return m.SuspendedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldNationalID:
		return m.OldNationalID(ctx)
	case user.FieldNationalIDHash:
		return m.OldNationalIDHash(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldMaritalStatus:
		return m.OldMaritalStatus(ctx)
	case user.FieldBirthYear:
		return m.OldBirthYear(ctx)
	case user.FieldAvatarKey:
		return m.OldAvatarKey(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldMustChangePassword:
		return m.OldMustChangePassword(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldTwofaPhoneEnabled:
		return m.OldTwofaPhoneEnabled(ctx)
	case user.FieldTwofaEmailEnabled:
		return m.OldTwofaEmailEnabled(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldFailedLoginAttempts:
		return m.OldFailedLoginAttempts(ctx)
	case user.FieldLockedUntil:
		return m.OldLockedUntil(ctx)
	case user.FieldLastFailedLoginAt:
		return m.OldLastFailedLoginAt(ctx)
	case user.FieldMetadata:
		return m.OldMetadata(ctx)
	case user.FieldSuspendedAt:
		return m.OldSuspendedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldNationalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNationalID(v)
		return nil
	case user.FieldNationalIDHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNationalIDHash(v)
		return nil
	case user.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldMaritalStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaritalStatus(v)
		return nil
	case user.FieldBirthYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthYear(v)
		return nil
	case user.FieldAvatarKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarKey(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldMustChangePassword:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMustChangePassword(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldTwofaPhoneEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwofaPhoneEnabled(v)
		return nil
	case user.FieldTwofaEmailEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwofaEmailEnabled(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldFailedLoginAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedLoginAttempts(v)
		return nil
	case user.FieldLockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedUntil(v)
		return nil
	case user.FieldLastFailedLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailedLoginAt(v)
		return nil
	case user.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case user.FieldSuspendedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addbirth_year != nil {
		fields = append(fields, user.FieldBirthYear)
	}
	if m.addfailed_login_attempts != nil {
		fields = append(fields, user.FieldFailedLoginAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBirthYear:
		return m.AddedBirthYear()
	case user.FieldFailedLoginAttempts:
		return m.AddedFailedLoginAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBirthYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthYear(v)
		return nil
	case user.FieldFailedLoginAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedLoginAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldNationalID) {
		fields = append(fields, user.FieldNationalID)
	}
	if m.FieldCleared(user.FieldNationalIDHash) {
		fields = append(fields, user.FieldNationalIDHash)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldMaritalStatus) {
		fields = append(fields, user.FieldMaritalStatus)
	}
	if m.FieldCleared(user.FieldBirthYear) {
		fields = append(fields, user.FieldBirthYear)
	}
	if m.FieldCleared(user.FieldAvatarKey) {
		fields = append(fields, user.FieldAvatarKey)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldLockedUntil) {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.FieldCleared(user.FieldLastFailedLoginAt) {
		fields = append(fields, user.FieldLastFailedLoginAt)
	}
	if m.FieldCleared(user.FieldMetadata) {
		fields = append(fields, user.FieldMetadata)
	}
	if m.FieldCleared(user.FieldSuspendedAt) {
		fields = append(fields, user.FieldSuspendedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldNationalID:
		m.ClearNationalID()
		return nil
	case user.FieldNationalIDHash:
		m.ClearNationalIDHash()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldMaritalStatus:
		m.ClearMaritalStatus()
		return nil
	case user.FieldBirthYear:
		m.ClearBirthYear()
		return nil
	case user.FieldAvatarKey:
		m.ClearAvatarKey()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldLockedUntil:
		m.ClearLockedUntil()
		return nil
	case user.FieldLastFailedLoginAt:
		m.ClearLastFailedLoginAt()
		return nil
	case user.FieldMetadata:
		m.ClearMetadata()
		return nil
	case user.FieldSuspendedAt:
		m.ClearSuspendedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldNationalID:
		m.ResetNationalID()
		return nil
	case user.FieldNationalIDHash:
		m.ResetNationalIDHash()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldMaritalStatus:
		m.ResetMaritalStatus()
		return nil
	case user.FieldBirthYear:
		m.ResetBirthYear()
		return nil
	case user.FieldAvatarKey:
		m.ResetAvatarKey()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldMustChangePassword:
		m.ResetMustChangePassword()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldTwofaPhoneEnabled:
		m.ResetTwofaPhoneEnabled()
		return nil
	case user.FieldTwofaEmailEnabled:
		m.ResetTwofaEmailEnabled()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldFailedLoginAttempts:
		m.ResetFailedLoginAttempts()
		return nil
	case user.FieldLockedUntil:
		m.ResetLockedUntil()
		return nil
	case user.FieldLastFailedLoginAt:
		m.ResetLastFailedLoginAt()
		return nil
	case user.FieldMetadata:
		m.ResetMetadata()
		return nil
	case user.FieldSuspendedAt:
		m.ResetSuspendedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	user_id       *uuid.UUID
	device_token  *string
	platform      *userdevice.Platform
	is_active     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserDevice, error)
	predicates    []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id uuid.UUID) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user_id = nil
}

// SetDeviceToken sets the "device_token" field.
func (m *UserDeviceMutation) SetDeviceToken(s string) {
	m.device_token = &s
}

// DeviceToken returns the value of the "device_token" field in the mutation.
func (m *UserDeviceMutation) DeviceToken() (r string, exists bool) {
	v := m.device_token
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceToken returns the old "device_token" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceToken: %w", err)
	}
	return oldValue.DeviceToken, nil
}

// ResetDeviceToken resets all changes to the "device_token" field.
func (m *UserDeviceMutation) ResetDeviceToken() {
	m.device_token = nil
}

// SetPlatform sets the "platform" field.
func (m *UserDeviceMutation) SetPlatform(u userdevice.Platform) {
	m.platform = &u
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserDeviceMutation) Platform() (r userdevice.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldPlatform(ctx context.Context) (v userdevice.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserDeviceMutation) ResetPlatform() {
	m.platform = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserDeviceMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserDeviceMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserDeviceMutation) ResetIsActive() {
	m.is_active = nil
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device_token != nil {
		fields = append(fields, userdevice.FieldDeviceToken)
	}
	if m.platform != nil {
		fields = append(fields, userdevice.FieldPlatform)
	}
	if m.is_active != nil {
		fields = append(fields, userdevice.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceToken:
		return m.DeviceToken()
	case userdevice.FieldPlatform:
		return m.Platform()
	case userdevice.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceToken:
		return m.OldDeviceToken(ctx)
	case userdevice.FieldPlatform:
		return m.OldPlatform(ctx)
	case userdevice.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceToken(v)
		return nil
	case userdevice.FieldPlatform:
		v, ok := value.(userdevice.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case userdevice.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceToken:
		m.ResetDeviceToken()
		return nil
	case userdevice.FieldPlatform:
		m.ResetPlatform()
		return nil
	case userdevice.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	session_id         *string
	refresh_token_hash *string
	user_agent         *string
	ip_address         *string
	expires_at         *time.Time
	last_used_at       *time.Time
	revoked_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserSession, error)
	predicates         []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id uuid.UUID) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSession entities.
func (m *UserSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserSessionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSessionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSessionMutation) ResetUserID() {
	m.user = nil
}

// SetSessionID sets the "session_id" field.
func (m *UserSessionMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *UserSessionMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *UserSessionMutation) ResetSessionID() {
	m.session_id = nil
}

// SetRefreshTokenHash sets the "refresh_token_hash" field.
func (m *UserSessionMutation) SetRefreshTokenHash(s string) {
	m.refresh_token_hash = &s
}

// RefreshTokenHash returns the value of the "refresh_token_hash" field in the mutation.
func (m *UserSessionMutation) RefreshTokenHash() (r string, exists bool) {
	v := m.refresh_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenHash returns the old "refresh_token_hash" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldRefreshTokenHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenHash: %w", err)
	}
	return oldValue.RefreshTokenHash, nil
}

// ClearRefreshTokenHash clears the value of the "refresh_token_hash" field.
func (m *UserSessionMutation) ClearRefreshTokenHash() {
	m.refresh_token_hash = nil
	m.clearedFields[usersession.FieldRefreshTokenHash] = struct{}{}
}

// RefreshTokenHashCleared returns if the "refresh_token_hash" field was cleared in this mutation.
func (m *UserSessionMutation) RefreshTokenHashCleared() bool {
	_, ok := m.clearedFields[usersession.FieldRefreshTokenHash]
	return ok
}

// ResetRefreshTokenHash resets all changes to the "refresh_token_hash" field.
func (m *UserSessionMutation) ResetRefreshTokenHash() {
	m.refresh_token_hash = nil
	delete(m.clearedFields, usersession.FieldRefreshTokenHash)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[usersession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[usersession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, usersession.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *UserSessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserSessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserSessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[usersession.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserSessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[usersession.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserSessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, usersession.FieldIPAddress)
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *UserSessionMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *UserSessionMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *UserSessionMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[usersession.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *UserSessionMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[usersession.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *UserSessionMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, usersession.FieldLastUsedAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *UserSessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *UserSessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *UserSessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[usersession.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *UserSessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[usersession.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *UserSessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, usersession.FieldRevokedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, usersession.FieldUserID)
	}
	if m.session_id != nil {
		fields = append(fields, usersession.FieldSessionID)
	}
	if m.refresh_token_hash != nil {
		fields = append(fields, usersession.FieldRefreshTokenHash)
	}
	if m.user_agent != nil {
		fields = append(fields, usersession.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, usersession.FieldIPAddress)
	}
	if m.expires_at != nil {
		fields = append(fields, usersession.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, usersession.FieldLastUsedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, usersession.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	case usersession.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersession.FieldUserID:
		return m.UserID()
	case usersession.FieldSessionID:
		return m.SessionID()
	case usersession.FieldRefreshTokenHash:
		return m.RefreshTokenHash()
	case usersession.FieldUserAgent:
		return m.UserAgent()
	case usersession.FieldIPAddress:
		return m.IPAddress()
	case usersession.FieldExpiresAt:
		return m.ExpiresAt()
	case usersession.FieldLastUsedAt:
		return m.LastUsedAt()
	case usersession.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersession.FieldUserID:
		return m.OldUserID(ctx)
	case usersession.FieldSessionID:
		return m.OldSessionID(ctx)
	case usersession.FieldRefreshTokenHash:
		return m.OldRefreshTokenHash(ctx)
	case usersession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case usersession.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case usersession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersession.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case usersession.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersession.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersession.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case usersession.FieldRefreshTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenHash(v)
		return nil
	case usersession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case usersession.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case usersession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersession.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case usersession.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersession.FieldRefreshTokenHash) {
		fields = append(fields, usersession.FieldRefreshTokenHash)
	}
	if m.FieldCleared(usersession.FieldUserAgent) {
		fields = append(fields, usersession.FieldUserAgent)
	}
	if m.FieldCleared(usersession.FieldIPAddress) {
		fields = append(fields, usersession.FieldIPAddress)
	}
	if m.FieldCleared(usersession.FieldLastUsedAt) {
		fields = append(fields, usersession.FieldLastUsedAt)
	}
	if m.FieldCleared(usersession.FieldRevokedAt) {
		fields = append(fields, usersession.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	switch name {
	case usersession.FieldRefreshTokenHash:
		m.ClearRefreshTokenHash()
		return nil
	case usersession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case usersession.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case usersession.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case usersession.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersession.FieldUserID:
		m.ResetUserID()
		return nil
	case usersession.FieldSessionID:
		m.ResetSessionID()
		return nil
	case usersession.FieldRefreshTokenHash:
		m.ResetRefreshTokenHash()
		return nil
	case usersession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case usersession.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case usersession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersession.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case usersession.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	owner_type          *wallet.OwnerType
	owner_id            *uuid.UUID
	balance             *int64
	addbalance          *int64
	iban_encrypted      *string
	iban_hash           *string
	account_holder      *string
	clearedFields       map[string]struct{}
	transactions        map[uuid.UUID]struct{}
	removedtransactions map[uuid.UUID]struct{}
	clearedtransactions bool
	withdrawals         map[uuid.UUID]struct{}
	removedwithdrawals  map[uuid.UUID]struct{}
	clearedwithdrawals  bool
	done                bool
	oldValue            func(context.Context) (*Wallet, error)
	predicates          []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id uuid.UUID) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerType sets the "owner_type" field.
func (m *WalletMutation) SetOwnerType(wt wallet.OwnerType) {
	m.owner_type = &wt
}

// OwnerType returns the value of the "owner_type" field in the mutation.
func (m *WalletMutation) OwnerType() (r wallet.OwnerType, exists bool) {
	v := m.owner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerType returns the old "owner_type" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldOwnerType(ctx context.Context) (v wallet.OwnerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerType: %w", err)
	}
	return oldValue.OwnerType, nil
}

// ResetOwnerType resets all changes to the "owner_type" field.
func (m *WalletMutation) ResetOwnerType() {
	m.owner_type = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *WalletMutation) SetOwnerID(u uuid.UUID) {
	m.owner_id = &u
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WalletMutation) OwnerID() (r uuid.UUID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldOwnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WalletMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetBalance sets the "balance" field.
func (m *WalletMutation) SetBalance(i int64) {
	m.balance = &i
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *WalletMutation) Balance() (r int64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds i to the "balance" field.
func (m *WalletMutation) AddBalance(i int64) {
	if m.addbalance != nil {
		*m.addbalance += i
	} else {
		m.addbalance = &i
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *WalletMutation) AddedBalance() (r int64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *WalletMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetIbanEncrypted sets the "iban_encrypted" field.
func (m *WalletMutation) SetIbanEncrypted(s string) {
	m.iban_encrypted = &s
}

// IbanEncrypted returns the value of the "iban_encrypted" field in the mutation.
func (m *WalletMutation) IbanEncrypted() (r string, exists bool) {
	v := m.iban_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldIbanEncrypted returns the old "iban_encrypted" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldIbanEncrypted(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIbanEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIbanEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIbanEncrypted: %w", err)
	}
	return oldValue.IbanEncrypted, nil
}

// ClearIbanEncrypted clears the value of the "iban_encrypted" field.
func (m *WalletMutation) ClearIbanEncrypted() {
	m.iban_encrypted = nil
	m.clearedFields[wallet.FieldIbanEncrypted] = struct{}{}
}

// IbanEncryptedCleared returns if the "iban_encrypted" field was cleared in this mutation.
func (m *WalletMutation) IbanEncryptedCleared() bool {
	_, ok := m.clearedFields[wallet.FieldIbanEncrypted]
	return ok
}

// ResetIbanEncrypted resets all changes to the "iban_encrypted" field.
func (m *WalletMutation) ResetIbanEncrypted() {
	m.iban_encrypted = nil
	delete(m.clearedFields, wallet.FieldIbanEncrypted)
}

// SetIbanHash sets the "iban_hash" field.
func (m *WalletMutation) SetIbanHash(s string) {
	m.iban_hash = &s
}

// IbanHash returns the value of the "iban_hash" field in the mutation.
func (m *WalletMutation) IbanHash() (r string, exists bool) {
	v := m.iban_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldIbanHash returns the old "iban_hash" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldIbanHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIbanHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIbanHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIbanHash: %w", err)
	}
	return oldValue.IbanHash, nil
}

// ClearIbanHash clears the value of the "iban_hash" field.
func (m *WalletMutation) ClearIbanHash() {
	m.iban_hash = nil
	m.clearedFields[wallet.FieldIbanHash] = struct{}{}
}

// IbanHashCleared returns if the "iban_hash" field was cleared in this mutation.
func (m *WalletMutation) IbanHashCleared() bool {
	_, ok := m.clearedFields[wallet.FieldIbanHash]
	return ok
}

// ResetIbanHash resets all changes to the "iban_hash" field.
func (m *WalletMutation) ResetIbanHash() {
	m.iban_hash = nil
	delete(m.clearedFields, wallet.FieldIbanHash)
}

// SetAccountHolder sets the "account_holder" field.
func (m *WalletMutation) SetAccountHolder(s string) {
	m.account_holder = &s
}

// AccountHolder returns the value of the "account_holder" field in the mutation.
func (m *WalletMutation) AccountHolder() (r string, exists bool) {
	v := m.account_holder
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountHolder returns the old "account_holder" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldAccountHolder(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountHolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountHolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountHolder: %w", err)
	}
	return oldValue.AccountHolder, nil
}

// ClearAccountHolder clears the value of the "account_holder" field.
func (m *WalletMutation) ClearAccountHolder() {
	m.account_holder = nil
	m.clearedFields[wallet.FieldAccountHolder] = struct{}{}
}

// AccountHolderCleared returns if the "account_holder" field was cleared in this mutation.
func (m *WalletMutation) AccountHolderCleared() bool {
	_, ok := m.clearedFields[wallet.FieldAccountHolder]
	return ok
}

// ResetAccountHolder resets all changes to the "account_holder" field.
func (m *WalletMutation) ResetAccountHolder() {
	m.account_holder = nil
	delete(m.clearedFields, wallet.FieldAccountHolder)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *WalletMutation) AddTransactionIDs(ids ...uuid.UUID) {
	if m.transactions == nil {
		m.transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *WalletMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *WalletMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *WalletMutation) RemoveTransactionIDs(ids ...uuid.UUID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *WalletMutation) RemovedTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *WalletMutation) TransactionsIDs() (ids []uuid.UUID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *WalletMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddWithdrawalIDs adds the "withdrawals" edge to the WithdrawalRequest entity by ids.
func (m *WalletMutation) AddWithdrawalIDs(ids ...uuid.UUID) {
	if m.withdrawals == nil {
		m.withdrawals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.withdrawals[ids[i]] = struct{}{}
	}
}

// ClearWithdrawals clears the "withdrawals" edge to the WithdrawalRequest entity.
func (m *WalletMutation) ClearWithdrawals() {
	m.clearedwithdrawals = true
}

// WithdrawalsCleared reports if the "withdrawals" edge to the WithdrawalRequest entity was cleared.
func (m *WalletMutation) WithdrawalsCleared() bool {
	return m.clearedwithdrawals
}

// RemoveWithdrawalIDs removes the "withdrawals" edge to the WithdrawalRequest entity by IDs.
func (m *WalletMutation) RemoveWithdrawalIDs(ids ...uuid.UUID) {
	if m.removedwithdrawals == nil {
		m.removedwithdrawals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.withdrawals, ids[i])
		m.removedwithdrawals[ids[i]] = struct{}{}
	}
}

// RemovedWithdrawals returns the removed IDs of the "withdrawals" edge to the WithdrawalRequest entity.
func (m *WalletMutation) RemovedWithdrawalsIDs() (ids []uuid.UUID) {
	for id := range m.removedwithdrawals {
		ids = append(ids, id)
	}
	return
}

// WithdrawalsIDs returns the "withdrawals" edge IDs in the mutation.
func (m *WalletMutation) WithdrawalsIDs() (ids []uuid.UUID) {
	for id := range m.withdrawals {
		ids = append(ids, id)
	}
	return
}

// ResetWithdrawals resets all changes to the "withdrawals" edge.
func (m *WalletMutation) ResetWithdrawals() {
	m.withdrawals = nil
	m.clearedwithdrawals = false
	m.removedwithdrawals = nil
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wallet.FieldUpdatedAt)
	}
	if m.owner_type != nil {
		fields = append(fields, wallet.FieldOwnerType)
	}
	if m.owner_id != nil {
		fields = append(fields, wallet.FieldOwnerID)
	}
	if m.balance != nil {
		fields = append(fields, wallet.FieldBalance)
	}
	if m.iban_encrypted != nil {
		fields = append(fields, wallet.FieldIbanEncrypted)
	}
	if m.iban_hash != nil {
		fields = append(fields, wallet.FieldIbanHash)
	}
	if m.account_holder != nil {
		fields = append(fields, wallet.FieldAccountHolder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	case wallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case wallet.FieldOwnerType:
		return m.OwnerType()
	case wallet.FieldOwnerID:
		return m.OwnerID()
	case wallet.FieldBalance:
		return m.Balance()
	case wallet.FieldIbanEncrypted:
		return m.IbanEncrypted()
	case wallet.FieldIbanHash:
		return m.IbanHash()
	case wallet.FieldAccountHolder:
		return m.AccountHolder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wallet.FieldOwnerType:
		return m.OldOwnerType(ctx)
	case wallet.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case wallet.FieldBalance:
		return m.OldBalance(ctx)
	case wallet.FieldIbanEncrypted:
		return m.OldIbanEncrypted(ctx)
	case wallet.FieldIbanHash:
		return m.OldIbanHash(ctx)
	case wallet.FieldAccountHolder:
		return m.OldAccountHolder(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wallet.FieldOwnerType:
		v, ok := value.(wallet.OwnerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerType(v)
		return nil
	case wallet.FieldOwnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case wallet.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case wallet.FieldIbanEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIbanEncrypted(v)
		return nil
	case wallet.FieldIbanHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIbanHash(v)
		return nil
	case wallet.FieldAccountHolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountHolder(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, wallet.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wallet.FieldIbanEncrypted) {
		fields = append(fields, wallet.FieldIbanEncrypted)
	}
	if m.FieldCleared(wallet.FieldIbanHash) {
		fields = append(fields, wallet.FieldIbanHash)
	}
	if m.FieldCleared(wallet.FieldAccountHolder) {
		fields = append(fields, wallet.FieldAccountHolder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	switch name {
	case wallet.FieldIbanEncrypted:
		m.ClearIbanEncrypted()
		return nil
	case wallet.FieldIbanHash:
		m.ClearIbanHash()
		return nil
	case wallet.FieldAccountHolder:
		m.ClearAccountHolder()
		return nil
	}
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wallet.FieldOwnerType:
		m.ResetOwnerType()
		return nil
	case wallet.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case wallet.FieldBalance:
		m.ResetBalance()
		return nil
	case wallet.FieldIbanEncrypted:
		m.ResetIbanEncrypted()
		return nil
	case wallet.FieldIbanHash:
		m.ResetIbanHash()
		return nil
	case wallet.FieldAccountHolder:
		m.ResetAccountHolder()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transactions != nil {
		edges = append(edges, wallet.EdgeTransactions)
	}
	if m.withdrawals != nil {
		edges = append(edges, wallet.EdgeWithdrawals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeWithdrawals:
		ids := make([]ent.Value, 0, len(m.withdrawals))
		for id := range m.withdrawals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, wallet.EdgeTransactions)
	}
	if m.removedwithdrawals != nil {
		edges = append(edges, wallet.EdgeWithdrawals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case wallet.EdgeWithdrawals:
		ids := make([]ent.Value, 0, len(m.removedwithdrawals))
		for id := range m.removedwithdrawals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransactions {
		edges = append(edges, wallet.EdgeTransactions)
	}
	if m.clearedwithdrawals {
		edges = append(edges, wallet.EdgeWithdrawals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeTransactions:
		return m.clearedtransactions
	case wallet.EdgeWithdrawals:
		return m.clearedwithdrawals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case wallet.EdgeWithdrawals:
		m.ResetWithdrawals()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WithdrawalRequestMutation represents an operation that mutates the WithdrawalRequest nodes in the graph.
type WithdrawalRequestMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	clinic_id      *uuid.UUID
	amount         *int64
	addamount      *int64
	status         *withdrawalrequest.Status
	iban_encrypted *string
	account_holder *string
	bank_ref       *string
	requested_at   *time.Time
	processed_at   *time.Time
	failure_reason *string
	clearedFields  map[string]struct{}
	wallet         *uuid.UUID
	clearedwallet  bool
	done           bool
	oldValue       func(context.Context) (*WithdrawalRequest, error)
	predicates     []predicate.WithdrawalRequest
}

var _ ent.Mutation = (*WithdrawalRequestMutation)(nil)

// withdrawalrequestOption allows management of the mutation configuration using functional options.
type withdrawalrequestOption func(*WithdrawalRequestMutation)

// newWithdrawalRequestMutation creates new mutation for the WithdrawalRequest entity.
func newWithdrawalRequestMutation(c config, op Op, opts ...withdrawalrequestOption) *WithdrawalRequestMutation {
	m := &WithdrawalRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeWithdrawalRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWithdrawalRequestID sets the ID field of the mutation.
func withWithdrawalRequestID(id uuid.UUID) withdrawalrequestOption {
	return func(m *WithdrawalRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *WithdrawalRequest
		)
		m.oldValue = func(ctx context.Context) (*WithdrawalRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WithdrawalRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWithdrawalRequest sets the old WithdrawalRequest of the mutation.
func withWithdrawalRequest(node *WithdrawalRequest) withdrawalrequestOption {
	return func(m *WithdrawalRequestMutation) {
		m.oldValue = func(context.Context) (*WithdrawalRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WithdrawalRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WithdrawalRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("repo: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WithdrawalRequest entities.
func (m *WithdrawalRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WithdrawalRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WithdrawalRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WithdrawalRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WithdrawalRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WithdrawalRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WithdrawalRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWalletID sets the "wallet_id" field.
func (m *WithdrawalRequestMutation) SetWalletID(u uuid.UUID) {
	m.wallet = &u
}

// WalletID returns the value of the "wallet_id" field in the mutation.
func (m *WithdrawalRequestMutation) WalletID() (r uuid.UUID, exists bool) {
	v := m.wallet
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "wallet_id" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldWalletID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ResetWalletID resets all changes to the "wallet_id" field.
func (m *WithdrawalRequestMutation) ResetWalletID() {
	m.wallet = nil
}

// SetClinicID sets the "clinic_id" field.
func (m *WithdrawalRequestMutation) SetClinicID(u uuid.UUID) {
	m.clinic_id = &u
}

// ClinicID returns the value of the "clinic_id" field in the mutation.
func (m *WithdrawalRequestMutation) ClinicID() (r uuid.UUID, exists bool) {
	v := m.clinic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClinicID returns the old "clinic_id" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldClinicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClinicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClinicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClinicID: %w", err)
	}
	return oldValue.ClinicID, nil
}

// ResetClinicID resets all changes to the "clinic_id" field.
func (m *WithdrawalRequestMutation) ResetClinicID() {
	m.clinic_id = nil
}

// SetAmount sets the "amount" field.
func (m *WithdrawalRequestMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *WithdrawalRequestMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *WithdrawalRequestMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *WithdrawalRequestMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *WithdrawalRequestMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *WithdrawalRequestMutation) SetStatus(w withdrawalrequest.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WithdrawalRequestMutation) Status() (r withdrawalrequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldStatus(ctx context.Context) (v withdrawalrequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WithdrawalRequestMutation) ResetStatus() {
	m.status = nil
}

// SetIbanEncrypted sets the "iban_encrypted" field.
func (m *WithdrawalRequestMutation) SetIbanEncrypted(s string) {
	m.iban_encrypted = &s
}

// IbanEncrypted returns the value of the "iban_encrypted" field in the mutation.
func (m *WithdrawalRequestMutation) IbanEncrypted() (r string, exists bool) {
	v := m.iban_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldIbanEncrypted returns the old "iban_encrypted" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldIbanEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIbanEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIbanEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIbanEncrypted: %w", err)
	}
	return oldValue.IbanEncrypted, nil
}

// ResetIbanEncrypted resets all changes to the "iban_encrypted" field.
func (m *WithdrawalRequestMutation) ResetIbanEncrypted() {
	m.iban_encrypted = nil
}

// SetAccountHolder sets the "account_holder" field.
func (m *WithdrawalRequestMutation) SetAccountHolder(s string) {
	m.account_holder = &s
}

// AccountHolder returns the value of the "account_holder" field in the mutation.
func (m *WithdrawalRequestMutation) AccountHolder() (r string, exists bool) {
	v := m.account_holder
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountHolder returns the old "account_holder" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldAccountHolder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountHolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountHolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountHolder: %w", err)
	}
	return oldValue.AccountHolder, nil
}

// ResetAccountHolder resets all changes to the "account_holder" field.
func (m *WithdrawalRequestMutation) ResetAccountHolder() {
	m.account_holder = nil
}

// SetBankRef sets the "bank_ref" field.
func (m *WithdrawalRequestMutation) SetBankRef(s string) {
	m.bank_ref = &s
}

// BankRef returns the value of the "bank_ref" field in the mutation.
func (m *WithdrawalRequestMutation) BankRef() (r string, exists bool) {
	v := m.bank_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldBankRef returns the old "bank_ref" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldBankRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankRef: %w", err)
	}
	return oldValue.BankRef, nil
}

// ClearBankRef clears the value of the "bank_ref" field.
func (m *WithdrawalRequestMutation) ClearBankRef() {
	m.bank_ref = nil
	m.clearedFields[withdrawalrequest.FieldBankRef] = struct{}{}
}

// BankRefCleared returns if the "bank_ref" field was cleared in this mutation.
func (m *WithdrawalRequestMutation) BankRefCleared() bool {
	_, ok := m.clearedFields[withdrawalrequest.FieldBankRef]
	return ok
}

// ResetBankRef resets all changes to the "bank_ref" field.
func (m *WithdrawalRequestMutation) ResetBankRef() {
	m.bank_ref = nil
	delete(m.clearedFields, withdrawalrequest.FieldBankRef)
}

// SetRequestedAt sets the "requested_at" field.
func (m *WithdrawalRequestMutation) SetRequestedAt(t time.Time) {
	m.requested_at = &t
}

// RequestedAt returns the value of the "requested_at" field in the mutation.
func (m *WithdrawalRequestMutation) RequestedAt() (r time.Time, exists bool) {
	v := m.requested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAt returns the old "requested_at" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldRequestedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAt: %w", err)
	}
	return oldValue.RequestedAt, nil
}

// ResetRequestedAt resets all changes to the "requested_at" field.
func (m *WithdrawalRequestMutation) ResetRequestedAt() {
	m.requested_at = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *WithdrawalRequestMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *WithdrawalRequestMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldProcessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *WithdrawalRequestMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[withdrawalrequest.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *WithdrawalRequestMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[withdrawalrequest.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *WithdrawalRequestMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, withdrawalrequest.FieldProcessedAt)
}

// SetFailureReason sets the "failure_reason" field.
func (m *WithdrawalRequestMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *WithdrawalRequestMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the WithdrawalRequest entity.
// If the WithdrawalRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawalRequestMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *WithdrawalRequestMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[withdrawalrequest.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *WithdrawalRequestMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[withdrawalrequest.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *WithdrawalRequestMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, withdrawalrequest.FieldFailureReason)
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *WithdrawalRequestMutation) ClearWallet() {
	m.clearedwallet = true
	m.clearedFields[withdrawalrequest.FieldWalletID] = struct{}{}
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *WithdrawalRequestMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *WithdrawalRequestMutation) WalletIDs() (ids []uuid.UUID) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *WithdrawalRequestMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// Where appends a list predicates to the WithdrawalRequestMutation builder.
func (m *WithdrawalRequestMutation) Where(ps ...predicate.WithdrawalRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WithdrawalRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WithdrawalRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WithdrawalRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WithdrawalRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WithdrawalRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WithdrawalRequest).
func (m *WithdrawalRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WithdrawalRequestMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, withdrawalrequest.FieldCreatedAt)
	}
	if m.wallet != nil {
		fields = append(fields, withdrawalrequest.FieldWalletID)
	}
	if m.clinic_id != nil {
		fields = append(fields, withdrawalrequest.FieldClinicID)
	}
	if m.amount != nil {
		fields = append(fields, withdrawalrequest.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, withdrawalrequest.FieldStatus)
	}
	if m.iban_encrypted != nil {
		fields = append(fields, withdrawalrequest.FieldIbanEncrypted)
	}
	if m.account_holder != nil {
		fields = append(fields, withdrawalrequest.FieldAccountHolder)
	}
	if m.bank_ref != nil {
		fields = append(fields, withdrawalrequest.FieldBankRef)
	}
	if m.requested_at != nil {
		fields = append(fields, withdrawalrequest.FieldRequestedAt)
	}
	if m.processed_at != nil {
		fields = append(fields, withdrawalrequest.FieldProcessedAt)
	}
	if m.failure_reason != nil {
		fields = append(fields, withdrawalrequest.FieldFailureReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WithdrawalRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case withdrawalrequest.FieldCreatedAt:
		return m.CreatedAt()
	case withdrawalrequest.FieldWalletID:
		return m.WalletID()
	case withdrawalrequest.FieldClinicID:
		return m.ClinicID()
	case withdrawalrequest.FieldAmount:
		return m.Amount()
	case withdrawalrequest.FieldStatus:
		return m.Status()
	case withdrawalrequest.FieldIbanEncrypted:
		return m.IbanEncrypted()
	case withdrawalrequest.FieldAccountHolder:
		return m.AccountHolder()
	case withdrawalrequest.FieldBankRef:
		return m.BankRef()
	case withdrawalrequest.FieldRequestedAt:
		return m.RequestedAt()
	case withdrawalrequest.FieldProcessedAt:
		return m.ProcessedAt()
	case withdrawalrequest.FieldFailureReason:
		return m.FailureReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WithdrawalRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case withdrawalrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case withdrawalrequest.FieldWalletID:
		return m.OldWalletID(ctx)
	case withdrawalrequest.FieldClinicID:
		return m.OldClinicID(ctx)
	case withdrawalrequest.FieldAmount:
		return m.OldAmount(ctx)
	case withdrawalrequest.FieldStatus:
		return m.OldStatus(ctx)
	case withdrawalrequest.FieldIbanEncrypted:
		return m.OldIbanEncrypted(ctx)
	case withdrawalrequest.FieldAccountHolder:
		return m.OldAccountHolder(ctx)
	case withdrawalrequest.FieldBankRef:
		return m.OldBankRef(ctx)
	case withdrawalrequest.FieldRequestedAt:
		return m.OldRequestedAt(ctx)
	case withdrawalrequest.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	case withdrawalrequest.FieldFailureReason:
		return m.OldFailureReason(ctx)
	}
	return nil, fmt.Errorf("unknown WithdrawalRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawalRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case withdrawalrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case withdrawalrequest.FieldWalletID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case withdrawalrequest.FieldClinicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClinicID(v)
		return nil
	case withdrawalrequest.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case withdrawalrequest.FieldStatus:
		v, ok := value.(withdrawalrequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case withdrawalrequest.FieldIbanEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIbanEncrypted(v)
		return nil
	case withdrawalrequest.FieldAccountHolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountHolder(v)
		return nil
	case withdrawalrequest.FieldBankRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankRef(v)
		return nil
	case withdrawalrequest.FieldRequestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAt(v)
		return nil
	case withdrawalrequest.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	case withdrawalrequest.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawalRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WithdrawalRequestMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, withdrawalrequest.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WithdrawalRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case withdrawalrequest.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawalRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case withdrawalrequest.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown WithdrawalRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WithdrawalRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(withdrawalrequest.FieldBankRef) {
		fields = append(fields, withdrawalrequest.FieldBankRef)
	}
	if m.FieldCleared(withdrawalrequest.FieldProcessedAt) {
		fields = append(fields, withdrawalrequest.FieldProcessedAt)
	}
	if m.FieldCleared(withdrawalrequest.FieldFailureReason) {
		fields = append(fields, withdrawalrequest.FieldFailureReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WithdrawalRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WithdrawalRequestMutation) ClearField(name string) error {
	switch name {
	case withdrawalrequest.FieldBankRef:
		m.ClearBankRef()
		return nil
	case withdrawalrequest.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	case withdrawalrequest.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	}
	return fmt.Errorf("unknown WithdrawalRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WithdrawalRequestMutation) ResetField(name string) error {
	switch name {
	case withdrawalrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case withdrawalrequest.FieldWalletID:
		m.ResetWalletID()
		return nil
	case withdrawalrequest.FieldClinicID:
		m.ResetClinicID()
		return nil
	case withdrawalrequest.FieldAmount:
		m.ResetAmount()
		return nil
	case withdrawalrequest.FieldStatus:
		m.ResetStatus()
		return nil
	case withdrawalrequest.FieldIbanEncrypted:
		m.ResetIbanEncrypted()
		return nil
	case withdrawalrequest.FieldAccountHolder:
		m.ResetAccountHolder()
		return nil
	case withdrawalrequest.FieldBankRef:
		m.ResetBankRef()
		return nil
	case withdrawalrequest.FieldRequestedAt:
		m.ResetRequestedAt()
		return nil
	case withdrawalrequest.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	case withdrawalrequest.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	}
	return fmt.Errorf("unknown WithdrawalRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WithdrawalRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.wallet != nil {
		edges = append(edges, withdrawalrequest.EdgeWallet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WithdrawalRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case withdrawalrequest.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WithdrawalRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WithdrawalRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WithdrawalRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwallet {
		edges = append(edges, withdrawalrequest.EdgeWallet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WithdrawalRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case withdrawalrequest.EdgeWallet:
		return m.clearedwallet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WithdrawalRequestMutation) ClearEdge(name string) error {
	switch name {
	case withdrawalrequest.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown WithdrawalRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WithdrawalRequestMutation) ResetEdge(name string) error {
	switch name {
	case withdrawalrequest.EdgeWallet:
		m.ResetWallet()
		return nil
	}
	return fmt.Errorf("unknown WithdrawalRequest edge %s", name)
}
